import {
  Component,
  FirebaseError,
  LogLevel,
  Logger,
  SDK_VERSION,
  _getProvider,
  _registerComponent,
  _removeServiceInstance,
  createMockUserToken,
  deepEqual,
  getApp,
  getDefaultEmulatorHostnameAndPort,
  getModularInstance,
  getUA,
  isIndexedDBAvailable,
  isSafari,
  registerVersion
} from "./chunk-HAR62UCM.js";
import "./chunk-HUBM7RA2.js";

// node_modules/@firebase/webchannel-wrapper/dist/index.esm2017.js
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
var esm = {};
var k;
var goog = goog || {};
var l = commonjsGlobal || self;
function aa() {
}
function ba(a) {
  var b2 = typeof a;
  b2 = "object" != b2 ? b2 : a ? Array.isArray(a) ? "array" : b2 : "null";
  return "array" == b2 || "object" == b2 && "number" == typeof a.length;
}
function p(a) {
  var b2 = typeof a;
  return "object" == b2 && null != a || "function" == b2;
}
function ca(a) {
  return Object.prototype.hasOwnProperty.call(a, da) && a[da] || (a[da] = ++ea);
}
var da = "closure_uid_" + (1e9 * Math.random() >>> 0);
var ea = 0;
function fa(a, b2, c) {
  return a.call.apply(a.bind, arguments);
}
function ha(a, b2, c) {
  if (!a)
    throw Error();
  if (2 < arguments.length) {
    var d = Array.prototype.slice.call(arguments, 2);
    return function() {
      var e = Array.prototype.slice.call(arguments);
      Array.prototype.unshift.apply(e, d);
      return a.apply(b2, e);
    };
  }
  return function() {
    return a.apply(b2, arguments);
  };
}
function q(a, b2, c) {
  Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? q = fa : q = ha;
  return q.apply(null, arguments);
}
function ia(a, b2) {
  var c = Array.prototype.slice.call(arguments, 1);
  return function() {
    var d = c.slice();
    d.push.apply(d, arguments);
    return a.apply(this, d);
  };
}
function t(a, b2) {
  function c() {
  }
  c.prototype = b2.prototype;
  a.X = b2.prototype;
  a.prototype = new c();
  a.prototype.constructor = a;
  a.Wb = function(d, e, f) {
    for (var h = Array(arguments.length - 2), n = 2; n < arguments.length; n++)
      h[n - 2] = arguments[n];
    return b2.prototype[e].apply(d, h);
  };
}
function v() {
  this.s = this.s;
  this.o = this.o;
}
var ja = 0;
v.prototype.s = false;
v.prototype.na = function() {
  if (!this.s && (this.s = true, this.M(), 0 != ja)) {
    ca(this);
  }
};
v.prototype.M = function() {
  if (this.o)
    for (; this.o.length; )
      this.o.shift()();
};
var la = Array.prototype.indexOf ? function(a, b2) {
  return Array.prototype.indexOf.call(a, b2, void 0);
} : function(a, b2) {
  if ("string" === typeof a)
    return "string" !== typeof b2 || 1 != b2.length ? -1 : a.indexOf(b2, 0);
  for (let c = 0; c < a.length; c++)
    if (c in a && a[c] === b2)
      return c;
  return -1;
};
function ma(a) {
  const b2 = a.length;
  if (0 < b2) {
    const c = Array(b2);
    for (let d = 0; d < b2; d++)
      c[d] = a[d];
    return c;
  }
  return [];
}
function na(a, b2) {
  for (let c = 1; c < arguments.length; c++) {
    const d = arguments[c];
    if (ba(d)) {
      const e = a.length || 0, f = d.length || 0;
      a.length = e + f;
      for (let h = 0; h < f; h++)
        a[e + h] = d[h];
    } else
      a.push(d);
  }
}
function w(a, b2) {
  this.type = a;
  this.g = this.target = b2;
  this.defaultPrevented = false;
}
w.prototype.h = function() {
  this.defaultPrevented = true;
};
var oa = function() {
  if (!l.addEventListener || !Object.defineProperty)
    return false;
  var a = false, b2 = Object.defineProperty({}, "passive", { get: function() {
    a = true;
  } });
  try {
    l.addEventListener("test", aa, b2), l.removeEventListener("test", aa, b2);
  } catch (c) {
  }
  return a;
}();
function pa(a) {
  return /^[\s\xa0]*$/.test(a);
}
var qa = String.prototype.trim ? function(a) {
  return a.trim();
} : function(a) {
  return /^[\s\xa0]*([\s\S]*?)[\s\xa0]*$/.exec(a)[1];
};
function ra(a, b2) {
  return a < b2 ? -1 : a > b2 ? 1 : 0;
}
function sa() {
  var a = l.navigator;
  return a && (a = a.userAgent) ? a : "";
}
function x(a) {
  return -1 != sa().indexOf(a);
}
function ta(a) {
  ta[" "](a);
  return a;
}
ta[" "] = aa;
function ua(a) {
  var b2 = va;
  return Object.prototype.hasOwnProperty.call(b2, 9) ? b2[9] : b2[9] = a(9);
}
var wa = x("Opera");
var y = x("Trident") || x("MSIE");
var xa = x("Edge");
var ya = xa || y;
var za = x("Gecko") && !(-1 != sa().toLowerCase().indexOf("webkit") && !x("Edge")) && !(x("Trident") || x("MSIE")) && !x("Edge");
var Aa = -1 != sa().toLowerCase().indexOf("webkit") && !x("Edge");
function Ba() {
  var a = l.document;
  return a ? a.documentMode : void 0;
}
var Ea;
a: {
  Fa2 = "", Ga2 = function() {
    var a = sa();
    if (za)
      return /rv:([^\);]+)(\)|;)/.exec(a);
    if (xa)
      return /Edge\/([\d\.]+)/.exec(a);
    if (y)
      return /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(a);
    if (Aa)
      return /WebKit\/(\S+)/.exec(a);
    if (wa)
      return /(?:Version)[ \/]?(\S+)/.exec(a);
  }();
  Ga2 && (Fa2 = Ga2 ? Ga2[1] : "");
  if (y) {
    Ha2 = Ba();
    if (null != Ha2 && Ha2 > parseFloat(Fa2)) {
      Ea = String(Ha2);
      break a;
    }
  }
  Ea = Fa2;
}
var Fa2;
var Ga2;
var Ha2;
var va = {};
function Ia() {
  return ua(function() {
    let a = 0;
    const b2 = qa(String(Ea)).split("."), c = qa("9").split("."), d = Math.max(b2.length, c.length);
    for (let h = 0; 0 == a && h < d; h++) {
      var e = b2[h] || "", f = c[h] || "";
      do {
        e = /(\d*)(\D*)(.*)/.exec(e) || ["", "", "", ""];
        f = /(\d*)(\D*)(.*)/.exec(f) || ["", "", "", ""];
        if (0 == e[0].length && 0 == f[0].length)
          break;
        a = ra(0 == e[1].length ? 0 : parseInt(e[1], 10), 0 == f[1].length ? 0 : parseInt(f[1], 10)) || ra(0 == e[2].length, 0 == f[2].length) || ra(e[2], f[2]);
        e = e[3];
        f = f[3];
      } while (0 == a);
    }
    return 0 <= a;
  });
}
var Ja;
if (l.document && y) {
  Ka2 = Ba();
  Ja = Ka2 ? Ka2 : parseInt(Ea, 10) || void 0;
} else
  Ja = void 0;
var Ka2;
var La = Ja;
function z(a, b2) {
  w.call(this, a ? a.type : "");
  this.relatedTarget = this.g = this.target = null;
  this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0;
  this.key = "";
  this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = false;
  this.state = null;
  this.pointerId = 0;
  this.pointerType = "";
  this.i = null;
  if (a) {
    var c = this.type = a.type, d = a.changedTouches && a.changedTouches.length ? a.changedTouches[0] : null;
    this.target = a.target || a.srcElement;
    this.g = b2;
    if (b2 = a.relatedTarget) {
      if (za) {
        a: {
          try {
            ta(b2.nodeName);
            var e = true;
            break a;
          } catch (f) {
          }
          e = false;
        }
        e || (b2 = null);
      }
    } else
      "mouseover" == c ? b2 = a.fromElement : "mouseout" == c && (b2 = a.toElement);
    this.relatedTarget = b2;
    d ? (this.clientX = void 0 !== d.clientX ? d.clientX : d.pageX, this.clientY = void 0 !== d.clientY ? d.clientY : d.pageY, this.screenX = d.screenX || 0, this.screenY = d.screenY || 0) : (this.clientX = void 0 !== a.clientX ? a.clientX : a.pageX, this.clientY = void 0 !== a.clientY ? a.clientY : a.pageY, this.screenX = a.screenX || 0, this.screenY = a.screenY || 0);
    this.button = a.button;
    this.key = a.key || "";
    this.ctrlKey = a.ctrlKey;
    this.altKey = a.altKey;
    this.shiftKey = a.shiftKey;
    this.metaKey = a.metaKey;
    this.pointerId = a.pointerId || 0;
    this.pointerType = "string" === typeof a.pointerType ? a.pointerType : Ma[a.pointerType] || "";
    this.state = a.state;
    this.i = a;
    a.defaultPrevented && z.X.h.call(this);
  }
}
t(z, w);
var Ma = { 2: "touch", 3: "pen", 4: "mouse" };
z.prototype.h = function() {
  z.X.h.call(this);
  var a = this.i;
  a.preventDefault ? a.preventDefault() : a.returnValue = false;
};
var A = "closure_listenable_" + (1e6 * Math.random() | 0);
var Na = 0;
function Oa(a, b2, c, d, e) {
  this.listener = a;
  this.proxy = null;
  this.src = b2;
  this.type = c;
  this.capture = !!d;
  this.ha = e;
  this.key = ++Na;
  this.ba = this.ea = false;
}
function Pa(a) {
  a.ba = true;
  a.listener = null;
  a.proxy = null;
  a.src = null;
  a.ha = null;
}
function Qa(a, b2, c) {
  for (const d in a)
    b2.call(c, a[d], d, a);
}
function Ra(a) {
  const b2 = {};
  for (const c in a)
    b2[c] = a[c];
  return b2;
}
var Sa = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" ");
function Ta(a, b2) {
  let c, d;
  for (let e = 1; e < arguments.length; e++) {
    d = arguments[e];
    for (c in d)
      a[c] = d[c];
    for (let f = 0; f < Sa.length; f++)
      c = Sa[f], Object.prototype.hasOwnProperty.call(d, c) && (a[c] = d[c]);
  }
}
function Ua(a) {
  this.src = a;
  this.g = {};
  this.h = 0;
}
Ua.prototype.add = function(a, b2, c, d, e) {
  var f = a.toString();
  a = this.g[f];
  a || (a = this.g[f] = [], this.h++);
  var h = Va(a, b2, d, e);
  -1 < h ? (b2 = a[h], c || (b2.ea = false)) : (b2 = new Oa(b2, this.src, f, !!d, e), b2.ea = c, a.push(b2));
  return b2;
};
function Wa(a, b2) {
  var c = b2.type;
  if (c in a.g) {
    var d = a.g[c], e = la(d, b2), f;
    (f = 0 <= e) && Array.prototype.splice.call(d, e, 1);
    f && (Pa(b2), 0 == a.g[c].length && (delete a.g[c], a.h--));
  }
}
function Va(a, b2, c, d) {
  for (var e = 0; e < a.length; ++e) {
    var f = a[e];
    if (!f.ba && f.listener == b2 && f.capture == !!c && f.ha == d)
      return e;
  }
  return -1;
}
var Xa = "closure_lm_" + (1e6 * Math.random() | 0);
var Ya = {};
function $a(a, b2, c, d, e) {
  if (d && d.once)
    return ab(a, b2, c, d, e);
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      $a(a, b2[f], c, d, e);
    return null;
  }
  c = bb(c);
  return a && a[A] ? a.N(b2, c, p(d) ? !!d.capture : !!d, e) : cb(a, b2, c, false, d, e);
}
function cb(a, b2, c, d, e, f) {
  if (!b2)
    throw Error("Invalid event type");
  var h = p(e) ? !!e.capture : !!e, n = db(a);
  n || (a[Xa] = n = new Ua(a));
  c = n.add(b2, c, d, h, f);
  if (c.proxy)
    return c;
  d = eb();
  c.proxy = d;
  d.src = a;
  d.listener = c;
  if (a.addEventListener)
    oa || (e = h), void 0 === e && (e = false), a.addEventListener(b2.toString(), d, e);
  else if (a.attachEvent)
    a.attachEvent(fb(b2.toString()), d);
  else if (a.addListener && a.removeListener)
    a.addListener(d);
  else
    throw Error("addEventListener and attachEvent are unavailable.");
  return c;
}
function eb() {
  function a(c) {
    return b2.call(a.src, a.listener, c);
  }
  const b2 = gb;
  return a;
}
function ab(a, b2, c, d, e) {
  if (Array.isArray(b2)) {
    for (var f = 0; f < b2.length; f++)
      ab(a, b2[f], c, d, e);
    return null;
  }
  c = bb(c);
  return a && a[A] ? a.O(b2, c, p(d) ? !!d.capture : !!d, e) : cb(a, b2, c, true, d, e);
}
function hb(a, b2, c, d, e) {
  if (Array.isArray(b2))
    for (var f = 0; f < b2.length; f++)
      hb(a, b2[f], c, d, e);
  else
    (d = p(d) ? !!d.capture : !!d, c = bb(c), a && a[A]) ? (a = a.i, b2 = String(b2).toString(), b2 in a.g && (f = a.g[b2], c = Va(f, c, d, e), -1 < c && (Pa(f[c]), Array.prototype.splice.call(f, c, 1), 0 == f.length && (delete a.g[b2], a.h--)))) : a && (a = db(a)) && (b2 = a.g[b2.toString()], a = -1, b2 && (a = Va(b2, c, d, e)), (c = -1 < a ? b2[a] : null) && ib(c));
}
function ib(a) {
  if ("number" !== typeof a && a && !a.ba) {
    var b2 = a.src;
    if (b2 && b2[A])
      Wa(b2.i, a);
    else {
      var c = a.type, d = a.proxy;
      b2.removeEventListener ? b2.removeEventListener(c, d, a.capture) : b2.detachEvent ? b2.detachEvent(fb(c), d) : b2.addListener && b2.removeListener && b2.removeListener(d);
      (c = db(b2)) ? (Wa(c, a), 0 == c.h && (c.src = null, b2[Xa] = null)) : Pa(a);
    }
  }
}
function fb(a) {
  return a in Ya ? Ya[a] : Ya[a] = "on" + a;
}
function gb(a, b2) {
  if (a.ba)
    a = true;
  else {
    b2 = new z(b2, this);
    var c = a.listener, d = a.ha || a.src;
    a.ea && ib(a);
    a = c.call(d, b2);
  }
  return a;
}
function db(a) {
  a = a[Xa];
  return a instanceof Ua ? a : null;
}
var jb = "__closure_events_fn_" + (1e9 * Math.random() >>> 0);
function bb(a) {
  if ("function" === typeof a)
    return a;
  a[jb] || (a[jb] = function(b2) {
    return a.handleEvent(b2);
  });
  return a[jb];
}
function B() {
  v.call(this);
  this.i = new Ua(this);
  this.P = this;
  this.I = null;
}
t(B, v);
B.prototype[A] = true;
B.prototype.removeEventListener = function(a, b2, c, d) {
  hb(this, a, b2, c, d);
};
function C(a, b2) {
  var c, d = a.I;
  if (d)
    for (c = []; d; d = d.I)
      c.push(d);
  a = a.P;
  d = b2.type || b2;
  if ("string" === typeof b2)
    b2 = new w(b2, a);
  else if (b2 instanceof w)
    b2.target = b2.target || a;
  else {
    var e = b2;
    b2 = new w(d, a);
    Ta(b2, e);
  }
  e = true;
  if (c)
    for (var f = c.length - 1; 0 <= f; f--) {
      var h = b2.g = c[f];
      e = kb(h, d, true, b2) && e;
    }
  h = b2.g = a;
  e = kb(h, d, true, b2) && e;
  e = kb(h, d, false, b2) && e;
  if (c)
    for (f = 0; f < c.length; f++)
      h = b2.g = c[f], e = kb(h, d, false, b2) && e;
}
B.prototype.M = function() {
  B.X.M.call(this);
  if (this.i) {
    var a = this.i, c;
    for (c in a.g) {
      for (var d = a.g[c], e = 0; e < d.length; e++)
        Pa(d[e]);
      delete a.g[c];
      a.h--;
    }
  }
  this.I = null;
};
B.prototype.N = function(a, b2, c, d) {
  return this.i.add(String(a), b2, false, c, d);
};
B.prototype.O = function(a, b2, c, d) {
  return this.i.add(String(a), b2, true, c, d);
};
function kb(a, b2, c, d) {
  b2 = a.i.g[String(b2)];
  if (!b2)
    return true;
  b2 = b2.concat();
  for (var e = true, f = 0; f < b2.length; ++f) {
    var h = b2[f];
    if (h && !h.ba && h.capture == c) {
      var n = h.listener, u = h.ha || h.src;
      h.ea && Wa(a.i, h);
      e = false !== n.call(u, d) && e;
    }
  }
  return e && !d.defaultPrevented;
}
var lb = l.JSON.stringify;
function mb() {
  var a = nb;
  let b2 = null;
  a.g && (b2 = a.g, a.g = a.g.next, a.g || (a.h = null), b2.next = null);
  return b2;
}
var ob = class {
  constructor() {
    this.h = this.g = null;
  }
  add(a, b2) {
    const c = pb.get();
    c.set(a, b2);
    this.h ? this.h.next = c : this.g = c;
    this.h = c;
  }
};
var pb = new class {
  constructor(a, b2) {
    this.i = a;
    this.j = b2;
    this.h = 0;
    this.g = null;
  }
  get() {
    let a;
    0 < this.h ? (this.h--, a = this.g, this.g = a.next, a.next = null) : a = this.i();
    return a;
  }
}(() => new qb(), (a) => a.reset());
var qb = class {
  constructor() {
    this.next = this.g = this.h = null;
  }
  set(a, b2) {
    this.h = a;
    this.g = b2;
    this.next = null;
  }
  reset() {
    this.next = this.g = this.h = null;
  }
};
function rb(a) {
  l.setTimeout(() => {
    throw a;
  }, 0);
}
function sb(a, b2) {
  ub || vb();
  wb || (ub(), wb = true);
  nb.add(a, b2);
}
var ub;
function vb() {
  var a = l.Promise.resolve(void 0);
  ub = function() {
    a.then(xb);
  };
}
var wb = false;
var nb = new ob();
function xb() {
  for (var a; a = mb(); ) {
    try {
      a.h.call(a.g);
    } catch (c) {
      rb(c);
    }
    var b2 = pb;
    b2.j(a);
    100 > b2.h && (b2.h++, a.next = b2.g, b2.g = a);
  }
  wb = false;
}
function yb(a, b2) {
  B.call(this);
  this.h = a || 1;
  this.g = b2 || l;
  this.j = q(this.lb, this);
  this.l = Date.now();
}
t(yb, B);
k = yb.prototype;
k.ca = false;
k.R = null;
k.lb = function() {
  if (this.ca) {
    var a = Date.now() - this.l;
    0 < a && a < 0.8 * this.h ? this.R = this.g.setTimeout(this.j, this.h - a) : (this.R && (this.g.clearTimeout(this.R), this.R = null), C(this, "tick"), this.ca && (zb(this), this.start()));
  }
};
k.start = function() {
  this.ca = true;
  this.R || (this.R = this.g.setTimeout(this.j, this.h), this.l = Date.now());
};
function zb(a) {
  a.ca = false;
  a.R && (a.g.clearTimeout(a.R), a.R = null);
}
k.M = function() {
  yb.X.M.call(this);
  zb(this);
  delete this.g;
};
function Ab(a, b2, c) {
  if ("function" === typeof a)
    c && (a = q(a, c));
  else if (a && "function" == typeof a.handleEvent)
    a = q(a.handleEvent, a);
  else
    throw Error("Invalid listener argument");
  return 2147483647 < Number(b2) ? -1 : l.setTimeout(a, b2 || 0);
}
function Bb(a) {
  a.g = Ab(() => {
    a.g = null;
    a.i && (a.i = false, Bb(a));
  }, a.j);
  const b2 = a.h;
  a.h = null;
  a.m.apply(null, b2);
}
var Cb = class extends v {
  constructor(a, b2) {
    super();
    this.m = a;
    this.j = b2;
    this.h = null;
    this.i = false;
    this.g = null;
  }
  l(a) {
    this.h = arguments;
    this.g ? this.i = true : Bb(this);
  }
  M() {
    super.M();
    this.g && (l.clearTimeout(this.g), this.g = null, this.i = false, this.h = null);
  }
};
function D(a) {
  v.call(this);
  this.h = a;
  this.g = {};
}
t(D, v);
var Db = [];
function Eb(a, b2, c, d) {
  Array.isArray(c) || (c && (Db[0] = c.toString()), c = Db);
  for (var e = 0; e < c.length; e++) {
    var f = $a(b2, c[e], d || a.handleEvent, false, a.h || a);
    if (!f)
      break;
    a.g[f.key] = f;
  }
}
function Fb(a) {
  Qa(a.g, function(b2, c) {
    this.g.hasOwnProperty(c) && ib(b2);
  }, a);
  a.g = {};
}
D.prototype.M = function() {
  D.X.M.call(this);
  Fb(this);
};
D.prototype.handleEvent = function() {
  throw Error("EventHandler.handleEvent not implemented");
};
function Gb() {
  this.g = true;
}
Gb.prototype.Aa = function() {
  this.g = false;
};
function Hb(a, b2, c, d, e, f) {
  a.info(function() {
    if (a.g)
      if (f) {
        var h = "";
        for (var n = f.split("&"), u = 0; u < n.length; u++) {
          var m = n[u].split("=");
          if (1 < m.length) {
            var r = m[0];
            m = m[1];
            var F2 = r.split("_");
            h = 2 <= F2.length && "type" == F2[1] ? h + (r + "=" + m + "&") : h + (r + "=redacted&");
          }
        }
      } else
        h = null;
    else
      h = f;
    return "XMLHTTP REQ (" + d + ") [attempt " + e + "]: " + b2 + "\n" + c + "\n" + h;
  });
}
function Ib(a, b2, c, d, e, f, h) {
  a.info(function() {
    return "XMLHTTP RESP (" + d + ") [ attempt " + e + "]: " + b2 + "\n" + c + "\n" + f + " " + h;
  });
}
function E(a, b2, c, d) {
  a.info(function() {
    return "XMLHTTP TEXT (" + b2 + "): " + Jb(a, c) + (d ? " " + d : "");
  });
}
function Kb(a, b2) {
  a.info(function() {
    return "TIMEOUT: " + b2;
  });
}
Gb.prototype.info = function() {
};
function Jb(a, b2) {
  if (!a.g)
    return b2;
  if (!b2)
    return null;
  try {
    var c = JSON.parse(b2);
    if (c) {
      for (a = 0; a < c.length; a++)
        if (Array.isArray(c[a])) {
          var d = c[a];
          if (!(2 > d.length)) {
            var e = d[1];
            if (Array.isArray(e) && !(1 > e.length)) {
              var f = e[0];
              if ("noop" != f && "stop" != f && "close" != f)
                for (var h = 1; h < e.length; h++)
                  e[h] = "";
            }
          }
        }
    }
    return lb(c);
  } catch (n) {
    return b2;
  }
}
var G = {};
var Lb = null;
function Mb() {
  return Lb = Lb || new B();
}
G.Pa = "serverreachability";
function Nb(a) {
  w.call(this, G.Pa, a);
}
t(Nb, w);
function H(a) {
  const b2 = Mb();
  C(b2, new Nb(b2));
}
G.STAT_EVENT = "statevent";
function Ob(a, b2) {
  w.call(this, G.STAT_EVENT, a);
  this.stat = b2;
}
t(Ob, w);
function I(a) {
  const b2 = Mb();
  C(b2, new Ob(b2, a));
}
G.Qa = "timingevent";
function Pb(a, b2) {
  w.call(this, G.Qa, a);
  this.size = b2;
}
t(Pb, w);
function J(a, b2) {
  if ("function" !== typeof a)
    throw Error("Fn must not be null and must be a function");
  return l.setTimeout(function() {
    a();
  }, b2);
}
var Qb = { NO_ERROR: 0, mb: 1, zb: 2, yb: 3, tb: 4, xb: 5, Ab: 6, Ma: 7, TIMEOUT: 8, Db: 9 };
var Rb = { rb: "complete", Nb: "success", Na: "error", Ma: "abort", Fb: "ready", Gb: "readystatechange", TIMEOUT: "timeout", Bb: "incrementaldata", Eb: "progress", ub: "downloadprogress", Vb: "uploadprogress" };
function Sb() {
}
Sb.prototype.h = null;
function Tb(a) {
  return a.h || (a.h = a.i());
}
function Ub() {
}
var K = { OPEN: "a", qb: "b", Na: "c", Cb: "d" };
function Vb() {
  w.call(this, "d");
}
t(Vb, w);
function Wb() {
  w.call(this, "c");
}
t(Wb, w);
var Xb;
function Yb() {
}
t(Yb, Sb);
Yb.prototype.g = function() {
  return new XMLHttpRequest();
};
Yb.prototype.i = function() {
  return {};
};
Xb = new Yb();
function L(a, b2, c, d) {
  this.l = a;
  this.j = b2;
  this.m = c;
  this.U = d || 1;
  this.S = new D(this);
  this.O = Zb;
  a = ya ? 125 : void 0;
  this.T = new yb(a);
  this.H = null;
  this.i = false;
  this.s = this.A = this.v = this.K = this.F = this.V = this.B = null;
  this.D = [];
  this.g = null;
  this.C = 0;
  this.o = this.u = null;
  this.Y = -1;
  this.I = false;
  this.N = 0;
  this.L = null;
  this.$ = this.J = this.Z = this.P = false;
  this.h = new $b();
}
function $b() {
  this.i = null;
  this.g = "";
  this.h = false;
}
var Zb = 45e3;
var ac = {};
var bc = {};
k = L.prototype;
k.setTimeout = function(a) {
  this.O = a;
};
function cc(a, b2, c) {
  a.K = 1;
  a.v = dc(M(b2));
  a.s = c;
  a.P = true;
  ec(a, null);
}
function ec(a, b2) {
  a.F = Date.now();
  N(a);
  a.A = M(a.v);
  var c = a.A, d = a.U;
  Array.isArray(d) || (d = [String(d)]);
  fc(c.i, "t", d);
  a.C = 0;
  c = a.l.H;
  a.h = new $b();
  a.g = gc(a.l, c ? b2 : null, !a.s);
  0 < a.N && (a.L = new Cb(q(a.La, a, a.g), a.N));
  Eb(a.S, a.g, "readystatechange", a.ib);
  b2 = a.H ? Ra(a.H) : {};
  a.s ? (a.u || (a.u = "POST"), b2["Content-Type"] = "application/x-www-form-urlencoded", a.g.da(a.A, a.u, a.s, b2)) : (a.u = "GET", a.g.da(a.A, a.u, null, b2));
  H();
  Hb(a.j, a.u, a.A, a.m, a.U, a.s);
}
k.ib = function(a) {
  a = a.target;
  const b2 = this.L;
  b2 && 3 == O(a) ? b2.l() : this.La(a);
};
k.La = function(a) {
  try {
    if (a == this.g)
      a: {
        const r = O(this.g);
        var b2 = this.g.Ea();
        const F2 = this.g.aa();
        if (!(3 > r) && (3 != r || ya || this.g && (this.h.h || this.g.fa() || hc(this.g)))) {
          this.I || 4 != r || 7 == b2 || (8 == b2 || 0 >= F2 ? H(3) : H(2));
          ic(this);
          var c = this.g.aa();
          this.Y = c;
          b:
            if (jc(this)) {
              var d = hc(this.g);
              a = "";
              var e = d.length, f = 4 == O(this.g);
              if (!this.h.i) {
                if ("undefined" === typeof TextDecoder) {
                  P(this);
                  Q(this);
                  var h = "";
                  break b;
                }
                this.h.i = new l.TextDecoder();
              }
              for (b2 = 0; b2 < e; b2++)
                this.h.h = true, a += this.h.i.decode(d[b2], { stream: f && b2 == e - 1 });
              d.splice(
                0,
                e
              );
              this.h.g += a;
              this.C = 0;
              h = this.h.g;
            } else
              h = this.g.fa();
          this.i = 200 == c;
          Ib(this.j, this.u, this.A, this.m, this.U, r, c);
          if (this.i) {
            if (this.Z && !this.J) {
              b: {
                if (this.g) {
                  var n, u = this.g;
                  if ((n = u.g ? u.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !pa(n)) {
                    var m = n;
                    break b;
                  }
                }
                m = null;
              }
              if (c = m)
                E(this.j, this.m, c, "Initial handshake response via X-HTTP-Initial-Response"), this.J = true, kc(this, c);
              else {
                this.i = false;
                this.o = 3;
                I(12);
                P(this);
                Q(this);
                break a;
              }
            }
            this.P ? (lc(this, r, h), ya && this.i && 3 == r && (Eb(this.S, this.T, "tick", this.hb), this.T.start())) : (E(this.j, this.m, h, null), kc(this, h));
            4 == r && P(this);
            this.i && !this.I && (4 == r ? mc(this.l, this) : (this.i = false, N(this)));
          } else
            400 == c && 0 < h.indexOf("Unknown SID") ? (this.o = 3, I(12)) : (this.o = 0, I(13)), P(this), Q(this);
        }
      }
  } catch (r) {
  } finally {
  }
};
function jc(a) {
  return a.g ? "GET" == a.u && 2 != a.K && a.l.Da : false;
}
function lc(a, b2, c) {
  let d = true, e;
  for (; !a.I && a.C < c.length; )
    if (e = nc(a, c), e == bc) {
      4 == b2 && (a.o = 4, I(14), d = false);
      E(a.j, a.m, null, "[Incomplete Response]");
      break;
    } else if (e == ac) {
      a.o = 4;
      I(15);
      E(a.j, a.m, c, "[Invalid Chunk]");
      d = false;
      break;
    } else
      E(a.j, a.m, e, null), kc(a, e);
  jc(a) && e != bc && e != ac && (a.h.g = "", a.C = 0);
  4 != b2 || 0 != c.length || a.h.h || (a.o = 1, I(16), d = false);
  a.i = a.i && d;
  d ? 0 < c.length && !a.$ && (a.$ = true, b2 = a.l, b2.g == a && b2.$ && !b2.K && (b2.j.info("Great, no buffering proxy detected. Bytes received: " + c.length), oc(b2), b2.K = true, I(11))) : (E(
    a.j,
    a.m,
    c,
    "[Invalid Chunked Response]"
  ), P(a), Q(a));
}
k.hb = function() {
  if (this.g) {
    var a = O(this.g), b2 = this.g.fa();
    this.C < b2.length && (ic(this), lc(this, a, b2), this.i && 4 != a && N(this));
  }
};
function nc(a, b2) {
  var c = a.C, d = b2.indexOf("\n", c);
  if (-1 == d)
    return bc;
  c = Number(b2.substring(c, d));
  if (isNaN(c))
    return ac;
  d += 1;
  if (d + c > b2.length)
    return bc;
  b2 = b2.substr(d, c);
  a.C = d + c;
  return b2;
}
k.cancel = function() {
  this.I = true;
  P(this);
};
function N(a) {
  a.V = Date.now() + a.O;
  pc(a, a.O);
}
function pc(a, b2) {
  if (null != a.B)
    throw Error("WatchDog timer not null");
  a.B = J(q(a.gb, a), b2);
}
function ic(a) {
  a.B && (l.clearTimeout(a.B), a.B = null);
}
k.gb = function() {
  this.B = null;
  const a = Date.now();
  0 <= a - this.V ? (Kb(this.j, this.A), 2 != this.K && (H(), I(17)), P(this), this.o = 2, Q(this)) : pc(this, this.V - a);
};
function Q(a) {
  0 == a.l.G || a.I || mc(a.l, a);
}
function P(a) {
  ic(a);
  var b2 = a.L;
  b2 && "function" == typeof b2.na && b2.na();
  a.L = null;
  zb(a.T);
  Fb(a.S);
  a.g && (b2 = a.g, a.g = null, b2.abort(), b2.na());
}
function kc(a, b2) {
  try {
    var c = a.l;
    if (0 != c.G && (c.g == a || qc(c.h, a))) {
      if (!a.J && qc(c.h, a) && 3 == c.G) {
        try {
          var d = c.Fa.g.parse(b2);
        } catch (m) {
          d = null;
        }
        if (Array.isArray(d) && 3 == d.length) {
          var e = d;
          if (0 == e[0])
            a: {
              if (!c.u) {
                if (c.g)
                  if (c.g.F + 3e3 < a.F)
                    rc(c), sc(c);
                  else
                    break a;
                tc(c);
                I(18);
              }
            }
          else
            c.Ba = e[1], 0 < c.Ba - c.T && 37500 > e[2] && c.L && 0 == c.A && !c.v && (c.v = J(q(c.cb, c), 6e3));
          if (1 >= uc(c.h) && c.ja) {
            try {
              c.ja();
            } catch (m) {
            }
            c.ja = void 0;
          }
        } else
          R(c, 11);
      } else if ((a.J || c.g == a) && rc(c), !pa(b2))
        for (e = c.Fa.g.parse(b2), b2 = 0; b2 < e.length; b2++) {
          let m = e[b2];
          c.T = m[0];
          m = m[1];
          if (2 == c.G)
            if ("c" == m[0]) {
              c.I = m[1];
              c.ka = m[2];
              const r = m[3];
              null != r && (c.ma = r, c.j.info("VER=" + c.ma));
              const F2 = m[4];
              null != F2 && (c.Ca = F2, c.j.info("SVER=" + c.Ca));
              const Ca2 = m[5];
              null != Ca2 && "number" === typeof Ca2 && 0 < Ca2 && (d = 1.5 * Ca2, c.J = d, c.j.info("backChannelRequestTimeoutMs_=" + d));
              d = c;
              const Z2 = a.g;
              if (Z2) {
                const Da2 = Z2.g ? Z2.g.getResponseHeader("X-Client-Wire-Protocol") : null;
                if (Da2) {
                  var f = d.h;
                  f.g || -1 == Da2.indexOf("spdy") && -1 == Da2.indexOf("quic") && -1 == Da2.indexOf("h2") || (f.j = f.l, f.g = /* @__PURE__ */ new Set(), f.h && (vc(f, f.h), f.h = null));
                }
                if (d.D) {
                  const tb = Z2.g ? Z2.g.getResponseHeader("X-HTTP-Session-Id") : null;
                  tb && (d.za = tb, S(d.F, d.D, tb));
                }
              }
              c.G = 3;
              c.l && c.l.xa();
              c.$ && (c.P = Date.now() - a.F, c.j.info("Handshake RTT: " + c.P + "ms"));
              d = c;
              var h = a;
              d.sa = wc(d, d.H ? d.ka : null, d.V);
              if (h.J) {
                xc(d.h, h);
                var n = h, u = d.J;
                u && n.setTimeout(u);
                n.B && (ic(n), N(n));
                d.g = h;
              } else
                yc(d);
              0 < c.i.length && zc(c);
            } else
              "stop" != m[0] && "close" != m[0] || R(c, 7);
          else
            3 == c.G && ("stop" == m[0] || "close" == m[0] ? "stop" == m[0] ? R(c, 7) : Ac(c) : "noop" != m[0] && c.l && c.l.wa(m), c.A = 0);
        }
    }
    H(4);
  } catch (m) {
  }
}
function Bc(a) {
  if (a.W && "function" == typeof a.W)
    return a.W();
  if ("undefined" !== typeof Map && a instanceof Map || "undefined" !== typeof Set && a instanceof Set)
    return Array.from(a.values());
  if ("string" === typeof a)
    return a.split("");
  if (ba(a)) {
    for (var b2 = [], c = a.length, d = 0; d < c; d++)
      b2.push(a[d]);
    return b2;
  }
  b2 = [];
  c = 0;
  for (d in a)
    b2[c++] = a[d];
  return b2;
}
function Cc(a) {
  if (a.oa && "function" == typeof a.oa)
    return a.oa();
  if (!a.W || "function" != typeof a.W) {
    if ("undefined" !== typeof Map && a instanceof Map)
      return Array.from(a.keys());
    if (!("undefined" !== typeof Set && a instanceof Set)) {
      if (ba(a) || "string" === typeof a) {
        var b2 = [];
        a = a.length;
        for (var c = 0; c < a; c++)
          b2.push(c);
        return b2;
      }
      b2 = [];
      c = 0;
      for (const d in a)
        b2[c++] = d;
      return b2;
    }
  }
}
function Dc(a, b2) {
  if (a.forEach && "function" == typeof a.forEach)
    a.forEach(b2, void 0);
  else if (ba(a) || "string" === typeof a)
    Array.prototype.forEach.call(a, b2, void 0);
  else
    for (var c = Cc(a), d = Bc(a), e = d.length, f = 0; f < e; f++)
      b2.call(void 0, d[f], c && c[f], a);
}
var Ec = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$");
function Fc(a, b2) {
  if (a) {
    a = a.split("&");
    for (var c = 0; c < a.length; c++) {
      var d = a[c].indexOf("="), e = null;
      if (0 <= d) {
        var f = a[c].substring(0, d);
        e = a[c].substring(d + 1);
      } else
        f = a[c];
      b2(f, e ? decodeURIComponent(e.replace(/\+/g, " ")) : "");
    }
  }
}
function T(a, b2) {
  this.g = this.s = this.j = "";
  this.m = null;
  this.o = this.l = "";
  this.h = false;
  if (a instanceof T) {
    this.h = void 0 !== b2 ? b2 : a.h;
    Gc(this, a.j);
    this.s = a.s;
    this.g = a.g;
    Hc(this, a.m);
    this.l = a.l;
    b2 = a.i;
    var c = new Ic();
    c.i = b2.i;
    b2.g && (c.g = new Map(b2.g), c.h = b2.h);
    Jc(this, c);
    this.o = a.o;
  } else
    a && (c = String(a).match(Ec)) ? (this.h = !!b2, Gc(this, c[1] || "", true), this.s = Kc(c[2] || ""), this.g = Kc(c[3] || "", true), Hc(this, c[4]), this.l = Kc(c[5] || "", true), Jc(this, c[6] || "", true), this.o = Kc(c[7] || "")) : (this.h = !!b2, this.i = new Ic(null, this.h));
}
T.prototype.toString = function() {
  var a = [], b2 = this.j;
  b2 && a.push(Lc(b2, Mc, true), ":");
  var c = this.g;
  if (c || "file" == b2)
    a.push("//"), (b2 = this.s) && a.push(Lc(b2, Mc, true), "@"), a.push(encodeURIComponent(String(c)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), c = this.m, null != c && a.push(":", String(c));
  if (c = this.l)
    this.g && "/" != c.charAt(0) && a.push("/"), a.push(Lc(c, "/" == c.charAt(0) ? Nc : Oc, true));
  (c = this.i.toString()) && a.push("?", c);
  (c = this.o) && a.push("#", Lc(c, Pc));
  return a.join("");
};
function M(a) {
  return new T(a);
}
function Gc(a, b2, c) {
  a.j = c ? Kc(b2, true) : b2;
  a.j && (a.j = a.j.replace(/:$/, ""));
}
function Hc(a, b2) {
  if (b2) {
    b2 = Number(b2);
    if (isNaN(b2) || 0 > b2)
      throw Error("Bad port number " + b2);
    a.m = b2;
  } else
    a.m = null;
}
function Jc(a, b2, c) {
  b2 instanceof Ic ? (a.i = b2, Qc(a.i, a.h)) : (c || (b2 = Lc(b2, Rc)), a.i = new Ic(b2, a.h));
}
function S(a, b2, c) {
  a.i.set(b2, c);
}
function dc(a) {
  S(a, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36));
  return a;
}
function Kc(a, b2) {
  return a ? b2 ? decodeURI(a.replace(/%25/g, "%2525")) : decodeURIComponent(a) : "";
}
function Lc(a, b2, c) {
  return "string" === typeof a ? (a = encodeURI(a).replace(b2, Sc), c && (a = a.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), a) : null;
}
function Sc(a) {
  a = a.charCodeAt(0);
  return "%" + (a >> 4 & 15).toString(16) + (a & 15).toString(16);
}
var Mc = /[#\/\?@]/g;
var Oc = /[#\?:]/g;
var Nc = /[#\?]/g;
var Rc = /[#\?@]/g;
var Pc = /#/g;
function Ic(a, b2) {
  this.h = this.g = null;
  this.i = a || null;
  this.j = !!b2;
}
function U(a) {
  a.g || (a.g = /* @__PURE__ */ new Map(), a.h = 0, a.i && Fc(a.i, function(b2, c) {
    a.add(decodeURIComponent(b2.replace(/\+/g, " ")), c);
  }));
}
k = Ic.prototype;
k.add = function(a, b2) {
  U(this);
  this.i = null;
  a = V(this, a);
  var c = this.g.get(a);
  c || this.g.set(a, c = []);
  c.push(b2);
  this.h += 1;
  return this;
};
function Tc(a, b2) {
  U(a);
  b2 = V(a, b2);
  a.g.has(b2) && (a.i = null, a.h -= a.g.get(b2).length, a.g.delete(b2));
}
function Uc(a, b2) {
  U(a);
  b2 = V(a, b2);
  return a.g.has(b2);
}
k.forEach = function(a, b2) {
  U(this);
  this.g.forEach(function(c, d) {
    c.forEach(function(e) {
      a.call(b2, e, d, this);
    }, this);
  }, this);
};
k.oa = function() {
  U(this);
  const a = Array.from(this.g.values()), b2 = Array.from(this.g.keys()), c = [];
  for (let d = 0; d < b2.length; d++) {
    const e = a[d];
    for (let f = 0; f < e.length; f++)
      c.push(b2[d]);
  }
  return c;
};
k.W = function(a) {
  U(this);
  let b2 = [];
  if ("string" === typeof a)
    Uc(this, a) && (b2 = b2.concat(this.g.get(V(this, a))));
  else {
    a = Array.from(this.g.values());
    for (let c = 0; c < a.length; c++)
      b2 = b2.concat(a[c]);
  }
  return b2;
};
k.set = function(a, b2) {
  U(this);
  this.i = null;
  a = V(this, a);
  Uc(this, a) && (this.h -= this.g.get(a).length);
  this.g.set(a, [b2]);
  this.h += 1;
  return this;
};
k.get = function(a, b2) {
  if (!a)
    return b2;
  a = this.W(a);
  return 0 < a.length ? String(a[0]) : b2;
};
function fc(a, b2, c) {
  Tc(a, b2);
  0 < c.length && (a.i = null, a.g.set(V(a, b2), ma(c)), a.h += c.length);
}
k.toString = function() {
  if (this.i)
    return this.i;
  if (!this.g)
    return "";
  const a = [], b2 = Array.from(this.g.keys());
  for (var c = 0; c < b2.length; c++) {
    var d = b2[c];
    const f = encodeURIComponent(String(d)), h = this.W(d);
    for (d = 0; d < h.length; d++) {
      var e = f;
      "" !== h[d] && (e += "=" + encodeURIComponent(String(h[d])));
      a.push(e);
    }
  }
  return this.i = a.join("&");
};
function V(a, b2) {
  b2 = String(b2);
  a.j && (b2 = b2.toLowerCase());
  return b2;
}
function Qc(a, b2) {
  b2 && !a.j && (U(a), a.i = null, a.g.forEach(function(c, d) {
    var e = d.toLowerCase();
    d != e && (Tc(this, d), fc(this, e, c));
  }, a));
  a.j = b2;
}
var Vc = class {
  constructor(a, b2) {
    this.h = a;
    this.g = b2;
  }
};
function Wc(a) {
  this.l = a || Xc;
  l.PerformanceNavigationTiming ? (a = l.performance.getEntriesByType("navigation"), a = 0 < a.length && ("hq" == a[0].nextHopProtocol || "h2" == a[0].nextHopProtocol)) : a = !!(l.g && l.g.Ga && l.g.Ga() && l.g.Ga().$b);
  this.j = a ? this.l : 1;
  this.g = null;
  1 < this.j && (this.g = /* @__PURE__ */ new Set());
  this.h = null;
  this.i = [];
}
var Xc = 10;
function Yc(a) {
  return a.h ? true : a.g ? a.g.size >= a.j : false;
}
function uc(a) {
  return a.h ? 1 : a.g ? a.g.size : 0;
}
function qc(a, b2) {
  return a.h ? a.h == b2 : a.g ? a.g.has(b2) : false;
}
function vc(a, b2) {
  a.g ? a.g.add(b2) : a.h = b2;
}
function xc(a, b2) {
  a.h && a.h == b2 ? a.h = null : a.g && a.g.has(b2) && a.g.delete(b2);
}
Wc.prototype.cancel = function() {
  this.i = Zc(this);
  if (this.h)
    this.h.cancel(), this.h = null;
  else if (this.g && 0 !== this.g.size) {
    for (const a of this.g.values())
      a.cancel();
    this.g.clear();
  }
};
function Zc(a) {
  if (null != a.h)
    return a.i.concat(a.h.D);
  if (null != a.g && 0 !== a.g.size) {
    let b2 = a.i;
    for (const c of a.g.values())
      b2 = b2.concat(c.D);
    return b2;
  }
  return ma(a.i);
}
function $c() {
}
$c.prototype.stringify = function(a) {
  return l.JSON.stringify(a, void 0);
};
$c.prototype.parse = function(a) {
  return l.JSON.parse(a, void 0);
};
function ad() {
  this.g = new $c();
}
function bd(a, b2, c) {
  const d = c || "";
  try {
    Dc(a, function(e, f) {
      let h = e;
      p(e) && (h = lb(e));
      b2.push(d + f + "=" + encodeURIComponent(h));
    });
  } catch (e) {
    throw b2.push(d + "type=" + encodeURIComponent("_badmap")), e;
  }
}
function cd(a, b2) {
  const c = new Gb();
  if (l.Image) {
    const d = new Image();
    d.onload = ia(dd, c, d, "TestLoadImage: loaded", true, b2);
    d.onerror = ia(dd, c, d, "TestLoadImage: error", false, b2);
    d.onabort = ia(dd, c, d, "TestLoadImage: abort", false, b2);
    d.ontimeout = ia(dd, c, d, "TestLoadImage: timeout", false, b2);
    l.setTimeout(function() {
      if (d.ontimeout)
        d.ontimeout();
    }, 1e4);
    d.src = a;
  } else
    b2(false);
}
function dd(a, b2, c, d, e) {
  try {
    b2.onload = null, b2.onerror = null, b2.onabort = null, b2.ontimeout = null, e(d);
  } catch (f) {
  }
}
function ed(a) {
  this.l = a.ac || null;
  this.j = a.jb || false;
}
t(ed, Sb);
ed.prototype.g = function() {
  return new fd(this.l, this.j);
};
ed.prototype.i = function(a) {
  return function() {
    return a;
  };
}({});
function fd(a, b2) {
  B.call(this);
  this.D = a;
  this.u = b2;
  this.m = void 0;
  this.readyState = gd;
  this.status = 0;
  this.responseType = this.responseText = this.response = this.statusText = "";
  this.onreadystatechange = null;
  this.v = new Headers();
  this.h = null;
  this.C = "GET";
  this.B = "";
  this.g = false;
  this.A = this.j = this.l = null;
}
t(fd, B);
var gd = 0;
k = fd.prototype;
k.open = function(a, b2) {
  if (this.readyState != gd)
    throw this.abort(), Error("Error reopening a connection");
  this.C = a;
  this.B = b2;
  this.readyState = 1;
  hd(this);
};
k.send = function(a) {
  if (1 != this.readyState)
    throw this.abort(), Error("need to call open() first. ");
  this.g = true;
  const b2 = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 };
  a && (b2.body = a);
  (this.D || l).fetch(new Request(this.B, b2)).then(this.Wa.bind(this), this.ga.bind(this));
};
k.abort = function() {
  this.response = this.responseText = "";
  this.v = new Headers();
  this.status = 0;
  this.j && this.j.cancel("Request was aborted.").catch(() => {
  });
  1 <= this.readyState && this.g && 4 != this.readyState && (this.g = false, id(this));
  this.readyState = gd;
};
k.Wa = function(a) {
  if (this.g && (this.l = a, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = a.headers, this.readyState = 2, hd(this)), this.g && (this.readyState = 3, hd(this), this.g)))
    if ("arraybuffer" === this.responseType)
      a.arrayBuffer().then(this.Ua.bind(this), this.ga.bind(this));
    else if ("undefined" !== typeof l.ReadableStream && "body" in a) {
      this.j = a.body.getReader();
      if (this.u) {
        if (this.responseType)
          throw Error('responseType must be empty for "streamBinaryChunks" mode responses.');
        this.response = [];
      } else
        this.response = this.responseText = "", this.A = new TextDecoder();
      jd(this);
    } else
      a.text().then(this.Va.bind(this), this.ga.bind(this));
};
function jd(a) {
  a.j.read().then(a.Ta.bind(a)).catch(a.ga.bind(a));
}
k.Ta = function(a) {
  if (this.g) {
    if (this.u && a.value)
      this.response.push(a.value);
    else if (!this.u) {
      var b2 = a.value ? a.value : new Uint8Array(0);
      if (b2 = this.A.decode(b2, { stream: !a.done }))
        this.response = this.responseText += b2;
    }
    a.done ? id(this) : hd(this);
    3 == this.readyState && jd(this);
  }
};
k.Va = function(a) {
  this.g && (this.response = this.responseText = a, id(this));
};
k.Ua = function(a) {
  this.g && (this.response = a, id(this));
};
k.ga = function() {
  this.g && id(this);
};
function id(a) {
  a.readyState = 4;
  a.l = null;
  a.j = null;
  a.A = null;
  hd(a);
}
k.setRequestHeader = function(a, b2) {
  this.v.append(a, b2);
};
k.getResponseHeader = function(a) {
  return this.h ? this.h.get(a.toLowerCase()) || "" : "";
};
k.getAllResponseHeaders = function() {
  if (!this.h)
    return "";
  const a = [], b2 = this.h.entries();
  for (var c = b2.next(); !c.done; )
    c = c.value, a.push(c[0] + ": " + c[1]), c = b2.next();
  return a.join("\r\n");
};
function hd(a) {
  a.onreadystatechange && a.onreadystatechange.call(a);
}
Object.defineProperty(fd.prototype, "withCredentials", { get: function() {
  return "include" === this.m;
}, set: function(a) {
  this.m = a ? "include" : "same-origin";
} });
var kd = l.JSON.parse;
function W(a) {
  B.call(this);
  this.headers = /* @__PURE__ */ new Map();
  this.u = a || null;
  this.h = false;
  this.C = this.g = null;
  this.H = "";
  this.m = 0;
  this.j = "";
  this.l = this.F = this.v = this.D = false;
  this.B = 0;
  this.A = null;
  this.J = ld;
  this.K = this.L = false;
}
t(W, B);
var ld = "";
var md = /^https?$/i;
var nd = ["POST", "PUT"];
k = W.prototype;
k.Ka = function(a) {
  this.L = a;
};
k.da = function(a, b2, c, d) {
  if (this.g)
    throw Error("[goog.net.XhrIo] Object is active with another request=" + this.H + "; newUri=" + a);
  b2 = b2 ? b2.toUpperCase() : "GET";
  this.H = a;
  this.j = "";
  this.m = 0;
  this.D = false;
  this.h = true;
  this.g = this.u ? this.u.g() : Xb.g();
  this.C = this.u ? Tb(this.u) : Tb(Xb);
  this.g.onreadystatechange = q(this.Ha, this);
  try {
    this.F = true, this.g.open(b2, String(a), true), this.F = false;
  } catch (f) {
    od(this, f);
    return;
  }
  a = c || "";
  c = new Map(this.headers);
  if (d)
    if (Object.getPrototypeOf(d) === Object.prototype)
      for (var e in d)
        c.set(e, d[e]);
    else if ("function" === typeof d.keys && "function" === typeof d.get)
      for (const f of d.keys())
        c.set(f, d.get(f));
    else
      throw Error("Unknown input type for opt_headers: " + String(d));
  d = Array.from(c.keys()).find((f) => "content-type" == f.toLowerCase());
  e = l.FormData && a instanceof l.FormData;
  !(0 <= la(nd, b2)) || d || e || c.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");
  for (const [f, h] of c)
    this.g.setRequestHeader(f, h);
  this.J && (this.g.responseType = this.J);
  "withCredentials" in this.g && this.g.withCredentials !== this.L && (this.g.withCredentials = this.L);
  try {
    pd(this), 0 < this.B && ((this.K = qd(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = q(this.qa, this)) : this.A = Ab(this.qa, this.B, this)), this.v = true, this.g.send(a), this.v = false;
  } catch (f) {
    od(this, f);
  }
};
function qd(a) {
  return y && Ia() && "number" === typeof a.timeout && void 0 !== a.ontimeout;
}
k.qa = function() {
  "undefined" != typeof goog && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, C(this, "timeout"), this.abort(8));
};
function od(a, b2) {
  a.h = false;
  a.g && (a.l = true, a.g.abort(), a.l = false);
  a.j = b2;
  a.m = 5;
  rd(a);
  sd(a);
}
function rd(a) {
  a.D || (a.D = true, C(a, "complete"), C(a, "error"));
}
k.abort = function(a) {
  this.g && this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false, this.m = a || 7, C(this, "complete"), C(this, "abort"), sd(this));
};
k.M = function() {
  this.g && (this.h && (this.h = false, this.l = true, this.g.abort(), this.l = false), sd(this, true));
  W.X.M.call(this);
};
k.Ha = function() {
  this.s || (this.F || this.v || this.l ? td(this) : this.fb());
};
k.fb = function() {
  td(this);
};
function td(a) {
  if (a.h && "undefined" != typeof goog && (!a.C[1] || 4 != O(a) || 2 != a.aa())) {
    if (a.v && 4 == O(a))
      Ab(a.Ha, 0, a);
    else if (C(a, "readystatechange"), 4 == O(a)) {
      a.h = false;
      try {
        const n = a.aa();
        a:
          switch (n) {
            case 200:
            case 201:
            case 202:
            case 204:
            case 206:
            case 304:
            case 1223:
              var b2 = true;
              break a;
            default:
              b2 = false;
          }
        var c;
        if (!(c = b2)) {
          var d;
          if (d = 0 === n) {
            var e = String(a.H).match(Ec)[1] || null;
            if (!e && l.self && l.self.location) {
              var f = l.self.location.protocol;
              e = f.substr(0, f.length - 1);
            }
            d = !md.test(e ? e.toLowerCase() : "");
          }
          c = d;
        }
        if (c)
          C(a, "complete"), C(
            a,
            "success"
          );
        else {
          a.m = 6;
          try {
            var h = 2 < O(a) ? a.g.statusText : "";
          } catch (u) {
            h = "";
          }
          a.j = h + " [" + a.aa() + "]";
          rd(a);
        }
      } finally {
        sd(a);
      }
    }
  }
}
function sd(a, b2) {
  if (a.g) {
    pd(a);
    const c = a.g, d = a.C[0] ? aa : null;
    a.g = null;
    a.C = null;
    b2 || C(a, "ready");
    try {
      c.onreadystatechange = d;
    } catch (e) {
    }
  }
}
function pd(a) {
  a.g && a.K && (a.g.ontimeout = null);
  a.A && (l.clearTimeout(a.A), a.A = null);
}
function O(a) {
  return a.g ? a.g.readyState : 0;
}
k.aa = function() {
  try {
    return 2 < O(this) ? this.g.status : -1;
  } catch (a) {
    return -1;
  }
};
k.fa = function() {
  try {
    return this.g ? this.g.responseText : "";
  } catch (a) {
    return "";
  }
};
k.Sa = function(a) {
  if (this.g) {
    var b2 = this.g.responseText;
    a && 0 == b2.indexOf(a) && (b2 = b2.substring(a.length));
    return kd(b2);
  }
};
function hc(a) {
  try {
    if (!a.g)
      return null;
    if ("response" in a.g)
      return a.g.response;
    switch (a.J) {
      case ld:
      case "text":
        return a.g.responseText;
      case "arraybuffer":
        if ("mozResponseArrayBuffer" in a.g)
          return a.g.mozResponseArrayBuffer;
    }
    return null;
  } catch (b2) {
    return null;
  }
}
k.Ea = function() {
  return this.m;
};
k.Oa = function() {
  return "string" === typeof this.j ? this.j : String(this.j);
};
function ud(a) {
  let b2 = "";
  Qa(a, function(c, d) {
    b2 += d;
    b2 += ":";
    b2 += c;
    b2 += "\r\n";
  });
  return b2;
}
function vd(a, b2, c) {
  a: {
    for (d in c) {
      var d = false;
      break a;
    }
    d = true;
  }
  d || (c = ud(c), "string" === typeof a ? null != c && encodeURIComponent(String(c)) : S(a, b2, c));
}
function wd(a, b2, c) {
  return c && c.internalChannelParams ? c.internalChannelParams[a] || b2 : b2;
}
function xd(a) {
  this.Ca = 0;
  this.i = [];
  this.j = new Gb();
  this.ka = this.sa = this.F = this.V = this.g = this.za = this.D = this.ia = this.o = this.S = this.s = null;
  this.ab = this.U = 0;
  this.Za = wd("failFast", false, a);
  this.L = this.v = this.u = this.m = this.l = null;
  this.Y = true;
  this.pa = this.Ba = this.T = -1;
  this.Z = this.A = this.C = 0;
  this.Xa = wd("baseRetryDelayMs", 5e3, a);
  this.bb = wd("retryDelaySeedMs", 1e4, a);
  this.$a = wd("forwardChannelMaxRetries", 2, a);
  this.ta = wd("forwardChannelRequestTimeoutMs", 2e4, a);
  this.ra = a && a.xmlHttpFactory || void 0;
  this.Da = a && a.Zb || false;
  this.J = void 0;
  this.H = a && a.supportsCrossDomainXhr || false;
  this.I = "";
  this.h = new Wc(a && a.concurrentRequestLimit);
  this.Fa = new ad();
  this.O = a && a.fastHandshake || false;
  this.N = a && a.encodeInitMessageHeaders || false;
  this.O && this.N && (this.N = false);
  this.Ya = a && a.Xb || false;
  a && a.Aa && this.j.Aa();
  a && a.forceLongPolling && (this.Y = false);
  this.$ = !this.O && this.Y && a && a.detectBufferingProxy || false;
  this.ja = void 0;
  this.P = 0;
  this.K = false;
  this.la = this.B = null;
}
k = xd.prototype;
k.ma = 8;
k.G = 1;
function Ac(a) {
  yd(a);
  if (3 == a.G) {
    var b2 = a.U++, c = M(a.F);
    S(c, "SID", a.I);
    S(c, "RID", b2);
    S(c, "TYPE", "terminate");
    zd(a, c);
    b2 = new L(a, a.j, b2, void 0);
    b2.K = 2;
    b2.v = dc(M(c));
    c = false;
    l.navigator && l.navigator.sendBeacon && (c = l.navigator.sendBeacon(b2.v.toString(), ""));
    !c && l.Image && (new Image().src = b2.v, c = true);
    c || (b2.g = gc(b2.l, null), b2.g.da(b2.v));
    b2.F = Date.now();
    N(b2);
  }
  Ad(a);
}
function sc(a) {
  a.g && (oc(a), a.g.cancel(), a.g = null);
}
function yd(a) {
  sc(a);
  a.u && (l.clearTimeout(a.u), a.u = null);
  rc(a);
  a.h.cancel();
  a.m && ("number" === typeof a.m && l.clearTimeout(a.m), a.m = null);
}
function zc(a) {
  Yc(a.h) || a.m || (a.m = true, sb(a.Ja, a), a.C = 0);
}
function Bd(a, b2) {
  if (uc(a.h) >= a.h.j - (a.m ? 1 : 0))
    return false;
  if (a.m)
    return a.i = b2.D.concat(a.i), true;
  if (1 == a.G || 2 == a.G || a.C >= (a.Za ? 0 : a.$a))
    return false;
  a.m = J(q(a.Ja, a, b2), Cd(a, a.C));
  a.C++;
  return true;
}
k.Ja = function(a) {
  if (this.m)
    if (this.m = null, 1 == this.G) {
      if (!a) {
        this.U = Math.floor(1e5 * Math.random());
        a = this.U++;
        const e = new L(this, this.j, a, void 0);
        let f = this.s;
        this.S && (f ? (f = Ra(f), Ta(f, this.S)) : f = this.S);
        null !== this.o || this.N || (e.H = f, f = null);
        if (this.O)
          a: {
            var b2 = 0;
            for (var c = 0; c < this.i.length; c++) {
              b: {
                var d = this.i[c];
                if ("__data__" in d.g && (d = d.g.__data__, "string" === typeof d)) {
                  d = d.length;
                  break b;
                }
                d = void 0;
              }
              if (void 0 === d)
                break;
              b2 += d;
              if (4096 < b2) {
                b2 = c;
                break a;
              }
              if (4096 === b2 || c === this.i.length - 1) {
                b2 = c + 1;
                break a;
              }
            }
            b2 = 1e3;
          }
        else
          b2 = 1e3;
        b2 = Dd(this, e, b2);
        c = M(this.F);
        S(c, "RID", a);
        S(c, "CVER", 22);
        this.D && S(c, "X-HTTP-Session-Id", this.D);
        zd(this, c);
        f && (this.N ? b2 = "headers=" + encodeURIComponent(String(ud(f))) + "&" + b2 : this.o && vd(c, this.o, f));
        vc(this.h, e);
        this.Ya && S(c, "TYPE", "init");
        this.O ? (S(c, "$req", b2), S(c, "SID", "null"), e.Z = true, cc(e, c, null)) : cc(e, c, b2);
        this.G = 2;
      }
    } else
      3 == this.G && (a ? Ed(this, a) : 0 == this.i.length || Yc(this.h) || Ed(this));
};
function Ed(a, b2) {
  var c;
  b2 ? c = b2.m : c = a.U++;
  const d = M(a.F);
  S(d, "SID", a.I);
  S(d, "RID", c);
  S(d, "AID", a.T);
  zd(a, d);
  a.o && a.s && vd(d, a.o, a.s);
  c = new L(a, a.j, c, a.C + 1);
  null === a.o && (c.H = a.s);
  b2 && (a.i = b2.D.concat(a.i));
  b2 = Dd(a, c, 1e3);
  c.setTimeout(Math.round(0.5 * a.ta) + Math.round(0.5 * a.ta * Math.random()));
  vc(a.h, c);
  cc(c, d, b2);
}
function zd(a, b2) {
  a.ia && Qa(a.ia, function(c, d) {
    S(b2, d, c);
  });
  a.l && Dc({}, function(c, d) {
    S(b2, d, c);
  });
}
function Dd(a, b2, c) {
  c = Math.min(a.i.length, c);
  var d = a.l ? q(a.l.Ra, a.l, a) : null;
  a: {
    var e = a.i;
    let f = -1;
    for (; ; ) {
      const h = ["count=" + c];
      -1 == f ? 0 < c ? (f = e[0].h, h.push("ofs=" + f)) : f = 0 : h.push("ofs=" + f);
      let n = true;
      for (let u = 0; u < c; u++) {
        let m = e[u].h;
        const r = e[u].g;
        m -= f;
        if (0 > m)
          f = Math.max(0, e[u].h - 100), n = false;
        else
          try {
            bd(r, h, "req" + m + "_");
          } catch (F2) {
            d && d(r);
          }
      }
      if (n) {
        d = h.join("&");
        break a;
      }
    }
  }
  a = a.i.splice(0, c);
  b2.D = a;
  return d;
}
function yc(a) {
  a.g || a.u || (a.Z = 1, sb(a.Ia, a), a.A = 0);
}
function tc(a) {
  if (a.g || a.u || 3 <= a.A)
    return false;
  a.Z++;
  a.u = J(q(a.Ia, a), Cd(a, a.A));
  a.A++;
  return true;
}
k.Ia = function() {
  this.u = null;
  Fd(this);
  if (this.$ && !(this.K || null == this.g || 0 >= this.P)) {
    var a = 2 * this.P;
    this.j.info("BP detection timer enabled: " + a);
    this.B = J(q(this.eb, this), a);
  }
};
k.eb = function() {
  this.B && (this.B = null, this.j.info("BP detection timeout reached."), this.j.info("Buffering proxy detected and switch to long-polling!"), this.L = false, this.K = true, I(10), sc(this), Fd(this));
};
function oc(a) {
  null != a.B && (l.clearTimeout(a.B), a.B = null);
}
function Fd(a) {
  a.g = new L(a, a.j, "rpc", a.Z);
  null === a.o && (a.g.H = a.s);
  a.g.N = 0;
  var b2 = M(a.sa);
  S(b2, "RID", "rpc");
  S(b2, "SID", a.I);
  S(b2, "CI", a.L ? "0" : "1");
  S(b2, "AID", a.T);
  S(b2, "TYPE", "xmlhttp");
  zd(a, b2);
  a.o && a.s && vd(b2, a.o, a.s);
  a.J && a.g.setTimeout(a.J);
  var c = a.g;
  a = a.ka;
  c.K = 1;
  c.v = dc(M(b2));
  c.s = null;
  c.P = true;
  ec(c, a);
}
k.cb = function() {
  null != this.v && (this.v = null, sc(this), tc(this), I(19));
};
function rc(a) {
  null != a.v && (l.clearTimeout(a.v), a.v = null);
}
function mc(a, b2) {
  var c = null;
  if (a.g == b2) {
    rc(a);
    oc(a);
    a.g = null;
    var d = 2;
  } else if (qc(a.h, b2))
    c = b2.D, xc(a.h, b2), d = 1;
  else
    return;
  if (0 != a.G) {
    if (a.pa = b2.Y, b2.i)
      if (1 == d) {
        c = b2.s ? b2.s.length : 0;
        b2 = Date.now() - b2.F;
        var e = a.C;
        d = Mb();
        C(d, new Pb(d, c));
        zc(a);
      } else
        yc(a);
    else if (e = b2.o, 3 == e || 0 == e && 0 < a.pa || !(1 == d && Bd(a, b2) || 2 == d && tc(a)))
      switch (c && 0 < c.length && (b2 = a.h, b2.i = b2.i.concat(c)), e) {
        case 1:
          R(a, 5);
          break;
        case 4:
          R(a, 10);
          break;
        case 3:
          R(a, 6);
          break;
        default:
          R(a, 2);
      }
  }
}
function Cd(a, b2) {
  let c = a.Xa + Math.floor(Math.random() * a.bb);
  a.l || (c *= 2);
  return c * b2;
}
function R(a, b2) {
  a.j.info("Error code " + b2);
  if (2 == b2) {
    var c = null;
    a.l && (c = null);
    var d = q(a.kb, a);
    c || (c = new T("//www.google.com/images/cleardot.gif"), l.location && "http" == l.location.protocol || Gc(c, "https"), dc(c));
    cd(c.toString(), d);
  } else
    I(2);
  a.G = 0;
  a.l && a.l.va(b2);
  Ad(a);
  yd(a);
}
k.kb = function(a) {
  a ? (this.j.info("Successfully pinged google.com"), I(2)) : (this.j.info("Failed to ping google.com"), I(1));
};
function Ad(a) {
  a.G = 0;
  a.la = [];
  if (a.l) {
    const b2 = Zc(a.h);
    if (0 != b2.length || 0 != a.i.length)
      na(a.la, b2), na(a.la, a.i), a.h.i.length = 0, ma(a.i), a.i.length = 0;
    a.l.ua();
  }
}
function wc(a, b2, c) {
  var d = c instanceof T ? M(c) : new T(c, void 0);
  if ("" != d.g)
    b2 && (d.g = b2 + "." + d.g), Hc(d, d.m);
  else {
    var e = l.location;
    d = e.protocol;
    b2 = b2 ? b2 + "." + e.hostname : e.hostname;
    e = +e.port;
    var f = new T(null, void 0);
    d && Gc(f, d);
    b2 && (f.g = b2);
    e && Hc(f, e);
    c && (f.l = c);
    d = f;
  }
  c = a.D;
  b2 = a.za;
  c && b2 && S(d, c, b2);
  S(d, "VER", a.ma);
  zd(a, d);
  return d;
}
function gc(a, b2, c) {
  if (b2 && !a.H)
    throw Error("Can't create secondary domain capable XhrIo object.");
  b2 = c && a.Da && !a.ra ? new W(new ed({ jb: true })) : new W(a.ra);
  b2.Ka(a.H);
  return b2;
}
function Gd() {
}
k = Gd.prototype;
k.xa = function() {
};
k.wa = function() {
};
k.va = function() {
};
k.ua = function() {
};
k.Ra = function() {
};
function Hd() {
  if (y && !(10 <= Number(La)))
    throw Error("Environmental error: no available transport.");
}
Hd.prototype.g = function(a, b2) {
  return new X(a, b2);
};
function X(a, b2) {
  B.call(this);
  this.g = new xd(b2);
  this.l = a;
  this.h = b2 && b2.messageUrlParams || null;
  a = b2 && b2.messageHeaders || null;
  b2 && b2.clientProtocolHeaderRequired && (a ? a["X-Client-Protocol"] = "webchannel" : a = { "X-Client-Protocol": "webchannel" });
  this.g.s = a;
  a = b2 && b2.initMessageHeaders || null;
  b2 && b2.messageContentType && (a ? a["X-WebChannel-Content-Type"] = b2.messageContentType : a = { "X-WebChannel-Content-Type": b2.messageContentType });
  b2 && b2.ya && (a ? a["X-WebChannel-Client-Profile"] = b2.ya : a = { "X-WebChannel-Client-Profile": b2.ya });
  this.g.S = a;
  (a = b2 && b2.Yb) && !pa(a) && (this.g.o = a);
  this.A = b2 && b2.supportsCrossDomainXhr || false;
  this.v = b2 && b2.sendRawJson || false;
  (b2 = b2 && b2.httpSessionIdParam) && !pa(b2) && (this.g.D = b2, a = this.h, null !== a && b2 in a && (a = this.h, b2 in a && delete a[b2]));
  this.j = new Y(this);
}
t(X, B);
X.prototype.m = function() {
  this.g.l = this.j;
  this.A && (this.g.H = true);
  var a = this.g, b2 = this.l, c = this.h || void 0;
  I(0);
  a.V = b2;
  a.ia = c || {};
  a.L = a.Y;
  a.F = wc(a, null, a.V);
  zc(a);
};
X.prototype.close = function() {
  Ac(this.g);
};
X.prototype.u = function(a) {
  var b2 = this.g;
  if ("string" === typeof a) {
    var c = {};
    c.__data__ = a;
    a = c;
  } else
    this.v && (c = {}, c.__data__ = lb(a), a = c);
  b2.i.push(new Vc(b2.ab++, a));
  3 == b2.G && zc(b2);
};
X.prototype.M = function() {
  this.g.l = null;
  delete this.j;
  Ac(this.g);
  delete this.g;
  X.X.M.call(this);
};
function Id(a) {
  Vb.call(this);
  var b2 = a.__sm__;
  if (b2) {
    a: {
      for (const c in b2) {
        a = c;
        break a;
      }
      a = void 0;
    }
    if (this.i = a)
      a = this.i, b2 = null !== b2 && a in b2 ? b2[a] : void 0;
    this.data = b2;
  } else
    this.data = a;
}
t(Id, Vb);
function Jd() {
  Wb.call(this);
  this.status = 1;
}
t(Jd, Wb);
function Y(a) {
  this.g = a;
}
t(Y, Gd);
Y.prototype.xa = function() {
  C(this.g, "a");
};
Y.prototype.wa = function(a) {
  C(this.g, new Id(a));
};
Y.prototype.va = function(a) {
  C(this.g, new Jd());
};
Y.prototype.ua = function() {
  C(this.g, "b");
};
Hd.prototype.createWebChannel = Hd.prototype.g;
X.prototype.send = X.prototype.u;
X.prototype.open = X.prototype.m;
X.prototype.close = X.prototype.close;
Qb.NO_ERROR = 0;
Qb.TIMEOUT = 8;
Qb.HTTP_ERROR = 6;
Rb.COMPLETE = "complete";
Ub.EventType = K;
K.OPEN = "a";
K.CLOSE = "b";
K.ERROR = "c";
K.MESSAGE = "d";
B.prototype.listen = B.prototype.N;
W.prototype.listenOnce = W.prototype.O;
W.prototype.getLastError = W.prototype.Oa;
W.prototype.getLastErrorCode = W.prototype.Ea;
W.prototype.getStatus = W.prototype.aa;
W.prototype.getResponseJson = W.prototype.Sa;
W.prototype.getResponseText = W.prototype.fa;
W.prototype.send = W.prototype.da;
W.prototype.setWithCredentials = W.prototype.Ka;
var createWebChannelTransport = esm.createWebChannelTransport = function() {
  return new Hd();
};
var getStatEventTarget = esm.getStatEventTarget = function() {
  return Mb();
};
var ErrorCode = esm.ErrorCode = Qb;
var EventType = esm.EventType = Rb;
var Event = esm.Event = G;
var Stat = esm.Stat = { sb: 0, vb: 1, wb: 2, Pb: 3, Ub: 4, Rb: 5, Sb: 6, Qb: 7, Ob: 8, Tb: 9, PROXY: 10, NOPROXY: 11, Mb: 12, Ib: 13, Jb: 14, Hb: 15, Kb: 16, Lb: 17, ob: 18, nb: 19, pb: 20 };
var FetchXmlHttpFactory = esm.FetchXmlHttpFactory = ed;
var WebChannel = esm.WebChannel = Ub;
var XhrIo = esm.XhrIo = W;

// node_modules/@firebase/firestore/dist/index.esm2017.js
var v2 = "@firebase/firestore";
var b = class {
  constructor(t2) {
    this.uid = t2;
  }
  isAuthenticated() {
    return null != this.uid;
  }
  toKey() {
    return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user";
  }
  isEqual(t2) {
    return t2.uid === this.uid;
  }
};
b.UNAUTHENTICATED = new b(null), b.GOOGLE_CREDENTIALS = new b("google-credentials-uid"), b.FIRST_PARTY = new b("first-party-uid"), b.MOCK_USER = new b("mock-user");
var P2 = "9.19.0";
var V2 = new Logger("@firebase/firestore");
function S2() {
  return V2.logLevel;
}
function D2(t2) {
  V2.setLogLevel(t2);
}
function C2(t2, ...e) {
  if (V2.logLevel <= LogLevel.DEBUG) {
    const n = e.map(k2);
    V2.debug(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function x2(t2, ...e) {
  if (V2.logLevel <= LogLevel.ERROR) {
    const n = e.map(k2);
    V2.error(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function N2(t2, ...e) {
  if (V2.logLevel <= LogLevel.WARN) {
    const n = e.map(k2);
    V2.warn(`Firestore (${P2}): ${t2}`, ...n);
  }
}
function k2(t2) {
  if ("string" == typeof t2)
    return t2;
  try {
    return e = t2, JSON.stringify(e);
  } catch (e2) {
    return t2;
  }
  var e;
}
function O2(t2 = "Unexpected state") {
  const e = `FIRESTORE (${P2}) INTERNAL ASSERTION FAILED: ` + t2;
  throw x2(e), new Error(e);
}
function $(t2, e) {
  t2 || O2();
}
function M2(t2, e) {
  t2 || O2();
}
function F(t2, e) {
  return t2;
}
var B2 = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var L2 = class extends FirebaseError {
  constructor(t2, e) {
    super(t2, e), this.code = t2, this.message = e, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}`;
  }
};
var q2 = class {
  constructor() {
    this.promise = new Promise((t2, e) => {
      this.resolve = t2, this.reject = e;
    });
  }
};
var U2 = class {
  constructor(t2, e) {
    this.user = e, this.type = "OAuth", this.headers = /* @__PURE__ */ new Map(), this.headers.set("Authorization", `Bearer ${t2}`);
  }
};
var K2 = class {
  getToken() {
    return Promise.resolve(null);
  }
  invalidateToken() {
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(b.UNAUTHENTICATED));
  }
  shutdown() {
  }
};
var G2 = class {
  constructor(t2) {
    this.token = t2, this.changeListener = null;
  }
  getToken() {
    return Promise.resolve(this.token);
  }
  invalidateToken() {
  }
  start(t2, e) {
    this.changeListener = e, t2.enqueueRetryable(() => e(this.token.user));
  }
  shutdown() {
    this.changeListener = null;
  }
};
var Q2 = class {
  constructor(t2) {
    this.t = t2, this.currentUser = b.UNAUTHENTICATED, this.i = 0, this.forceRefresh = false, this.auth = null;
  }
  start(t2, e) {
    let n = this.i;
    const s = (t3) => this.i !== n ? (n = this.i, e(t3)) : Promise.resolve();
    let i = new q2();
    this.o = () => {
      this.i++, this.currentUser = this.u(), i.resolve(), i = new q2(), t2.enqueueRetryable(() => s(this.currentUser));
    };
    const r = () => {
      const e2 = i;
      t2.enqueueRetryable(async () => {
        await e2.promise, await s(this.currentUser);
      });
    }, o = (t3) => {
      C2("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = t3, this.auth.addAuthTokenListener(this.o), r();
    };
    this.t.onInit((t3) => o(t3)), setTimeout(() => {
      if (!this.auth) {
        const t3 = this.t.getImmediate({
          optional: true
        });
        t3 ? o(t3) : (C2("FirebaseAuthCredentialsProvider", "Auth not yet detected"), i.resolve(), i = new q2());
      }
    }, 0), r();
  }
  getToken() {
    const t2 = this.i, e = this.forceRefresh;
    return this.forceRefresh = false, this.auth ? this.auth.getToken(e).then((e2) => this.i !== t2 ? (C2("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : e2 ? ($("string" == typeof e2.accessToken), new U2(e2.accessToken, this.currentUser)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.auth && this.auth.removeAuthTokenListener(this.o);
  }
  u() {
    const t2 = this.auth && this.auth.getUid();
    return $(null === t2 || "string" == typeof t2), new b(t2);
  }
};
var z2 = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n, this.type = "FirstParty", this.user = b.FIRST_PARTY, this.g = /* @__PURE__ */ new Map();
  }
  p() {
    return this.m ? this.m() : null;
  }
  get headers() {
    this.g.set("X-Goog-AuthUser", this.h);
    const t2 = this.p();
    return t2 && this.g.set("Authorization", t2), this.l && this.g.set("X-Goog-Iam-Authorization-Token", this.l), this.g;
  }
};
var j = class {
  constructor(t2, e, n) {
    this.h = t2, this.l = e, this.m = n;
  }
  getToken() {
    return Promise.resolve(new z2(this.h, this.l, this.m));
  }
  start(t2, e) {
    t2.enqueueRetryable(() => e(b.FIRST_PARTY));
  }
  shutdown() {
  }
  invalidateToken() {
  }
};
var W2 = class {
  constructor(t2) {
    this.value = t2, this.type = "AppCheck", this.headers = /* @__PURE__ */ new Map(), t2 && t2.length > 0 && this.headers.set("x-firebase-appcheck", this.value);
  }
};
var H2 = class {
  constructor(t2) {
    this.I = t2, this.forceRefresh = false, this.appCheck = null, this.T = null;
  }
  start(t2, e) {
    const n = (t3) => {
      null != t3.error && C2("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${t3.error.message}`);
      const n2 = t3.token !== this.T;
      return this.T = t3.token, C2("FirebaseAppCheckTokenProvider", `Received ${n2 ? "new" : "existing"} token.`), n2 ? e(t3.token) : Promise.resolve();
    };
    this.o = (e2) => {
      t2.enqueueRetryable(() => n(e2));
    };
    const s = (t3) => {
      C2("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = t3, this.appCheck.addTokenListener(this.o);
    };
    this.I.onInit((t3) => s(t3)), setTimeout(() => {
      if (!this.appCheck) {
        const t3 = this.I.getImmediate({
          optional: true
        });
        t3 ? s(t3) : C2("FirebaseAppCheckTokenProvider", "AppCheck not yet detected");
      }
    }, 0);
  }
  getToken() {
    const t2 = this.forceRefresh;
    return this.forceRefresh = false, this.appCheck ? this.appCheck.getToken(t2).then((t3) => t3 ? ($("string" == typeof t3.token), this.T = t3.token, new W2(t3.token)) : null) : Promise.resolve(null);
  }
  invalidateToken() {
    this.forceRefresh = true;
  }
  shutdown() {
    this.appCheck && this.appCheck.removeTokenListener(this.o);
  }
};
var J2 = class {
  getToken() {
    return Promise.resolve(new W2(""));
  }
  invalidateToken() {
  }
  start(t2, e) {
  }
  shutdown() {
  }
};
function Y2(t2) {
  const e = "undefined" != typeof self && (self.crypto || self.msCrypto), n = new Uint8Array(t2);
  if (e && "function" == typeof e.getRandomValues)
    e.getRandomValues(n);
  else
    for (let e2 = 0; e2 < t2; e2++)
      n[e2] = Math.floor(256 * Math.random());
  return n;
}
var Z = class {
  static A() {
    const t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", e = Math.floor(256 / t2.length) * t2.length;
    let n = "";
    for (; n.length < 20; ) {
      const s = Y2(40);
      for (let i = 0; i < s.length; ++i)
        n.length < 20 && s[i] < e && (n += t2.charAt(s[i] % t2.length));
    }
    return n;
  }
};
function X2(t2, e) {
  return t2 < e ? -1 : t2 > e ? 1 : 0;
}
function tt(t2, e, n) {
  return t2.length === e.length && t2.every((t3, s) => n(t3, e[s]));
}
function et(t2) {
  return t2 + "\0";
}
var nt = class {
  constructor(t2, e) {
    if (this.seconds = t2, this.nanoseconds = e, e < 0)
      throw new L2(B2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (e >= 1e9)
      throw new L2(B2.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + e);
    if (t2 < -62135596800)
      throw new L2(B2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
    if (t2 >= 253402300800)
      throw new L2(B2.INVALID_ARGUMENT, "Timestamp seconds out of range: " + t2);
  }
  static now() {
    return nt.fromMillis(Date.now());
  }
  static fromDate(t2) {
    return nt.fromMillis(t2.getTime());
  }
  static fromMillis(t2) {
    const e = Math.floor(t2 / 1e3), n = Math.floor(1e6 * (t2 - 1e3 * e));
    return new nt(e, n);
  }
  toDate() {
    return new Date(this.toMillis());
  }
  toMillis() {
    return 1e3 * this.seconds + this.nanoseconds / 1e6;
  }
  _compareTo(t2) {
    return this.seconds === t2.seconds ? X2(this.nanoseconds, t2.nanoseconds) : X2(this.seconds, t2.seconds);
  }
  isEqual(t2) {
    return t2.seconds === this.seconds && t2.nanoseconds === this.nanoseconds;
  }
  toString() {
    return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")";
  }
  toJSON() {
    return {
      seconds: this.seconds,
      nanoseconds: this.nanoseconds
    };
  }
  valueOf() {
    const t2 = this.seconds - -62135596800;
    return String(t2).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0");
  }
};
var st = class {
  constructor(t2) {
    this.timestamp = t2;
  }
  static fromTimestamp(t2) {
    return new st(t2);
  }
  static min() {
    return new st(new nt(0, 0));
  }
  static max() {
    return new st(new nt(253402300799, 999999999));
  }
  compareTo(t2) {
    return this.timestamp._compareTo(t2.timestamp);
  }
  isEqual(t2) {
    return this.timestamp.isEqual(t2.timestamp);
  }
  toMicroseconds() {
    return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3;
  }
  toString() {
    return "SnapshotVersion(" + this.timestamp.toString() + ")";
  }
  toTimestamp() {
    return this.timestamp;
  }
};
var it = class {
  constructor(t2, e, n) {
    void 0 === e ? e = 0 : e > t2.length && O2(), void 0 === n ? n = t2.length - e : n > t2.length - e && O2(), this.segments = t2, this.offset = e, this.len = n;
  }
  get length() {
    return this.len;
  }
  isEqual(t2) {
    return 0 === it.comparator(this, t2);
  }
  child(t2) {
    const e = this.segments.slice(this.offset, this.limit());
    return t2 instanceof it ? t2.forEach((t3) => {
      e.push(t3);
    }) : e.push(t2), this.construct(e);
  }
  limit() {
    return this.offset + this.length;
  }
  popFirst(t2) {
    return t2 = void 0 === t2 ? 1 : t2, this.construct(this.segments, this.offset + t2, this.length - t2);
  }
  popLast() {
    return this.construct(this.segments, this.offset, this.length - 1);
  }
  firstSegment() {
    return this.segments[this.offset];
  }
  lastSegment() {
    return this.get(this.length - 1);
  }
  get(t2) {
    return this.segments[this.offset + t2];
  }
  isEmpty() {
    return 0 === this.length;
  }
  isPrefixOf(t2) {
    if (t2.length < this.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  isImmediateParentOf(t2) {
    if (this.length + 1 !== t2.length)
      return false;
    for (let e = 0; e < this.length; e++)
      if (this.get(e) !== t2.get(e))
        return false;
    return true;
  }
  forEach(t2) {
    for (let e = this.offset, n = this.limit(); e < n; e++)
      t2(this.segments[e]);
  }
  toArray() {
    return this.segments.slice(this.offset, this.limit());
  }
  static comparator(t2, e) {
    const n = Math.min(t2.length, e.length);
    for (let s = 0; s < n; s++) {
      const n2 = t2.get(s), i = e.get(s);
      if (n2 < i)
        return -1;
      if (n2 > i)
        return 1;
    }
    return t2.length < e.length ? -1 : t2.length > e.length ? 1 : 0;
  }
};
var rt = class extends it {
  construct(t2, e, n) {
    return new rt(t2, e, n);
  }
  canonicalString() {
    return this.toArray().join("/");
  }
  toString() {
    return this.canonicalString();
  }
  static fromString(...t2) {
    const e = [];
    for (const n of t2) {
      if (n.indexOf("//") >= 0)
        throw new L2(B2.INVALID_ARGUMENT, `Invalid segment (${n}). Paths must not contain // in them.`);
      e.push(...n.split("/").filter((t3) => t3.length > 0));
    }
    return new rt(e);
  }
  static emptyPath() {
    return new rt([]);
  }
};
var ot = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
var ut = class extends it {
  construct(t2, e, n) {
    return new ut(t2, e, n);
  }
  static isValidIdentifier(t2) {
    return ot.test(t2);
  }
  canonicalString() {
    return this.toArray().map((t2) => (t2 = t2.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), ut.isValidIdentifier(t2) || (t2 = "`" + t2 + "`"), t2)).join(".");
  }
  toString() {
    return this.canonicalString();
  }
  isKeyField() {
    return 1 === this.length && "__name__" === this.get(0);
  }
  static keyField() {
    return new ut(["__name__"]);
  }
  static fromServerFormat(t2) {
    const e = [];
    let n = "", s = 0;
    const i = () => {
      if (0 === n.length)
        throw new L2(B2.INVALID_ARGUMENT, `Invalid field path (${t2}). Paths must not be empty, begin with '.', end with '.', or contain '..'`);
      e.push(n), n = "";
    };
    let r = false;
    for (; s < t2.length; ) {
      const e2 = t2[s];
      if ("\\" === e2) {
        if (s + 1 === t2.length)
          throw new L2(B2.INVALID_ARGUMENT, "Path has trailing escape character: " + t2);
        const e3 = t2[s + 1];
        if ("\\" !== e3 && "." !== e3 && "`" !== e3)
          throw new L2(B2.INVALID_ARGUMENT, "Path has invalid escape sequence: " + t2);
        n += e3, s += 2;
      } else
        "`" === e2 ? (r = !r, s++) : "." !== e2 || r ? (n += e2, s++) : (i(), s++);
    }
    if (i(), r)
      throw new L2(B2.INVALID_ARGUMENT, "Unterminated ` in path: " + t2);
    return new ut(e);
  }
  static emptyPath() {
    return new ut([]);
  }
};
var ct = class {
  constructor(t2) {
    this.path = t2;
  }
  static fromPath(t2) {
    return new ct(rt.fromString(t2));
  }
  static fromName(t2) {
    return new ct(rt.fromString(t2).popFirst(5));
  }
  static empty() {
    return new ct(rt.emptyPath());
  }
  get collectionGroup() {
    return this.path.popLast().lastSegment();
  }
  hasCollectionId(t2) {
    return this.path.length >= 2 && this.path.get(this.path.length - 2) === t2;
  }
  getCollectionGroup() {
    return this.path.get(this.path.length - 2);
  }
  getCollectionPath() {
    return this.path.popLast();
  }
  isEqual(t2) {
    return null !== t2 && 0 === rt.comparator(this.path, t2.path);
  }
  toString() {
    return this.path.toString();
  }
  static comparator(t2, e) {
    return rt.comparator(t2.path, e.path);
  }
  static isDocumentKey(t2) {
    return t2.length % 2 == 0;
  }
  static fromSegments(t2) {
    return new ct(new rt(t2.slice()));
  }
};
var at = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.collectionGroup = e, this.fields = n, this.indexState = s;
  }
};
function ht(t2) {
  return t2.fields.find((t3) => 2 === t3.kind);
}
function lt(t2) {
  return t2.fields.filter((t3) => 2 !== t3.kind);
}
function ft(t2, e) {
  let n = X2(t2.collectionGroup, e.collectionGroup);
  if (0 !== n)
    return n;
  for (let s = 0; s < Math.min(t2.fields.length, e.fields.length); ++s)
    if (n = wt(t2.fields[s], e.fields[s]), 0 !== n)
      return n;
  return X2(t2.fields.length, e.fields.length);
}
at.UNKNOWN_ID = -1;
var dt = class {
  constructor(t2, e) {
    this.fieldPath = t2, this.kind = e;
  }
};
function wt(t2, e) {
  const n = ut.comparator(t2.fieldPath, e.fieldPath);
  return 0 !== n ? n : X2(t2.kind, e.kind);
}
var _t = class {
  constructor(t2, e) {
    this.sequenceNumber = t2, this.offset = e;
  }
  static empty() {
    return new _t(0, yt.min());
  }
};
function mt(t2, e) {
  const n = t2.toTimestamp().seconds, s = t2.toTimestamp().nanoseconds + 1, i = st.fromTimestamp(1e9 === s ? new nt(n + 1, 0) : new nt(n, s));
  return new yt(i, ct.empty(), e);
}
function gt(t2) {
  return new yt(t2.readTime, t2.key, -1);
}
var yt = class {
  constructor(t2, e, n) {
    this.readTime = t2, this.documentKey = e, this.largestBatchId = n;
  }
  static min() {
    return new yt(st.min(), ct.empty(), -1);
  }
  static max() {
    return new yt(st.max(), ct.empty(), -1);
  }
};
function pt(t2, e) {
  let n = t2.readTime.compareTo(e.readTime);
  return 0 !== n ? n : (n = ct.comparator(t2.documentKey, e.documentKey), 0 !== n ? n : X2(t2.largestBatchId, e.largestBatchId));
}
var It = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab.";
var Tt = class {
  constructor() {
    this.onCommittedListeners = [];
  }
  addOnCommittedListener(t2) {
    this.onCommittedListeners.push(t2);
  }
  raiseOnCommittedEvent() {
    this.onCommittedListeners.forEach((t2) => t2());
  }
};
async function Et(t2) {
  if (t2.code !== B2.FAILED_PRECONDITION || t2.message !== It)
    throw t2;
  C2("LocalStore", "Unexpectedly lost primary lease");
}
var At = class {
  constructor(t2) {
    this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = false, this.callbackAttached = false, t2((t3) => {
      this.isDone = true, this.result = t3, this.nextCallback && this.nextCallback(t3);
    }, (t3) => {
      this.isDone = true, this.error = t3, this.catchCallback && this.catchCallback(t3);
    });
  }
  catch(t2) {
    return this.next(void 0, t2);
  }
  next(t2, e) {
    return this.callbackAttached && O2(), this.callbackAttached = true, this.isDone ? this.error ? this.wrapFailure(e, this.error) : this.wrapSuccess(t2, this.result) : new At((n, s) => {
      this.nextCallback = (e2) => {
        this.wrapSuccess(t2, e2).next(n, s);
      }, this.catchCallback = (t3) => {
        this.wrapFailure(e, t3).next(n, s);
      };
    });
  }
  toPromise() {
    return new Promise((t2, e) => {
      this.next(t2, e);
    });
  }
  wrapUserFunction(t2) {
    try {
      const e = t2();
      return e instanceof At ? e : At.resolve(e);
    } catch (t3) {
      return At.reject(t3);
    }
  }
  wrapSuccess(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : At.resolve(e);
  }
  wrapFailure(t2, e) {
    return t2 ? this.wrapUserFunction(() => t2(e)) : At.reject(e);
  }
  static resolve(t2) {
    return new At((e, n) => {
      e(t2);
    });
  }
  static reject(t2) {
    return new At((e, n) => {
      n(t2);
    });
  }
  static waitFor(t2) {
    return new At((e, n) => {
      let s = 0, i = 0, r = false;
      t2.forEach((t3) => {
        ++s, t3.next(() => {
          ++i, r && i === s && e();
        }, (t4) => n(t4));
      }), r = true, i === s && e();
    });
  }
  static or(t2) {
    let e = At.resolve(false);
    for (const n of t2)
      e = e.next((t3) => t3 ? At.resolve(t3) : n());
    return e;
  }
  static forEach(t2, e) {
    const n = [];
    return t2.forEach((t3, s) => {
      n.push(e.call(this, t3, s));
    }), this.waitFor(n);
  }
  static mapArray(t2, e) {
    return new At((n, s) => {
      const i = t2.length, r = new Array(i);
      let o = 0;
      for (let u = 0; u < i; u++) {
        const c = u;
        e(t2[c]).next((t3) => {
          r[c] = t3, ++o, o === i && n(r);
        }, (t3) => s(t3));
      }
    });
  }
  static doWhile(t2, e) {
    return new At((n, s) => {
      const i = () => {
        true === t2() ? e().next(() => {
          i();
        }, s) : n();
      };
      i();
    });
  }
};
var Rt = class {
  constructor(t2, e) {
    this.action = t2, this.transaction = e, this.aborted = false, this.R = new q2(), this.transaction.oncomplete = () => {
      this.R.resolve();
    }, this.transaction.onabort = () => {
      e.error ? this.R.reject(new Pt(t2, e.error)) : this.R.resolve();
    }, this.transaction.onerror = (e2) => {
      const n = xt(e2.target.error);
      this.R.reject(new Pt(t2, n));
    };
  }
  static open(t2, e, n, s) {
    try {
      return new Rt(e, t2.transaction(s, n));
    } catch (t3) {
      throw new Pt(e, t3);
    }
  }
  get v() {
    return this.R.promise;
  }
  abort(t2) {
    t2 && this.R.reject(t2), this.aborted || (C2("SimpleDb", "Aborting transaction:", t2 ? t2.message : "Client-initiated abort"), this.aborted = true, this.transaction.abort());
  }
  P() {
    const t2 = this.transaction;
    this.aborted || "function" != typeof t2.commit || t2.commit();
  }
  store(t2) {
    const e = this.transaction.objectStore(t2);
    return new St(e);
  }
};
var vt = class {
  constructor(t2, e, n) {
    this.name = t2, this.version = e, this.V = n;
    12.2 === vt.S(getUA()) && x2("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.");
  }
  static delete(t2) {
    return C2("SimpleDb", "Removing database:", t2), Dt(window.indexedDB.deleteDatabase(t2)).toPromise();
  }
  static D() {
    if (!isIndexedDBAvailable())
      return false;
    if (vt.C())
      return true;
    const t2 = getUA(), e = vt.S(t2), n = 0 < e && e < 10, s = vt.N(t2), i = 0 < s && s < 4.5;
    return !(t2.indexOf("MSIE ") > 0 || t2.indexOf("Trident/") > 0 || t2.indexOf("Edge/") > 0 || n || i);
  }
  static C() {
    var t2;
    return "undefined" != typeof process && "YES" === (null === (t2 = process.env) || void 0 === t2 ? void 0 : t2.k);
  }
  static O(t2, e) {
    return t2.store(e);
  }
  static S(t2) {
    const e = t2.match(/i(?:phone|pad|pod) os ([\d_]+)/i), n = e ? e[1].split("_").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  static N(t2) {
    const e = t2.match(/Android ([\d.]+)/i), n = e ? e[1].split(".").slice(0, 2).join(".") : "-1";
    return Number(n);
  }
  async $(t2) {
    return this.db || (C2("SimpleDb", "Opening database:", this.name), this.db = await new Promise((e, n) => {
      const s = indexedDB.open(this.name, this.version);
      s.onsuccess = (t3) => {
        const n2 = t3.target.result;
        e(n2);
      }, s.onblocked = () => {
        n(new Pt(t2, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed."));
      }, s.onerror = (e2) => {
        const s2 = e2.target.error;
        "VersionError" === s2.name ? n(new L2(B2.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.")) : "InvalidStateError" === s2.name ? n(new L2(B2.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + s2)) : n(new Pt(t2, s2));
      }, s.onupgradeneeded = (t3) => {
        C2("SimpleDb", 'Database "' + this.name + '" requires upgrade from version:', t3.oldVersion);
        const e2 = t3.target.result;
        this.V.M(e2, s.transaction, t3.oldVersion, this.version).next(() => {
          C2("SimpleDb", "Database upgrade to version " + this.version + " complete");
        });
      };
    })), this.F && (this.db.onversionchange = (t3) => this.F(t3)), this.db;
  }
  B(t2) {
    this.F = t2, this.db && (this.db.onversionchange = (e) => t2(e));
  }
  async runTransaction(t2, e, n, s) {
    const i = "readonly" === e;
    let r = 0;
    for (; ; ) {
      ++r;
      try {
        this.db = await this.$(t2);
        const e2 = Rt.open(this.db, t2, i ? "readonly" : "readwrite", n), r2 = s(e2).next((t3) => (e2.P(), t3)).catch((t3) => (e2.abort(t3), At.reject(t3))).toPromise();
        return r2.catch(() => {
        }), await e2.v, r2;
      } catch (t3) {
        const e2 = t3, n2 = "FirebaseError" !== e2.name && r < 3;
        if (C2("SimpleDb", "Transaction failed with error:", e2.message, "Retrying:", n2), this.close(), !n2)
          return Promise.reject(e2);
      }
    }
  }
  close() {
    this.db && this.db.close(), this.db = void 0;
  }
};
var bt = class {
  constructor(t2) {
    this.L = t2, this.q = false, this.U = null;
  }
  get isDone() {
    return this.q;
  }
  get K() {
    return this.U;
  }
  set cursor(t2) {
    this.L = t2;
  }
  done() {
    this.q = true;
  }
  G(t2) {
    this.U = t2;
  }
  delete() {
    return Dt(this.L.delete());
  }
};
var Pt = class extends L2 {
  constructor(t2, e) {
    super(B2.UNAVAILABLE, `IndexedDB transaction '${t2}' failed: ${e}`), this.name = "IndexedDbTransactionError";
  }
};
function Vt(t2) {
  return "IndexedDbTransactionError" === t2.name;
}
var St = class {
  constructor(t2) {
    this.store = t2;
  }
  put(t2, e) {
    let n;
    return void 0 !== e ? (C2("SimpleDb", "PUT", this.store.name, t2, e), n = this.store.put(e, t2)) : (C2("SimpleDb", "PUT", this.store.name, "<auto-key>", t2), n = this.store.put(t2)), Dt(n);
  }
  add(t2) {
    C2("SimpleDb", "ADD", this.store.name, t2, t2);
    return Dt(this.store.add(t2));
  }
  get(t2) {
    return Dt(this.store.get(t2)).next((e) => (void 0 === e && (e = null), C2("SimpleDb", "GET", this.store.name, t2, e), e));
  }
  delete(t2) {
    C2("SimpleDb", "DELETE", this.store.name, t2);
    return Dt(this.store.delete(t2));
  }
  count() {
    C2("SimpleDb", "COUNT", this.store.name);
    return Dt(this.store.count());
  }
  j(t2, e) {
    const n = this.options(t2, e);
    if (n.index || "function" != typeof this.store.getAll) {
      const t3 = this.cursor(n), e2 = [];
      return this.W(t3, (t4, n2) => {
        e2.push(n2);
      }).next(() => e2);
    }
    {
      const t3 = this.store.getAll(n.range);
      return new At((e2, n2) => {
        t3.onerror = (t4) => {
          n2(t4.target.error);
        }, t3.onsuccess = (t4) => {
          e2(t4.target.result);
        };
      });
    }
  }
  H(t2, e) {
    const n = this.store.getAll(t2, null === e ? void 0 : e);
    return new At((t3, e2) => {
      n.onerror = (t4) => {
        e2(t4.target.error);
      }, n.onsuccess = (e3) => {
        t3(e3.target.result);
      };
    });
  }
  J(t2, e) {
    C2("SimpleDb", "DELETE ALL", this.store.name);
    const n = this.options(t2, e);
    n.Y = false;
    const s = this.cursor(n);
    return this.W(s, (t3, e2, n2) => n2.delete());
  }
  Z(t2, e) {
    let n;
    e ? n = t2 : (n = {}, e = t2);
    const s = this.cursor(n);
    return this.W(s, e);
  }
  X(t2) {
    const e = this.cursor({});
    return new At((n, s) => {
      e.onerror = (t3) => {
        const e2 = xt(t3.target.error);
        s(e2);
      }, e.onsuccess = (e2) => {
        const s2 = e2.target.result;
        s2 ? t2(s2.primaryKey, s2.value).next((t3) => {
          t3 ? s2.continue() : n();
        }) : n();
      };
    });
  }
  W(t2, e) {
    const n = [];
    return new At((s, i) => {
      t2.onerror = (t3) => {
        i(t3.target.error);
      }, t2.onsuccess = (t3) => {
        const i2 = t3.target.result;
        if (!i2)
          return void s();
        const r = new bt(i2), o = e(i2.primaryKey, i2.value, r);
        if (o instanceof At) {
          const t4 = o.catch((t5) => (r.done(), At.reject(t5)));
          n.push(t4);
        }
        r.isDone ? s() : null === r.K ? i2.continue() : i2.continue(r.K);
      };
    }).next(() => At.waitFor(n));
  }
  options(t2, e) {
    let n;
    return void 0 !== t2 && ("string" == typeof t2 ? n = t2 : e = t2), {
      index: n,
      range: e
    };
  }
  cursor(t2) {
    let e = "next";
    if (t2.reverse && (e = "prev"), t2.index) {
      const n = this.store.index(t2.index);
      return t2.Y ? n.openKeyCursor(t2.range, e) : n.openCursor(t2.range, e);
    }
    return this.store.openCursor(t2.range, e);
  }
};
function Dt(t2) {
  return new At((e, n) => {
    t2.onsuccess = (t3) => {
      const n2 = t3.target.result;
      e(n2);
    }, t2.onerror = (t3) => {
      const e2 = xt(t3.target.error);
      n(e2);
    };
  });
}
var Ct = false;
function xt(t2) {
  const e = vt.S(getUA());
  if (e >= 12.2 && e < 13) {
    const e2 = "An internal error was encountered in the Indexed Database server";
    if (t2.message.indexOf(e2) >= 0) {
      const t3 = new L2("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${e2}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`);
      return Ct || (Ct = true, setTimeout(() => {
        throw t3;
      }, 0)), t3;
    }
  }
  return t2;
}
var Nt = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.tt = e, this.task = null;
  }
  start() {
    this.et(15e3);
  }
  stop() {
    this.task && (this.task.cancel(), this.task = null);
  }
  get started() {
    return null !== this.task;
  }
  et(t2) {
    C2("IndexBackiller", `Scheduled in ${t2}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", t2, async () => {
      this.task = null;
      try {
        C2("IndexBackiller", `Documents written: ${await this.tt.nt()}`);
      } catch (t3) {
        Vt(t3) ? C2("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", t3) : await Et(t3);
      }
      await this.et(6e4);
    });
  }
};
var kt = class {
  constructor(t2, e) {
    this.localStore = t2, this.persistence = e;
  }
  async nt(t2 = 50) {
    return this.persistence.runTransaction("Backfill Indexes", "readwrite-primary", (e) => this.st(e, t2));
  }
  st(t2, e) {
    const n = /* @__PURE__ */ new Set();
    let s = e, i = true;
    return At.doWhile(() => true === i && s > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(t2).next((e2) => {
      if (null !== e2 && !n.has(e2))
        return C2("IndexBackiller", `Processing collection: ${e2}`), this.it(t2, e2, s).next((t3) => {
          s -= t3, n.add(e2);
        });
      i = false;
    })).next(() => e - s);
  }
  it(t2, e, n) {
    return this.localStore.indexManager.getMinOffsetFromCollectionGroup(t2, e).next((s) => this.localStore.localDocuments.getNextDocuments(t2, e, s, n).next((n2) => {
      const i = n2.changes;
      return this.localStore.indexManager.updateIndexEntries(t2, i).next(() => this.rt(s, n2)).next((n3) => (C2("IndexBackiller", `Updating offset: ${n3}`), this.localStore.indexManager.updateCollectionGroup(t2, e, n3))).next(() => i.size);
    }));
  }
  rt(t2, e) {
    let n = t2;
    return e.changes.forEach((t3, e2) => {
      const s = gt(e2);
      pt(s, n) > 0 && (n = s);
    }), new yt(n.readTime, n.documentKey, Math.max(e.batchId, t2.largestBatchId));
  }
};
var Ot = class {
  constructor(t2, e) {
    this.previousValue = t2, e && (e.sequenceNumberHandler = (t3) => this.ot(t3), this.ut = (t3) => e.writeSequenceNumber(t3));
  }
  ot(t2) {
    return this.previousValue = Math.max(t2, this.previousValue), this.previousValue;
  }
  next() {
    const t2 = ++this.previousValue;
    return this.ut && this.ut(t2), t2;
  }
};
Ot.ct = -1;
function $t(t2) {
  return null == t2;
}
function Mt(t2) {
  return 0 === t2 && 1 / t2 == -1 / 0;
}
function Ft(t2) {
  return "number" == typeof t2 && Number.isInteger(t2) && !Mt(t2) && t2 <= Number.MAX_SAFE_INTEGER && t2 >= Number.MIN_SAFE_INTEGER;
}
function Bt(t2) {
  let e = "";
  for (let n = 0; n < t2.length; n++)
    e.length > 0 && (e = qt(e)), e = Lt(t2.get(n), e);
  return qt(e);
}
function Lt(t2, e) {
  let n = e;
  const s = t2.length;
  for (let e2 = 0; e2 < s; e2++) {
    const s2 = t2.charAt(e2);
    switch (s2) {
      case "\0":
        n += "";
        break;
      case "":
        n += "";
        break;
      default:
        n += s2;
    }
  }
  return n;
}
function qt(t2) {
  return t2 + "";
}
function Ut(t2) {
  const e = t2.length;
  if ($(e >= 2), 2 === e)
    return $("" === t2.charAt(0) && "" === t2.charAt(1)), rt.emptyPath();
  const __PRIVATE_lastReasonableEscapeIndex = e - 2, n = [];
  let s = "";
  for (let i = 0; i < e; ) {
    const e2 = t2.indexOf("", i);
    (e2 < 0 || e2 > __PRIVATE_lastReasonableEscapeIndex) && O2();
    switch (t2.charAt(e2 + 1)) {
      case "":
        const r = t2.substring(i, e2);
        let o;
        0 === s.length ? o = r : (s += r, o = s, s = ""), n.push(o);
        break;
      case "":
        s += t2.substring(i, e2), s += "\0";
        break;
      case "":
        s += t2.substring(i, e2 + 1);
        break;
      default:
        O2();
    }
    i = e2 + 2;
  }
  return new rt(n);
}
var Kt = ["userId", "batchId"];
function Gt(t2, e) {
  return [t2, Bt(e)];
}
function Qt(t2, e, n) {
  return [t2, Bt(e), n];
}
var zt = {};
var jt = ["prefixPath", "collectionGroup", "readTime", "documentId"];
var Wt = ["prefixPath", "collectionGroup", "documentId"];
var Ht = ["collectionGroup", "readTime", "prefixPath", "documentId"];
var Jt = ["canonicalId", "targetId"];
var Yt = ["targetId", "path"];
var Zt = ["path", "targetId"];
var Xt = ["collectionId", "parent"];
var te = ["indexId", "uid"];
var ee = ["uid", "sequenceNumber"];
var ne = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"];
var se = ["indexId", "uid", "orderedDocumentKey"];
var ie = ["userId", "collectionPath", "documentId"];
var re = ["userId", "collectionPath", "largestBatchId"];
var oe = ["userId", "collectionGroup", "largestBatchId"];
var ue = [...[...[...[...["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments"], "clientMetadata"], "remoteDocumentGlobal"], "collectionParents"], "bundles", "namedQueries"];
var ce = [...ue, "documentOverlays"];
var ae = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"];
var he = ae;
var le = [...he, "indexConfiguration", "indexState", "indexEntries"];
var fe = class extends Tt {
  constructor(t2, e) {
    super(), this.at = t2, this.currentSequenceNumber = e;
  }
};
function de(t2, e) {
  const n = F(t2);
  return vt.O(n.at, e);
}
function we(t2) {
  let e = 0;
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e++;
  return e;
}
function _e(t2, e) {
  for (const n in t2)
    Object.prototype.hasOwnProperty.call(t2, n) && e(n, t2[n]);
}
function me(t2) {
  for (const e in t2)
    if (Object.prototype.hasOwnProperty.call(t2, e))
      return false;
  return true;
}
var ge = class {
  constructor(t2, e) {
    this.comparator = t2, this.root = e || pe.EMPTY;
  }
  insert(t2, e) {
    return new ge(this.comparator, this.root.insert(t2, e, this.comparator).copy(null, null, pe.BLACK, null, null));
  }
  remove(t2) {
    return new ge(this.comparator, this.root.remove(t2, this.comparator).copy(null, null, pe.BLACK, null, null));
  }
  get(t2) {
    let e = this.root;
    for (; !e.isEmpty(); ) {
      const n = this.comparator(t2, e.key);
      if (0 === n)
        return e.value;
      n < 0 ? e = e.left : n > 0 && (e = e.right);
    }
    return null;
  }
  indexOf(t2) {
    let e = 0, n = this.root;
    for (; !n.isEmpty(); ) {
      const s = this.comparator(t2, n.key);
      if (0 === s)
        return e + n.left.size;
      s < 0 ? n = n.left : (e += n.left.size + 1, n = n.right);
    }
    return -1;
  }
  isEmpty() {
    return this.root.isEmpty();
  }
  get size() {
    return this.root.size;
  }
  minKey() {
    return this.root.minKey();
  }
  maxKey() {
    return this.root.maxKey();
  }
  inorderTraversal(t2) {
    return this.root.inorderTraversal(t2);
  }
  forEach(t2) {
    this.inorderTraversal((e, n) => (t2(e, n), false));
  }
  toString() {
    const t2 = [];
    return this.inorderTraversal((e, n) => (t2.push(`${e}:${n}`), false)), `{${t2.join(", ")}}`;
  }
  reverseTraversal(t2) {
    return this.root.reverseTraversal(t2);
  }
  getIterator() {
    return new ye(this.root, null, this.comparator, false);
  }
  getIteratorFrom(t2) {
    return new ye(this.root, t2, this.comparator, false);
  }
  getReverseIterator() {
    return new ye(this.root, null, this.comparator, true);
  }
  getReverseIteratorFrom(t2) {
    return new ye(this.root, t2, this.comparator, true);
  }
};
var ye = class {
  constructor(t2, e, n, s) {
    this.isReverse = s, this.nodeStack = [];
    let i = 1;
    for (; !t2.isEmpty(); )
      if (i = e ? n(t2.key, e) : 1, e && s && (i *= -1), i < 0)
        t2 = this.isReverse ? t2.left : t2.right;
      else {
        if (0 === i) {
          this.nodeStack.push(t2);
          break;
        }
        this.nodeStack.push(t2), t2 = this.isReverse ? t2.right : t2.left;
      }
  }
  getNext() {
    let t2 = this.nodeStack.pop();
    const e = {
      key: t2.key,
      value: t2.value
    };
    if (this.isReverse)
      for (t2 = t2.left; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.right;
    else
      for (t2 = t2.right; !t2.isEmpty(); )
        this.nodeStack.push(t2), t2 = t2.left;
    return e;
  }
  hasNext() {
    return this.nodeStack.length > 0;
  }
  peek() {
    if (0 === this.nodeStack.length)
      return null;
    const t2 = this.nodeStack[this.nodeStack.length - 1];
    return {
      key: t2.key,
      value: t2.value
    };
  }
};
var pe = class {
  constructor(t2, e, n, s, i) {
    this.key = t2, this.value = e, this.color = null != n ? n : pe.RED, this.left = null != s ? s : pe.EMPTY, this.right = null != i ? i : pe.EMPTY, this.size = this.left.size + 1 + this.right.size;
  }
  copy(t2, e, n, s, i) {
    return new pe(null != t2 ? t2 : this.key, null != e ? e : this.value, null != n ? n : this.color, null != s ? s : this.left, null != i ? i : this.right);
  }
  isEmpty() {
    return false;
  }
  inorderTraversal(t2) {
    return this.left.inorderTraversal(t2) || t2(this.key, this.value) || this.right.inorderTraversal(t2);
  }
  reverseTraversal(t2) {
    return this.right.reverseTraversal(t2) || t2(this.key, this.value) || this.left.reverseTraversal(t2);
  }
  min() {
    return this.left.isEmpty() ? this : this.left.min();
  }
  minKey() {
    return this.min().key;
  }
  maxKey() {
    return this.right.isEmpty() ? this.key : this.right.maxKey();
  }
  insert(t2, e, n) {
    let s = this;
    const i = n(t2, s.key);
    return s = i < 0 ? s.copy(null, null, null, s.left.insert(t2, e, n), null) : 0 === i ? s.copy(null, e, null, null, null) : s.copy(null, null, null, null, s.right.insert(t2, e, n)), s.fixUp();
  }
  removeMin() {
    if (this.left.isEmpty())
      return pe.EMPTY;
    let t2 = this;
    return t2.left.isRed() || t2.left.left.isRed() || (t2 = t2.moveRedLeft()), t2 = t2.copy(null, null, null, t2.left.removeMin(), null), t2.fixUp();
  }
  remove(t2, e) {
    let n, s = this;
    if (e(t2, s.key) < 0)
      s.left.isEmpty() || s.left.isRed() || s.left.left.isRed() || (s = s.moveRedLeft()), s = s.copy(null, null, null, s.left.remove(t2, e), null);
    else {
      if (s.left.isRed() && (s = s.rotateRight()), s.right.isEmpty() || s.right.isRed() || s.right.left.isRed() || (s = s.moveRedRight()), 0 === e(t2, s.key)) {
        if (s.right.isEmpty())
          return pe.EMPTY;
        n = s.right.min(), s = s.copy(n.key, n.value, null, null, s.right.removeMin());
      }
      s = s.copy(null, null, null, null, s.right.remove(t2, e));
    }
    return s.fixUp();
  }
  isRed() {
    return this.color;
  }
  fixUp() {
    let t2 = this;
    return t2.right.isRed() && !t2.left.isRed() && (t2 = t2.rotateLeft()), t2.left.isRed() && t2.left.left.isRed() && (t2 = t2.rotateRight()), t2.left.isRed() && t2.right.isRed() && (t2 = t2.colorFlip()), t2;
  }
  moveRedLeft() {
    let t2 = this.colorFlip();
    return t2.right.left.isRed() && (t2 = t2.copy(null, null, null, null, t2.right.rotateRight()), t2 = t2.rotateLeft(), t2 = t2.colorFlip()), t2;
  }
  moveRedRight() {
    let t2 = this.colorFlip();
    return t2.left.left.isRed() && (t2 = t2.rotateRight(), t2 = t2.colorFlip()), t2;
  }
  rotateLeft() {
    const t2 = this.copy(null, null, pe.RED, null, this.right.left);
    return this.right.copy(null, null, this.color, t2, null);
  }
  rotateRight() {
    const t2 = this.copy(null, null, pe.RED, this.left.right, null);
    return this.left.copy(null, null, this.color, null, t2);
  }
  colorFlip() {
    const t2 = this.left.copy(null, null, !this.left.color, null, null), e = this.right.copy(null, null, !this.right.color, null, null);
    return this.copy(null, null, !this.color, t2, e);
  }
  checkMaxDepth() {
    const t2 = this.check();
    return Math.pow(2, t2) <= this.size + 1;
  }
  check() {
    if (this.isRed() && this.left.isRed())
      throw O2();
    if (this.right.isRed())
      throw O2();
    const t2 = this.left.check();
    if (t2 !== this.right.check())
      throw O2();
    return t2 + (this.isRed() ? 0 : 1);
  }
};
pe.EMPTY = null, pe.RED = true, pe.BLACK = false;
pe.EMPTY = new class {
  constructor() {
    this.size = 0;
  }
  get key() {
    throw O2();
  }
  get value() {
    throw O2();
  }
  get color() {
    throw O2();
  }
  get left() {
    throw O2();
  }
  get right() {
    throw O2();
  }
  copy(t2, e, n, s, i) {
    return this;
  }
  insert(t2, e, n) {
    return new pe(t2, e);
  }
  remove(t2, e) {
    return this;
  }
  isEmpty() {
    return true;
  }
  inorderTraversal(t2) {
    return false;
  }
  reverseTraversal(t2) {
    return false;
  }
  minKey() {
    return null;
  }
  maxKey() {
    return null;
  }
  isRed() {
    return false;
  }
  checkMaxDepth() {
    return true;
  }
  check() {
    return 0;
  }
}();
var Ie = class {
  constructor(t2) {
    this.comparator = t2, this.data = new ge(this.comparator);
  }
  has(t2) {
    return null !== this.data.get(t2);
  }
  first() {
    return this.data.minKey();
  }
  last() {
    return this.data.maxKey();
  }
  get size() {
    return this.data.size;
  }
  indexOf(t2) {
    return this.data.indexOf(t2);
  }
  forEach(t2) {
    this.data.inorderTraversal((e, n) => (t2(e), false));
  }
  forEachInRange(t2, e) {
    const n = this.data.getIteratorFrom(t2[0]);
    for (; n.hasNext(); ) {
      const s = n.getNext();
      if (this.comparator(s.key, t2[1]) >= 0)
        return;
      e(s.key);
    }
  }
  forEachWhile(t2, e) {
    let n;
    for (n = void 0 !== e ? this.data.getIteratorFrom(e) : this.data.getIterator(); n.hasNext(); ) {
      if (!t2(n.getNext().key))
        return;
    }
  }
  firstAfterOrEqual(t2) {
    const e = this.data.getIteratorFrom(t2);
    return e.hasNext() ? e.getNext().key : null;
  }
  getIterator() {
    return new Te(this.data.getIterator());
  }
  getIteratorFrom(t2) {
    return new Te(this.data.getIteratorFrom(t2));
  }
  add(t2) {
    return this.copy(this.data.remove(t2).insert(t2, true));
  }
  delete(t2) {
    return this.has(t2) ? this.copy(this.data.remove(t2)) : this;
  }
  isEmpty() {
    return this.data.isEmpty();
  }
  unionWith(t2) {
    let e = this;
    return e.size < t2.size && (e = t2, t2 = this), t2.forEach((t3) => {
      e = e.add(t3);
    }), e;
  }
  isEqual(t2) {
    if (!(t2 instanceof Ie))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.data.getIterator(), n = t2.data.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (0 !== this.comparator(t3, s))
        return false;
    }
    return true;
  }
  toArray() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e);
    }), t2;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), "SortedSet(" + t2.toString() + ")";
  }
  copy(t2) {
    const e = new Ie(this.comparator);
    return e.data = t2, e;
  }
};
var Te = class {
  constructor(t2) {
    this.iter = t2;
  }
  getNext() {
    return this.iter.getNext().key;
  }
  hasNext() {
    return this.iter.hasNext();
  }
};
function Ee(t2) {
  return t2.hasNext() ? t2.getNext() : void 0;
}
var Ae = class {
  constructor(t2) {
    this.fields = t2, t2.sort(ut.comparator);
  }
  static empty() {
    return new Ae([]);
  }
  unionWith(t2) {
    let e = new Ie(ut.comparator);
    for (const t3 of this.fields)
      e = e.add(t3);
    for (const n of t2)
      e = e.add(n);
    return new Ae(e.toArray());
  }
  covers(t2) {
    for (const e of this.fields)
      if (e.isPrefixOf(t2))
        return true;
    return false;
  }
  isEqual(t2) {
    return tt(this.fields, t2.fields, (t3, e) => t3.isEqual(e));
  }
};
var Re = class extends Error {
  constructor() {
    super(...arguments), this.name = "Base64DecodeError";
  }
};
function ve() {
  return "undefined" != typeof atob;
}
var be = class {
  constructor(t2) {
    this.binaryString = t2;
  }
  static fromBase64String(t2) {
    const e = function(t3) {
      try {
        return atob(t3);
      } catch (t4) {
        throw "undefined" != typeof DOMException && t4 instanceof DOMException ? new Re("Invalid base64 string: " + t4) : t4;
      }
    }(t2);
    return new be(e);
  }
  static fromUint8Array(t2) {
    const e = function(t3) {
      let e2 = "";
      for (let n = 0; n < t3.length; ++n)
        e2 += String.fromCharCode(t3[n]);
      return e2;
    }(t2);
    return new be(e);
  }
  [Symbol.iterator]() {
    let t2 = 0;
    return {
      next: () => t2 < this.binaryString.length ? {
        value: this.binaryString.charCodeAt(t2++),
        done: false
      } : {
        value: void 0,
        done: true
      }
    };
  }
  toBase64() {
    return t2 = this.binaryString, btoa(t2);
    var t2;
  }
  toUint8Array() {
    return function(t2) {
      const e = new Uint8Array(t2.length);
      for (let n = 0; n < t2.length; n++)
        e[n] = t2.charCodeAt(n);
      return e;
    }(this.binaryString);
  }
  approximateByteSize() {
    return 2 * this.binaryString.length;
  }
  compareTo(t2) {
    return X2(this.binaryString, t2.binaryString);
  }
  isEqual(t2) {
    return this.binaryString === t2.binaryString;
  }
};
be.EMPTY_BYTE_STRING = new be("");
var Pe = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/);
function Ve(t2) {
  if ($(!!t2), "string" == typeof t2) {
    let e = 0;
    const n = Pe.exec(t2);
    if ($(!!n), n[1]) {
      let t3 = n[1];
      t3 = (t3 + "000000000").substr(0, 9), e = Number(t3);
    }
    const s = new Date(t2);
    return {
      seconds: Math.floor(s.getTime() / 1e3),
      nanos: e
    };
  }
  return {
    seconds: Se(t2.seconds),
    nanos: Se(t2.nanos)
  };
}
function Se(t2) {
  return "number" == typeof t2 ? t2 : "string" == typeof t2 ? Number(t2) : 0;
}
function De(t2) {
  return "string" == typeof t2 ? be.fromBase64String(t2) : be.fromUint8Array(t2);
}
function Ce(t2) {
  var e, n;
  return "server_timestamp" === (null === (n = ((null === (e = null == t2 ? void 0 : t2.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === n ? void 0 : n.stringValue);
}
function xe(t2) {
  const e = t2.mapValue.fields.__previous_value__;
  return Ce(e) ? xe(e) : e;
}
function Ne(t2) {
  const e = Ve(t2.mapValue.fields.__local_write_time__.timestampValue);
  return new nt(e.seconds, e.nanos);
}
var ke = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.databaseId = t2, this.appId = e, this.persistenceKey = n, this.host = s, this.ssl = i, this.forceLongPolling = r, this.autoDetectLongPolling = o, this.useFetchStreams = u;
  }
};
var Oe = class {
  constructor(t2, e) {
    this.projectId = t2, this.database = e || "(default)";
  }
  static empty() {
    return new Oe("", "");
  }
  get isDefaultDatabase() {
    return "(default)" === this.database;
  }
  isEqual(t2) {
    return t2 instanceof Oe && t2.projectId === this.projectId && t2.database === this.database;
  }
};
var $e = {
  mapValue: {
    fields: {
      __type__: {
        stringValue: "__max__"
      }
    }
  }
};
var Me = {
  nullValue: "NULL_VALUE"
};
function Fe(t2) {
  return "nullValue" in t2 ? 0 : "booleanValue" in t2 ? 1 : "integerValue" in t2 || "doubleValue" in t2 ? 2 : "timestampValue" in t2 ? 3 : "stringValue" in t2 ? 5 : "bytesValue" in t2 ? 6 : "referenceValue" in t2 ? 7 : "geoPointValue" in t2 ? 8 : "arrayValue" in t2 ? 9 : "mapValue" in t2 ? Ce(t2) ? 4 : Ze(t2) ? 9007199254740991 : 10 : O2();
}
function Be(t2, e) {
  if (t2 === e)
    return true;
  const n = Fe(t2);
  if (n !== Fe(e))
    return false;
  switch (n) {
    case 0:
    case 9007199254740991:
      return true;
    case 1:
      return t2.booleanValue === e.booleanValue;
    case 4:
      return Ne(t2).isEqual(Ne(e));
    case 3:
      return function(t3, e2) {
        if ("string" == typeof t3.timestampValue && "string" == typeof e2.timestampValue && t3.timestampValue.length === e2.timestampValue.length)
          return t3.timestampValue === e2.timestampValue;
        const n2 = Ve(t3.timestampValue), s = Ve(e2.timestampValue);
        return n2.seconds === s.seconds && n2.nanos === s.nanos;
      }(t2, e);
    case 5:
      return t2.stringValue === e.stringValue;
    case 6:
      return function(t3, e2) {
        return De(t3.bytesValue).isEqual(De(e2.bytesValue));
      }(t2, e);
    case 7:
      return t2.referenceValue === e.referenceValue;
    case 8:
      return function(t3, e2) {
        return Se(t3.geoPointValue.latitude) === Se(e2.geoPointValue.latitude) && Se(t3.geoPointValue.longitude) === Se(e2.geoPointValue.longitude);
      }(t2, e);
    case 2:
      return function(t3, e2) {
        if ("integerValue" in t3 && "integerValue" in e2)
          return Se(t3.integerValue) === Se(e2.integerValue);
        if ("doubleValue" in t3 && "doubleValue" in e2) {
          const n2 = Se(t3.doubleValue), s = Se(e2.doubleValue);
          return n2 === s ? Mt(n2) === Mt(s) : isNaN(n2) && isNaN(s);
        }
        return false;
      }(t2, e);
    case 9:
      return tt(t2.arrayValue.values || [], e.arrayValue.values || [], Be);
    case 10:
      return function(t3, e2) {
        const n2 = t3.mapValue.fields || {}, s = e2.mapValue.fields || {};
        if (we(n2) !== we(s))
          return false;
        for (const t4 in n2)
          if (n2.hasOwnProperty(t4) && (void 0 === s[t4] || !Be(n2[t4], s[t4])))
            return false;
        return true;
      }(t2, e);
    default:
      return O2();
  }
}
function Le(t2, e) {
  return void 0 !== (t2.values || []).find((t3) => Be(t3, e));
}
function qe(t2, e) {
  if (t2 === e)
    return 0;
  const n = Fe(t2), s = Fe(e);
  if (n !== s)
    return X2(n, s);
  switch (n) {
    case 0:
    case 9007199254740991:
      return 0;
    case 1:
      return X2(t2.booleanValue, e.booleanValue);
    case 2:
      return function(t3, e2) {
        const n2 = Se(t3.integerValue || t3.doubleValue), s2 = Se(e2.integerValue || e2.doubleValue);
        return n2 < s2 ? -1 : n2 > s2 ? 1 : n2 === s2 ? 0 : isNaN(n2) ? isNaN(s2) ? 0 : -1 : 1;
      }(t2, e);
    case 3:
      return Ue(t2.timestampValue, e.timestampValue);
    case 4:
      return Ue(Ne(t2), Ne(e));
    case 5:
      return X2(t2.stringValue, e.stringValue);
    case 6:
      return function(t3, e2) {
        const n2 = De(t3), s2 = De(e2);
        return n2.compareTo(s2);
      }(t2.bytesValue, e.bytesValue);
    case 7:
      return function(t3, e2) {
        const n2 = t3.split("/"), s2 = e2.split("/");
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; t4++) {
          const e3 = X2(n2[t4], s2[t4]);
          if (0 !== e3)
            return e3;
        }
        return X2(n2.length, s2.length);
      }(t2.referenceValue, e.referenceValue);
    case 8:
      return function(t3, e2) {
        const n2 = X2(Se(t3.latitude), Se(e2.latitude));
        if (0 !== n2)
          return n2;
        return X2(Se(t3.longitude), Se(e2.longitude));
      }(t2.geoPointValue, e.geoPointValue);
    case 9:
      return function(t3, e2) {
        const n2 = t3.values || [], s2 = e2.values || [];
        for (let t4 = 0; t4 < n2.length && t4 < s2.length; ++t4) {
          const e3 = qe(n2[t4], s2[t4]);
          if (e3)
            return e3;
        }
        return X2(n2.length, s2.length);
      }(t2.arrayValue, e.arrayValue);
    case 10:
      return function(t3, e2) {
        if (t3 === $e.mapValue && e2 === $e.mapValue)
          return 0;
        if (t3 === $e.mapValue)
          return 1;
        if (e2 === $e.mapValue)
          return -1;
        const n2 = t3.fields || {}, s2 = Object.keys(n2), i = e2.fields || {}, r = Object.keys(i);
        s2.sort(), r.sort();
        for (let t4 = 0; t4 < s2.length && t4 < r.length; ++t4) {
          const e3 = X2(s2[t4], r[t4]);
          if (0 !== e3)
            return e3;
          const o = qe(n2[s2[t4]], i[r[t4]]);
          if (0 !== o)
            return o;
        }
        return X2(s2.length, r.length);
      }(t2.mapValue, e.mapValue);
    default:
      throw O2();
  }
}
function Ue(t2, e) {
  if ("string" == typeof t2 && "string" == typeof e && t2.length === e.length)
    return X2(t2, e);
  const n = Ve(t2), s = Ve(e), i = X2(n.seconds, s.seconds);
  return 0 !== i ? i : X2(n.nanos, s.nanos);
}
function Ke(t2) {
  return Ge(t2);
}
function Ge(t2) {
  return "nullValue" in t2 ? "null" : "booleanValue" in t2 ? "" + t2.booleanValue : "integerValue" in t2 ? "" + t2.integerValue : "doubleValue" in t2 ? "" + t2.doubleValue : "timestampValue" in t2 ? function(t3) {
    const e2 = Ve(t3);
    return `time(${e2.seconds},${e2.nanos})`;
  }(t2.timestampValue) : "stringValue" in t2 ? t2.stringValue : "bytesValue" in t2 ? De(t2.bytesValue).toBase64() : "referenceValue" in t2 ? (n = t2.referenceValue, ct.fromName(n).toString()) : "geoPointValue" in t2 ? `geo(${(e = t2.geoPointValue).latitude},${e.longitude})` : "arrayValue" in t2 ? function(t3) {
    let e2 = "[", n2 = true;
    for (const s of t3.values || [])
      n2 ? n2 = false : e2 += ",", e2 += Ge(s);
    return e2 + "]";
  }(t2.arrayValue) : "mapValue" in t2 ? function(t3) {
    const e2 = Object.keys(t3.fields || {}).sort();
    let n2 = "{", s = true;
    for (const i of e2)
      s ? s = false : n2 += ",", n2 += `${i}:${Ge(t3.fields[i])}`;
    return n2 + "}";
  }(t2.mapValue) : O2();
  var e, n;
}
function Qe(t2, e) {
  return {
    referenceValue: `projects/${t2.projectId}/databases/${t2.database}/documents/${e.path.canonicalString()}`
  };
}
function ze(t2) {
  return !!t2 && "integerValue" in t2;
}
function je(t2) {
  return !!t2 && "arrayValue" in t2;
}
function We(t2) {
  return !!t2 && "nullValue" in t2;
}
function He(t2) {
  return !!t2 && "doubleValue" in t2 && isNaN(Number(t2.doubleValue));
}
function Je(t2) {
  return !!t2 && "mapValue" in t2;
}
function Ye(t2) {
  if (t2.geoPointValue)
    return {
      geoPointValue: Object.assign({}, t2.geoPointValue)
    };
  if (t2.timestampValue && "object" == typeof t2.timestampValue)
    return {
      timestampValue: Object.assign({}, t2.timestampValue)
    };
  if (t2.mapValue) {
    const e = {
      mapValue: {
        fields: {}
      }
    };
    return _e(t2.mapValue.fields, (t3, n) => e.mapValue.fields[t3] = Ye(n)), e;
  }
  if (t2.arrayValue) {
    const e = {
      arrayValue: {
        values: []
      }
    };
    for (let n = 0; n < (t2.arrayValue.values || []).length; ++n)
      e.arrayValue.values[n] = Ye(t2.arrayValue.values[n]);
    return e;
  }
  return Object.assign({}, t2);
}
function Ze(t2) {
  return "__max__" === (((t2.mapValue || {}).fields || {}).__type__ || {}).stringValue;
}
function Xe(t2) {
  return "nullValue" in t2 ? Me : "booleanValue" in t2 ? {
    booleanValue: false
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    doubleValue: NaN
  } : "timestampValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "stringValue" in t2 ? {
    stringValue: ""
  } : "bytesValue" in t2 ? {
    bytesValue: ""
  } : "referenceValue" in t2 ? Qe(Oe.empty(), ct.empty()) : "geoPointValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "arrayValue" in t2 ? {
    arrayValue: {}
  } : "mapValue" in t2 ? {
    mapValue: {}
  } : O2();
}
function tn(t2) {
  return "nullValue" in t2 ? {
    booleanValue: false
  } : "booleanValue" in t2 ? {
    doubleValue: NaN
  } : "integerValue" in t2 || "doubleValue" in t2 ? {
    timestampValue: {
      seconds: Number.MIN_SAFE_INTEGER
    }
  } : "timestampValue" in t2 ? {
    stringValue: ""
  } : "stringValue" in t2 ? {
    bytesValue: ""
  } : "bytesValue" in t2 ? Qe(Oe.empty(), ct.empty()) : "referenceValue" in t2 ? {
    geoPointValue: {
      latitude: -90,
      longitude: -180
    }
  } : "geoPointValue" in t2 ? {
    arrayValue: {}
  } : "arrayValue" in t2 ? {
    mapValue: {}
  } : "mapValue" in t2 ? $e : O2();
}
function en(t2, e) {
  const n = qe(t2.value, e.value);
  return 0 !== n ? n : t2.inclusive && !e.inclusive ? -1 : !t2.inclusive && e.inclusive ? 1 : 0;
}
function nn(t2, e) {
  const n = qe(t2.value, e.value);
  return 0 !== n ? n : t2.inclusive && !e.inclusive ? 1 : !t2.inclusive && e.inclusive ? -1 : 0;
}
var sn = class {
  constructor(t2) {
    this.value = t2;
  }
  static empty() {
    return new sn({
      mapValue: {}
    });
  }
  field(t2) {
    if (t2.isEmpty())
      return this.value;
    {
      let e = this.value;
      for (let n = 0; n < t2.length - 1; ++n)
        if (e = (e.mapValue.fields || {})[t2.get(n)], !Je(e))
          return null;
      return e = (e.mapValue.fields || {})[t2.lastSegment()], e || null;
    }
  }
  set(t2, e) {
    this.getFieldsMap(t2.popLast())[t2.lastSegment()] = Ye(e);
  }
  setAll(t2) {
    let e = ut.emptyPath(), n = {}, s = [];
    t2.forEach((t3, i2) => {
      if (!e.isImmediateParentOf(i2)) {
        const t4 = this.getFieldsMap(e);
        this.applyChanges(t4, n, s), n = {}, s = [], e = i2.popLast();
      }
      t3 ? n[i2.lastSegment()] = Ye(t3) : s.push(i2.lastSegment());
    });
    const i = this.getFieldsMap(e);
    this.applyChanges(i, n, s);
  }
  delete(t2) {
    const e = this.field(t2.popLast());
    Je(e) && e.mapValue.fields && delete e.mapValue.fields[t2.lastSegment()];
  }
  isEqual(t2) {
    return Be(this.value, t2.value);
  }
  getFieldsMap(t2) {
    let e = this.value;
    e.mapValue.fields || (e.mapValue = {
      fields: {}
    });
    for (let n = 0; n < t2.length; ++n) {
      let s = e.mapValue.fields[t2.get(n)];
      Je(s) && s.mapValue.fields || (s = {
        mapValue: {
          fields: {}
        }
      }, e.mapValue.fields[t2.get(n)] = s), e = s;
    }
    return e.mapValue.fields;
  }
  applyChanges(t2, e, n) {
    _e(e, (e2, n2) => t2[e2] = n2);
    for (const e2 of n)
      delete t2[e2];
  }
  clone() {
    return new sn(Ye(this.value));
  }
};
function rn(t2) {
  const e = [];
  return _e(t2.fields, (t3, n) => {
    const s = new ut([t3]);
    if (Je(n)) {
      const t4 = rn(n.mapValue).fields;
      if (0 === t4.length)
        e.push(s);
      else
        for (const n2 of t4)
          e.push(s.child(n2));
    } else
      e.push(s);
  }), new Ae(e);
}
var on = class {
  constructor(t2, e, n, s, i, r, o) {
    this.key = t2, this.documentType = e, this.version = n, this.readTime = s, this.createTime = i, this.data = r, this.documentState = o;
  }
  static newInvalidDocument(t2) {
    return new on(
      t2,
      0,
      st.min(),
      st.min(),
      st.min(),
      sn.empty(),
      0
    );
  }
  static newFoundDocument(t2, e, n, s) {
    return new on(
      t2,
      1,
      e,
      st.min(),
      n,
      s,
      0
    );
  }
  static newNoDocument(t2, e) {
    return new on(
      t2,
      2,
      e,
      st.min(),
      st.min(),
      sn.empty(),
      0
    );
  }
  static newUnknownDocument(t2, e) {
    return new on(
      t2,
      3,
      e,
      st.min(),
      st.min(),
      sn.empty(),
      2
    );
  }
  convertToFoundDocument(t2, e) {
    return !this.createTime.isEqual(st.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = t2), this.version = t2, this.documentType = 1, this.data = e, this.documentState = 0, this;
  }
  convertToNoDocument(t2) {
    return this.version = t2, this.documentType = 2, this.data = sn.empty(), this.documentState = 0, this;
  }
  convertToUnknownDocument(t2) {
    return this.version = t2, this.documentType = 3, this.data = sn.empty(), this.documentState = 2, this;
  }
  setHasCommittedMutations() {
    return this.documentState = 2, this;
  }
  setHasLocalMutations() {
    return this.documentState = 1, this.version = st.min(), this;
  }
  setReadTime(t2) {
    return this.readTime = t2, this;
  }
  get hasLocalMutations() {
    return 1 === this.documentState;
  }
  get hasCommittedMutations() {
    return 2 === this.documentState;
  }
  get hasPendingWrites() {
    return this.hasLocalMutations || this.hasCommittedMutations;
  }
  isValidDocument() {
    return 0 !== this.documentType;
  }
  isFoundDocument() {
    return 1 === this.documentType;
  }
  isNoDocument() {
    return 2 === this.documentType;
  }
  isUnknownDocument() {
    return 3 === this.documentType;
  }
  isEqual(t2) {
    return t2 instanceof on && this.key.isEqual(t2.key) && this.version.isEqual(t2.version) && this.documentType === t2.documentType && this.documentState === t2.documentState && this.data.isEqual(t2.data);
  }
  mutableCopy() {
    return new on(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState);
  }
  toString() {
    return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})`;
  }
};
var un = class {
  constructor(t2, e) {
    this.position = t2, this.inclusive = e;
  }
};
function cn(t2, e, n) {
  let s = 0;
  for (let i = 0; i < t2.position.length; i++) {
    const r = e[i], o = t2.position[i];
    if (r.field.isKeyField())
      s = ct.comparator(ct.fromName(o.referenceValue), n.key);
    else {
      s = qe(o, n.data.field(r.field));
    }
    if ("desc" === r.dir && (s *= -1), 0 !== s)
      break;
  }
  return s;
}
function an(t2, e) {
  if (null === t2)
    return null === e;
  if (null === e)
    return false;
  if (t2.inclusive !== e.inclusive || t2.position.length !== e.position.length)
    return false;
  for (let n = 0; n < t2.position.length; n++) {
    if (!Be(t2.position[n], e.position[n]))
      return false;
  }
  return true;
}
var hn = class {
  constructor(t2, e = "asc") {
    this.field = t2, this.dir = e;
  }
};
function ln(t2, e) {
  return t2.dir === e.dir && t2.field.isEqual(e.field);
}
var fn = class {
};
var dn = class extends fn {
  constructor(t2, e, n) {
    super(), this.field = t2, this.op = e, this.value = n;
  }
  static create(t2, e, n) {
    return t2.isKeyField() ? "in" === e || "not-in" === e ? this.createKeyFieldInFilter(t2, e, n) : new An(t2, e, n) : "array-contains" === e ? new Pn(t2, n) : "in" === e ? new Vn(t2, n) : "not-in" === e ? new Sn(t2, n) : "array-contains-any" === e ? new Dn(t2, n) : new dn(t2, e, n);
  }
  static createKeyFieldInFilter(t2, e, n) {
    return "in" === e ? new Rn(t2, n) : new vn(t2, n);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return "!=" === this.op ? null !== e && this.matchesComparison(qe(e, this.value)) : null !== e && Fe(this.value) === Fe(e) && this.matchesComparison(qe(e, this.value));
  }
  matchesComparison(t2) {
    switch (this.op) {
      case "<":
        return t2 < 0;
      case "<=":
        return t2 <= 0;
      case "==":
        return 0 === t2;
      case "!=":
        return 0 !== t2;
      case ">":
        return t2 > 0;
      case ">=":
        return t2 >= 0;
      default:
        return O2();
    }
  }
  isInequality() {
    return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0;
  }
  getFlattenedFilters() {
    return [this];
  }
  getFilters() {
    return [this];
  }
  getFirstInequalityField() {
    return this.isInequality() ? this.field : null;
  }
};
var wn = class extends fn {
  constructor(t2, e) {
    super(), this.filters = t2, this.op = e, this.ht = null;
  }
  static create(t2, e) {
    return new wn(t2, e);
  }
  matches(t2) {
    return _n(this) ? void 0 === this.filters.find((e) => !e.matches(t2)) : void 0 !== this.filters.find((e) => e.matches(t2));
  }
  getFlattenedFilters() {
    return null !== this.ht || (this.ht = this.filters.reduce((t2, e) => t2.concat(e.getFlattenedFilters()), [])), this.ht;
  }
  getFilters() {
    return Object.assign([], this.filters);
  }
  getFirstInequalityField() {
    const t2 = this.lt((t3) => t3.isInequality());
    return null !== t2 ? t2.field : null;
  }
  lt(t2) {
    for (const e of this.getFlattenedFilters())
      if (t2(e))
        return e;
    return null;
  }
};
function _n(t2) {
  return "and" === t2.op;
}
function mn(t2) {
  return "or" === t2.op;
}
function gn(t2) {
  return yn(t2) && _n(t2);
}
function yn(t2) {
  for (const e of t2.filters)
    if (e instanceof wn)
      return false;
  return true;
}
function pn(t2) {
  if (t2 instanceof dn)
    return t2.field.canonicalString() + t2.op.toString() + Ke(t2.value);
  if (gn(t2))
    return t2.filters.map((t3) => pn(t3)).join(",");
  {
    const e = t2.filters.map((t3) => pn(t3)).join(",");
    return `${t2.op}(${e})`;
  }
}
function In(t2, e) {
  return t2 instanceof dn ? function(t3, e2) {
    return e2 instanceof dn && t3.op === e2.op && t3.field.isEqual(e2.field) && Be(t3.value, e2.value);
  }(t2, e) : t2 instanceof wn ? function(t3, e2) {
    if (e2 instanceof wn && t3.op === e2.op && t3.filters.length === e2.filters.length) {
      return t3.filters.reduce((t4, n, s) => t4 && In(n, e2.filters[s]), true);
    }
    return false;
  }(t2, e) : void O2();
}
function Tn(t2, e) {
  const n = t2.filters.concat(e);
  return wn.create(n, t2.op);
}
function En(t2) {
  return t2 instanceof dn ? function(t3) {
    return `${t3.field.canonicalString()} ${t3.op} ${Ke(t3.value)}`;
  }(t2) : t2 instanceof wn ? function(t3) {
    return t3.op.toString() + " {" + t3.getFilters().map(En).join(" ,") + "}";
  }(t2) : "Filter";
}
var An = class extends dn {
  constructor(t2, e, n) {
    super(t2, e, n), this.key = ct.fromName(n.referenceValue);
  }
  matches(t2) {
    const e = ct.comparator(t2.key, this.key);
    return this.matchesComparison(e);
  }
};
var Rn = class extends dn {
  constructor(t2, e) {
    super(t2, "in", e), this.keys = bn("in", e);
  }
  matches(t2) {
    return this.keys.some((e) => e.isEqual(t2.key));
  }
};
var vn = class extends dn {
  constructor(t2, e) {
    super(t2, "not-in", e), this.keys = bn("not-in", e);
  }
  matches(t2) {
    return !this.keys.some((e) => e.isEqual(t2.key));
  }
};
function bn(t2, e) {
  var n;
  return ((null === (n = e.arrayValue) || void 0 === n ? void 0 : n.values) || []).map((t3) => ct.fromName(t3.referenceValue));
}
var Pn = class extends dn {
  constructor(t2, e) {
    super(t2, "array-contains", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return je(e) && Le(e.arrayValue, this.value);
  }
};
var Vn = class extends dn {
  constructor(t2, e) {
    super(t2, "in", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return null !== e && Le(this.value.arrayValue, e);
  }
};
var Sn = class extends dn {
  constructor(t2, e) {
    super(t2, "not-in", e);
  }
  matches(t2) {
    if (Le(this.value.arrayValue, {
      nullValue: "NULL_VALUE"
    }))
      return false;
    const e = t2.data.field(this.field);
    return null !== e && !Le(this.value.arrayValue, e);
  }
};
var Dn = class extends dn {
  constructor(t2, e) {
    super(t2, "array-contains-any", e);
  }
  matches(t2) {
    const e = t2.data.field(this.field);
    return !(!je(e) || !e.arrayValue.values) && e.arrayValue.values.some((t3) => Le(this.value.arrayValue, t3));
  }
};
var Cn = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
    this.path = t2, this.collectionGroup = e, this.orderBy = n, this.filters = s, this.limit = i, this.startAt = r, this.endAt = o, this.ft = null;
  }
};
function xn(t2, e = null, n = [], s = [], i = null, r = null, o = null) {
  return new Cn(t2, e, n, s, i, r, o);
}
function Nn(t2) {
  const e = F(t2);
  if (null === e.ft) {
    let t3 = e.path.canonicalString();
    null !== e.collectionGroup && (t3 += "|cg:" + e.collectionGroup), t3 += "|f:", t3 += e.filters.map((t4) => pn(t4)).join(","), t3 += "|ob:", t3 += e.orderBy.map((t4) => function(t5) {
      return t5.field.canonicalString() + t5.dir;
    }(t4)).join(","), $t(e.limit) || (t3 += "|l:", t3 += e.limit), e.startAt && (t3 += "|lb:", t3 += e.startAt.inclusive ? "b:" : "a:", t3 += e.startAt.position.map((t4) => Ke(t4)).join(",")), e.endAt && (t3 += "|ub:", t3 += e.endAt.inclusive ? "a:" : "b:", t3 += e.endAt.position.map((t4) => Ke(t4)).join(",")), e.ft = t3;
  }
  return e.ft;
}
function kn(t2, e) {
  if (t2.limit !== e.limit)
    return false;
  if (t2.orderBy.length !== e.orderBy.length)
    return false;
  for (let n = 0; n < t2.orderBy.length; n++)
    if (!ln(t2.orderBy[n], e.orderBy[n]))
      return false;
  if (t2.filters.length !== e.filters.length)
    return false;
  for (let n = 0; n < t2.filters.length; n++)
    if (!In(t2.filters[n], e.filters[n]))
      return false;
  return t2.collectionGroup === e.collectionGroup && (!!t2.path.isEqual(e.path) && (!!an(t2.startAt, e.startAt) && an(t2.endAt, e.endAt)));
}
function On(t2) {
  return ct.isDocumentKey(t2.path) && null === t2.collectionGroup && 0 === t2.filters.length;
}
function $n(t2, e) {
  return t2.filters.filter((t3) => t3 instanceof dn && t3.field.isEqual(e));
}
function Mn(t2, e, n) {
  let s = Me, i = true;
  for (const n2 of $n(t2, e)) {
    let t3 = Me, e2 = true;
    switch (n2.op) {
      case "<":
      case "<=":
        t3 = Xe(n2.value);
        break;
      case "==":
      case "in":
      case ">=":
        t3 = n2.value;
        break;
      case ">":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = Me;
    }
    en({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) < 0 && (s = t3, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        en({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) < 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
function Fn(t2, e, n) {
  let s = $e, i = true;
  for (const n2 of $n(t2, e)) {
    let t3 = $e, e2 = true;
    switch (n2.op) {
      case ">=":
      case ">":
        t3 = tn(n2.value), e2 = false;
        break;
      case "==":
      case "in":
      case "<=":
        t3 = n2.value;
        break;
      case "<":
        t3 = n2.value, e2 = false;
        break;
      case "!=":
      case "not-in":
        t3 = $e;
    }
    nn({
      value: s,
      inclusive: i
    }, {
      value: t3,
      inclusive: e2
    }) > 0 && (s = t3, i = e2);
  }
  if (null !== n)
    for (let r = 0; r < t2.orderBy.length; ++r) {
      if (t2.orderBy[r].field.isEqual(e)) {
        const t3 = n.position[r];
        nn({
          value: s,
          inclusive: i
        }, {
          value: t3,
          inclusive: n.inclusive
        }) > 0 && (s = t3, i = n.inclusive);
        break;
      }
    }
  return {
    value: s,
    inclusive: i
  };
}
var Bn = class {
  constructor(t2, e = null, n = [], s = [], i = null, r = "F", o = null, u = null) {
    this.path = t2, this.collectionGroup = e, this.explicitOrderBy = n, this.filters = s, this.limit = i, this.limitType = r, this.startAt = o, this.endAt = u, this.dt = null, this.wt = null, this.startAt, this.endAt;
  }
};
function Ln(t2, e, n, s, i, r, o, u) {
  return new Bn(t2, e, n, s, i, r, o, u);
}
function qn(t2) {
  return new Bn(t2);
}
function Un(t2) {
  return 0 === t2.filters.length && null === t2.limit && null == t2.startAt && null == t2.endAt && (0 === t2.explicitOrderBy.length || 1 === t2.explicitOrderBy.length && t2.explicitOrderBy[0].field.isKeyField());
}
function Kn(t2) {
  return t2.explicitOrderBy.length > 0 ? t2.explicitOrderBy[0].field : null;
}
function Gn(t2) {
  for (const e of t2.filters) {
    const t3 = e.getFirstInequalityField();
    if (null !== t3)
      return t3;
  }
  return null;
}
function Qn(t2) {
  return null !== t2.collectionGroup;
}
function zn(t2) {
  const e = F(t2);
  if (null === e.dt) {
    e.dt = [];
    const t3 = Gn(e), n = Kn(e);
    if (null !== t3 && null === n)
      t3.isKeyField() || e.dt.push(new hn(t3)), e.dt.push(new hn(ut.keyField(), "asc"));
    else {
      let t4 = false;
      for (const n2 of e.explicitOrderBy)
        e.dt.push(n2), n2.field.isKeyField() && (t4 = true);
      if (!t4) {
        const t5 = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc";
        e.dt.push(new hn(ut.keyField(), t5));
      }
    }
  }
  return e.dt;
}
function jn(t2) {
  const e = F(t2);
  if (!e.wt)
    if ("F" === e.limitType)
      e.wt = xn(e.path, e.collectionGroup, zn(e), e.filters, e.limit, e.startAt, e.endAt);
    else {
      const t3 = [];
      for (const n2 of zn(e)) {
        const e2 = "desc" === n2.dir ? "asc" : "desc";
        t3.push(new hn(n2.field, e2));
      }
      const n = e.endAt ? new un(e.endAt.position, e.endAt.inclusive) : null, s = e.startAt ? new un(e.startAt.position, e.startAt.inclusive) : null;
      e.wt = xn(e.path, e.collectionGroup, t3, e.filters, e.limit, n, s);
    }
  return e.wt;
}
function Wn(t2, e) {
  e.getFirstInequalityField(), Gn(t2);
  const n = t2.filters.concat([e]);
  return new Bn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), n, t2.limit, t2.limitType, t2.startAt, t2.endAt);
}
function Hn(t2, e, n) {
  return new Bn(t2.path, t2.collectionGroup, t2.explicitOrderBy.slice(), t2.filters.slice(), e, n, t2.startAt, t2.endAt);
}
function Jn(t2, e) {
  return kn(jn(t2), jn(e)) && t2.limitType === e.limitType;
}
function Yn(t2) {
  return `${Nn(jn(t2))}|lt:${t2.limitType}`;
}
function Zn(t2) {
  return `Query(target=${function(t3) {
    let e = t3.path.canonicalString();
    return null !== t3.collectionGroup && (e += " collectionGroup=" + t3.collectionGroup), t3.filters.length > 0 && (e += `, filters: [${t3.filters.map((t4) => En(t4)).join(", ")}]`), $t(t3.limit) || (e += ", limit: " + t3.limit), t3.orderBy.length > 0 && (e += `, orderBy: [${t3.orderBy.map((t4) => function(t5) {
      return `${t5.field.canonicalString()} (${t5.dir})`;
    }(t4)).join(", ")}]`), t3.startAt && (e += ", startAt: ", e += t3.startAt.inclusive ? "b:" : "a:", e += t3.startAt.position.map((t4) => Ke(t4)).join(",")), t3.endAt && (e += ", endAt: ", e += t3.endAt.inclusive ? "a:" : "b:", e += t3.endAt.position.map((t4) => Ke(t4)).join(",")), `Target(${e})`;
  }(jn(t2))}; limitType=${t2.limitType})`;
}
function Xn(t2, e) {
  return e.isFoundDocument() && function(t3, e2) {
    const n = e2.key.path;
    return null !== t3.collectionGroup ? e2.key.hasCollectionId(t3.collectionGroup) && t3.path.isPrefixOf(n) : ct.isDocumentKey(t3.path) ? t3.path.isEqual(n) : t3.path.isImmediateParentOf(n);
  }(t2, e) && function(t3, e2) {
    for (const n of zn(t3))
      if (!n.field.isKeyField() && null === e2.data.field(n.field))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    for (const n of t3.filters)
      if (!n.matches(e2))
        return false;
    return true;
  }(t2, e) && function(t3, e2) {
    if (t3.startAt && !function(t4, e3, n) {
      const s = cn(t4, e3, n);
      return t4.inclusive ? s <= 0 : s < 0;
    }(t3.startAt, zn(t3), e2))
      return false;
    if (t3.endAt && !function(t4, e3, n) {
      const s = cn(t4, e3, n);
      return t4.inclusive ? s >= 0 : s > 0;
    }(t3.endAt, zn(t3), e2))
      return false;
    return true;
  }(t2, e);
}
function ts(t2) {
  return t2.collectionGroup || (t2.path.length % 2 == 1 ? t2.path.lastSegment() : t2.path.get(t2.path.length - 2));
}
function es(t2) {
  return (e, n) => {
    let s = false;
    for (const i of zn(t2)) {
      const t3 = ns(i, e, n);
      if (0 !== t3)
        return t3;
      s = s || i.field.isKeyField();
    }
    return 0;
  };
}
function ns(t2, e, n) {
  const s = t2.field.isKeyField() ? ct.comparator(e.key, n.key) : function(t3, e2, n2) {
    const s2 = e2.data.field(t3), i = n2.data.field(t3);
    return null !== s2 && null !== i ? qe(s2, i) : O2();
  }(t2.field, e, n);
  switch (t2.dir) {
    case "asc":
      return s;
    case "desc":
      return -1 * s;
    default:
      return O2();
  }
}
var ss = class {
  constructor(t2, e) {
    this.mapKeyFn = t2, this.equalsFn = e, this.inner = {}, this.innerSize = 0;
  }
  get(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (void 0 !== n) {
      for (const [e2, s] of n)
        if (this.equalsFn(e2, t2))
          return s;
    }
  }
  has(t2) {
    return void 0 !== this.get(t2);
  }
  set(t2, e) {
    const n = this.mapKeyFn(t2), s = this.inner[n];
    if (void 0 === s)
      return this.inner[n] = [[t2, e]], void this.innerSize++;
    for (let n2 = 0; n2 < s.length; n2++)
      if (this.equalsFn(s[n2][0], t2))
        return void (s[n2] = [t2, e]);
    s.push([t2, e]), this.innerSize++;
  }
  delete(t2) {
    const e = this.mapKeyFn(t2), n = this.inner[e];
    if (void 0 === n)
      return false;
    for (let s = 0; s < n.length; s++)
      if (this.equalsFn(n[s][0], t2))
        return 1 === n.length ? delete this.inner[e] : n.splice(s, 1), this.innerSize--, true;
    return false;
  }
  forEach(t2) {
    _e(this.inner, (e, n) => {
      for (const [e2, s] of n)
        t2(e2, s);
    });
  }
  isEmpty() {
    return me(this.inner);
  }
  size() {
    return this.innerSize;
  }
};
var is = new ge(ct.comparator);
function rs() {
  return is;
}
var os = new ge(ct.comparator);
function us(...t2) {
  let e = os;
  for (const n of t2)
    e = e.insert(n.key, n);
  return e;
}
function cs(t2) {
  let e = os;
  return t2.forEach((t3, n) => e = e.insert(t3, n.overlayedDocument)), e;
}
function as() {
  return ls();
}
function hs() {
  return ls();
}
function ls() {
  return new ss((t2) => t2.toString(), (t2, e) => t2.isEqual(e));
}
var fs = new ge(ct.comparator);
var ds = new Ie(ct.comparator);
function ws(...t2) {
  let e = ds;
  for (const n of t2)
    e = e.add(n);
  return e;
}
var _s = new Ie(X2);
function ms() {
  return _s;
}
function gs(t2, e) {
  if (t2.useProto3Json) {
    if (isNaN(e))
      return {
        doubleValue: "NaN"
      };
    if (e === 1 / 0)
      return {
        doubleValue: "Infinity"
      };
    if (e === -1 / 0)
      return {
        doubleValue: "-Infinity"
      };
  }
  return {
    doubleValue: Mt(e) ? "-0" : e
  };
}
function ys(t2) {
  return {
    integerValue: "" + t2
  };
}
function ps(t2, e) {
  return Ft(e) ? ys(e) : gs(t2, e);
}
var Is = class {
  constructor() {
    this._ = void 0;
  }
};
function Ts(t2, e, n) {
  return t2 instanceof Rs ? function(t3, e2) {
    const n2 = {
      fields: {
        __type__: {
          stringValue: "server_timestamp"
        },
        __local_write_time__: {
          timestampValue: {
            seconds: t3.seconds,
            nanos: t3.nanoseconds
          }
        }
      }
    };
    return e2 && (n2.fields.__previous_value__ = e2), {
      mapValue: n2
    };
  }(n, e) : t2 instanceof vs ? bs(t2, e) : t2 instanceof Ps ? Vs(t2, e) : function(t3, e2) {
    const n2 = As(t3, e2), s = Ds(n2) + Ds(t3._t);
    return ze(n2) && ze(t3._t) ? ys(s) : gs(t3.serializer, s);
  }(t2, e);
}
function Es(t2, e, n) {
  return t2 instanceof vs ? bs(t2, e) : t2 instanceof Ps ? Vs(t2, e) : n;
}
function As(t2, e) {
  return t2 instanceof Ss ? ze(n = e) || function(t3) {
    return !!t3 && "doubleValue" in t3;
  }(n) ? e : {
    integerValue: 0
  } : null;
  var n;
}
var Rs = class extends Is {
};
var vs = class extends Is {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function bs(t2, e) {
  const n = Cs(e);
  for (const e2 of t2.elements)
    n.some((t3) => Be(t3, e2)) || n.push(e2);
  return {
    arrayValue: {
      values: n
    }
  };
}
var Ps = class extends Is {
  constructor(t2) {
    super(), this.elements = t2;
  }
};
function Vs(t2, e) {
  let n = Cs(e);
  for (const e2 of t2.elements)
    n = n.filter((t3) => !Be(t3, e2));
  return {
    arrayValue: {
      values: n
    }
  };
}
var Ss = class extends Is {
  constructor(t2, e) {
    super(), this.serializer = t2, this._t = e;
  }
};
function Ds(t2) {
  return Se(t2.integerValue || t2.doubleValue);
}
function Cs(t2) {
  return je(t2) && t2.arrayValue.values ? t2.arrayValue.values.slice() : [];
}
var xs = class {
  constructor(t2, e) {
    this.field = t2, this.transform = e;
  }
};
function Ns(t2, e) {
  return t2.field.isEqual(e.field) && function(t3, e2) {
    return t3 instanceof vs && e2 instanceof vs || t3 instanceof Ps && e2 instanceof Ps ? tt(t3.elements, e2.elements, Be) : t3 instanceof Ss && e2 instanceof Ss ? Be(t3._t, e2._t) : t3 instanceof Rs && e2 instanceof Rs;
  }(t2.transform, e.transform);
}
var ks = class {
  constructor(t2, e) {
    this.version = t2, this.transformResults = e;
  }
};
var Os = class {
  constructor(t2, e) {
    this.updateTime = t2, this.exists = e;
  }
  static none() {
    return new Os();
  }
  static exists(t2) {
    return new Os(void 0, t2);
  }
  static updateTime(t2) {
    return new Os(t2);
  }
  get isNone() {
    return void 0 === this.updateTime && void 0 === this.exists;
  }
  isEqual(t2) {
    return this.exists === t2.exists && (this.updateTime ? !!t2.updateTime && this.updateTime.isEqual(t2.updateTime) : !t2.updateTime);
  }
};
function $s(t2, e) {
  return void 0 !== t2.updateTime ? e.isFoundDocument() && e.version.isEqual(t2.updateTime) : void 0 === t2.exists || t2.exists === e.isFoundDocument();
}
var Ms = class {
};
function Fs(t2, e) {
  if (!t2.hasLocalMutations || e && 0 === e.fields.length)
    return null;
  if (null === e)
    return t2.isNoDocument() ? new Ws(t2.key, Os.none()) : new Ks(t2.key, t2.data, Os.none());
  {
    const n = t2.data, s = sn.empty();
    let i = new Ie(ut.comparator);
    for (let t3 of e.fields)
      if (!i.has(t3)) {
        let e2 = n.field(t3);
        null === e2 && t3.length > 1 && (t3 = t3.popLast(), e2 = n.field(t3)), null === e2 ? s.delete(t3) : s.set(t3, e2), i = i.add(t3);
      }
    return new Gs(t2.key, s, new Ae(i.toArray()), Os.none());
  }
}
function Bs(t2, e, n) {
  t2 instanceof Ks ? function(t3, e2, n2) {
    const s = t3.value.clone(), i = zs(t3.fieldTransforms, e2, n2.transformResults);
    s.setAll(i), e2.convertToFoundDocument(n2.version, s).setHasCommittedMutations();
  }(t2, e, n) : t2 instanceof Gs ? function(t3, e2, n2) {
    if (!$s(t3.precondition, e2))
      return void e2.convertToUnknownDocument(n2.version);
    const s = zs(t3.fieldTransforms, e2, n2.transformResults), i = e2.data;
    i.setAll(Qs(t3)), i.setAll(s), e2.convertToFoundDocument(n2.version, i).setHasCommittedMutations();
  }(t2, e, n) : function(t3, e2, n2) {
    e2.convertToNoDocument(n2.version).setHasCommittedMutations();
  }(0, e, n);
}
function Ls(t2, e, n, s) {
  return t2 instanceof Ks ? function(t3, e2, n2, s2) {
    if (!$s(t3.precondition, e2))
      return n2;
    const i = t3.value.clone(), r = js(t3.fieldTransforms, s2, e2);
    return i.setAll(r), e2.convertToFoundDocument(e2.version, i).setHasLocalMutations(), null;
  }(t2, e, n, s) : t2 instanceof Gs ? function(t3, e2, n2, s2) {
    if (!$s(t3.precondition, e2))
      return n2;
    const i = js(t3.fieldTransforms, s2, e2), r = e2.data;
    if (r.setAll(Qs(t3)), r.setAll(i), e2.convertToFoundDocument(e2.version, r).setHasLocalMutations(), null === n2)
      return null;
    return n2.unionWith(t3.fieldMask.fields).unionWith(t3.fieldTransforms.map((t4) => t4.field));
  }(t2, e, n, s) : function(t3, e2, n2) {
    if ($s(t3.precondition, e2))
      return e2.convertToNoDocument(e2.version).setHasLocalMutations(), null;
    return n2;
  }(t2, e, n);
}
function qs(t2, e) {
  let n = null;
  for (const s of t2.fieldTransforms) {
    const t3 = e.data.field(s.field), i = As(s.transform, t3 || null);
    null != i && (null === n && (n = sn.empty()), n.set(s.field, i));
  }
  return n || null;
}
function Us(t2, e) {
  return t2.type === e.type && (!!t2.key.isEqual(e.key) && (!!t2.precondition.isEqual(e.precondition) && (!!function(t3, e2) {
    return void 0 === t3 && void 0 === e2 || !(!t3 || !e2) && tt(t3, e2, (t4, e3) => Ns(t4, e3));
  }(t2.fieldTransforms, e.fieldTransforms) && (0 === t2.type ? t2.value.isEqual(e.value) : 1 !== t2.type || t2.data.isEqual(e.data) && t2.fieldMask.isEqual(e.fieldMask)))));
}
var Ks = class extends Ms {
  constructor(t2, e, n, s = []) {
    super(), this.key = t2, this.value = e, this.precondition = n, this.fieldTransforms = s, this.type = 0;
  }
  getFieldMask() {
    return null;
  }
};
var Gs = class extends Ms {
  constructor(t2, e, n, s, i = []) {
    super(), this.key = t2, this.data = e, this.fieldMask = n, this.precondition = s, this.fieldTransforms = i, this.type = 1;
  }
  getFieldMask() {
    return this.fieldMask;
  }
};
function Qs(t2) {
  const e = /* @__PURE__ */ new Map();
  return t2.fieldMask.fields.forEach((n) => {
    if (!n.isEmpty()) {
      const s = t2.data.field(n);
      e.set(n, s);
    }
  }), e;
}
function zs(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  $(t2.length === n.length);
  for (let i = 0; i < n.length; i++) {
    const r = t2[i], o = r.transform, u = e.data.field(r.field);
    s.set(r.field, Es(o, u, n[i]));
  }
  return s;
}
function js(t2, e, n) {
  const s = /* @__PURE__ */ new Map();
  for (const i of t2) {
    const t3 = i.transform, r = n.data.field(i.field);
    s.set(i.field, Ts(t3, r, e));
  }
  return s;
}
var Ws = class extends Ms {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 2, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Hs = class extends Ms {
  constructor(t2, e) {
    super(), this.key = t2, this.precondition = e, this.type = 3, this.fieldTransforms = [];
  }
  getFieldMask() {
    return null;
  }
};
var Js = class {
  constructor(t2, e, n, s) {
    this.batchId = t2, this.localWriteTime = e, this.baseMutations = n, this.mutations = s;
  }
  applyToRemoteDocument(t2, e) {
    const n = e.mutationResults;
    for (let e2 = 0; e2 < this.mutations.length; e2++) {
      const s = this.mutations[e2];
      if (s.key.isEqual(t2.key)) {
        Bs(s, t2, n[e2]);
      }
    }
  }
  applyToLocalView(t2, e) {
    for (const n of this.baseMutations)
      n.key.isEqual(t2.key) && (e = Ls(n, t2, e, this.localWriteTime));
    for (const n of this.mutations)
      n.key.isEqual(t2.key) && (e = Ls(n, t2, e, this.localWriteTime));
    return e;
  }
  applyToLocalDocumentSet(t2, e) {
    const n = hs();
    return this.mutations.forEach((s) => {
      const i = t2.get(s.key), r = i.overlayedDocument;
      let o = this.applyToLocalView(r, i.mutatedFields);
      o = e.has(s.key) ? null : o;
      const u = Fs(r, o);
      null !== u && n.set(s.key, u), r.isValidDocument() || r.convertToNoDocument(st.min());
    }), n;
  }
  keys() {
    return this.mutations.reduce((t2, e) => t2.add(e.key), ws());
  }
  isEqual(t2) {
    return this.batchId === t2.batchId && tt(this.mutations, t2.mutations, (t3, e) => Us(t3, e)) && tt(this.baseMutations, t2.baseMutations, (t3, e) => Us(t3, e));
  }
};
var Ys = class {
  constructor(t2, e, n, s) {
    this.batch = t2, this.commitVersion = e, this.mutationResults = n, this.docVersions = s;
  }
  static from(t2, e, n) {
    $(t2.mutations.length === n.length);
    let s = fs;
    const i = t2.mutations;
    for (let t3 = 0; t3 < i.length; t3++)
      s = s.insert(i[t3].key, n[t3].version);
    return new Ys(t2, e, n, s);
  }
};
var Zs = class {
  constructor(t2, e) {
    this.largestBatchId = t2, this.mutation = e;
  }
  getKey() {
    return this.mutation.key;
  }
  isEqual(t2) {
    return null !== t2 && this.mutation === t2.mutation;
  }
  toString() {
    return `Overlay{
      largestBatchId: ${this.largestBatchId},
      mutation: ${this.mutation.toString()}
    }`;
  }
};
var Xs = /^[_a-zA-Z][_a-zA-Z0-9]*(?:\.[_a-zA-Z][_a-zA-Z0-9]*)*$/;
var ti = class {
  constructor(t2) {
    this.alias = t2;
  }
  static gt(t2) {
    return Xs.test(t2);
  }
  canonicalString() {
    let t2 = this.alias.replace(/\\/g, "\\\\").replace(/`/g, "\\`");
    return ti.gt(t2) || (t2 = "`" + t2 + "`"), t2;
  }
};
var ei = class {
  constructor(t2, e, n) {
    this.alias = t2, this.yt = e, this.fieldPath = n;
  }
};
var ni = class {
  constructor(t2) {
    this.count = t2;
  }
};
var si;
var ii;
function ri(t2) {
  switch (t2) {
    default:
      return O2();
    case B2.CANCELLED:
    case B2.UNKNOWN:
    case B2.DEADLINE_EXCEEDED:
    case B2.RESOURCE_EXHAUSTED:
    case B2.INTERNAL:
    case B2.UNAVAILABLE:
    case B2.UNAUTHENTICATED:
      return false;
    case B2.INVALID_ARGUMENT:
    case B2.NOT_FOUND:
    case B2.ALREADY_EXISTS:
    case B2.PERMISSION_DENIED:
    case B2.FAILED_PRECONDITION:
    case B2.ABORTED:
    case B2.OUT_OF_RANGE:
    case B2.UNIMPLEMENTED:
    case B2.DATA_LOSS:
      return true;
  }
}
function oi(t2) {
  if (void 0 === t2)
    return x2("GRPC error has no .code"), B2.UNKNOWN;
  switch (t2) {
    case si.OK:
      return B2.OK;
    case si.CANCELLED:
      return B2.CANCELLED;
    case si.UNKNOWN:
      return B2.UNKNOWN;
    case si.DEADLINE_EXCEEDED:
      return B2.DEADLINE_EXCEEDED;
    case si.RESOURCE_EXHAUSTED:
      return B2.RESOURCE_EXHAUSTED;
    case si.INTERNAL:
      return B2.INTERNAL;
    case si.UNAVAILABLE:
      return B2.UNAVAILABLE;
    case si.UNAUTHENTICATED:
      return B2.UNAUTHENTICATED;
    case si.INVALID_ARGUMENT:
      return B2.INVALID_ARGUMENT;
    case si.NOT_FOUND:
      return B2.NOT_FOUND;
    case si.ALREADY_EXISTS:
      return B2.ALREADY_EXISTS;
    case si.PERMISSION_DENIED:
      return B2.PERMISSION_DENIED;
    case si.FAILED_PRECONDITION:
      return B2.FAILED_PRECONDITION;
    case si.ABORTED:
      return B2.ABORTED;
    case si.OUT_OF_RANGE:
      return B2.OUT_OF_RANGE;
    case si.UNIMPLEMENTED:
      return B2.UNIMPLEMENTED;
    case si.DATA_LOSS:
      return B2.DATA_LOSS;
    default:
      return O2();
  }
}
(ii = si || (si = {}))[ii.OK = 0] = "OK", ii[ii.CANCELLED = 1] = "CANCELLED", ii[ii.UNKNOWN = 2] = "UNKNOWN", ii[ii.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", ii[ii.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", ii[ii.NOT_FOUND = 5] = "NOT_FOUND", ii[ii.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", ii[ii.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", ii[ii.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", ii[ii.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", ii[ii.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", ii[ii.ABORTED = 10] = "ABORTED", ii[ii.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", ii[ii.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", ii[ii.INTERNAL = 13] = "INTERNAL", ii[ii.UNAVAILABLE = 14] = "UNAVAILABLE", ii[ii.DATA_LOSS = 15] = "DATA_LOSS";
var ui = class {
  constructor() {
    this.onExistenceFilterMismatchCallbacks = /* @__PURE__ */ new Map();
  }
  static get instance() {
    return ci;
  }
  static getOrCreateInstance() {
    return null === ci && (ci = new ui()), ci;
  }
  onExistenceFilterMismatch(t2) {
    const e = Symbol();
    return this.onExistenceFilterMismatchCallbacks.set(e, t2), () => this.onExistenceFilterMismatchCallbacks.delete(e);
  }
  notifyOnExistenceFilterMismatch(t2) {
    this.onExistenceFilterMismatchCallbacks.forEach((e) => e(t2));
  }
};
var ci = null;
var ai = class {
  constructor(t2, e, n, s, i) {
    this.snapshotVersion = t2, this.targetChanges = e, this.targetMismatches = n, this.documentUpdates = s, this.resolvedLimboDocuments = i;
  }
  static createSynthesizedRemoteEventForCurrentChange(t2, e, n) {
    const s = /* @__PURE__ */ new Map();
    return s.set(t2, hi.createSynthesizedTargetChangeForCurrentChange(t2, e, n)), new ai(st.min(), s, ms(), rs(), ws());
  }
};
var hi = class {
  constructor(t2, e, n, s, i) {
    this.resumeToken = t2, this.current = e, this.addedDocuments = n, this.modifiedDocuments = s, this.removedDocuments = i;
  }
  static createSynthesizedTargetChangeForCurrentChange(t2, e, n) {
    return new hi(n, e, ws(), ws(), ws());
  }
};
var li = class {
  constructor(t2, e, n, s) {
    this.It = t2, this.removedTargetIds = e, this.key = n, this.Tt = s;
  }
};
var fi = class {
  constructor(t2, e) {
    this.targetId = t2, this.Et = e;
  }
};
var di = class {
  constructor(t2, e, n = be.EMPTY_BYTE_STRING, s = null) {
    this.state = t2, this.targetIds = e, this.resumeToken = n, this.cause = s;
  }
};
var wi = class {
  constructor() {
    this.At = 0, this.Rt = gi(), this.vt = be.EMPTY_BYTE_STRING, this.bt = false, this.Pt = true;
  }
  get current() {
    return this.bt;
  }
  get resumeToken() {
    return this.vt;
  }
  get Vt() {
    return 0 !== this.At;
  }
  get St() {
    return this.Pt;
  }
  Dt(t2) {
    t2.approximateByteSize() > 0 && (this.Pt = true, this.vt = t2);
  }
  Ct() {
    let t2 = ws(), e = ws(), n = ws();
    return this.Rt.forEach((s, i) => {
      switch (i) {
        case 0:
          t2 = t2.add(s);
          break;
        case 2:
          e = e.add(s);
          break;
        case 1:
          n = n.add(s);
          break;
        default:
          O2();
      }
    }), new hi(this.vt, this.bt, t2, e, n);
  }
  xt() {
    this.Pt = false, this.Rt = gi();
  }
  Nt(t2, e) {
    this.Pt = true, this.Rt = this.Rt.insert(t2, e);
  }
  kt(t2) {
    this.Pt = true, this.Rt = this.Rt.remove(t2);
  }
  Ot() {
    this.At += 1;
  }
  $t() {
    this.At -= 1;
  }
  Mt() {
    this.Pt = true, this.bt = true;
  }
};
var _i = class {
  constructor(t2) {
    this.Ft = t2, this.Bt = /* @__PURE__ */ new Map(), this.Lt = rs(), this.qt = mi(), this.Ut = new Ie(X2);
  }
  Kt(t2) {
    for (const e of t2.It)
      t2.Tt && t2.Tt.isFoundDocument() ? this.Gt(e, t2.Tt) : this.Qt(e, t2.key, t2.Tt);
    for (const e of t2.removedTargetIds)
      this.Qt(e, t2.key, t2.Tt);
  }
  zt(t2) {
    this.forEachTarget(t2, (e) => {
      const n = this.jt(e);
      switch (t2.state) {
        case 0:
          this.Wt(e) && n.Dt(t2.resumeToken);
          break;
        case 1:
          n.$t(), n.Vt || n.xt(), n.Dt(t2.resumeToken);
          break;
        case 2:
          n.$t(), n.Vt || this.removeTarget(e);
          break;
        case 3:
          this.Wt(e) && (n.Mt(), n.Dt(t2.resumeToken));
          break;
        case 4:
          this.Wt(e) && (this.Ht(e), n.Dt(t2.resumeToken));
          break;
        default:
          O2();
      }
    });
  }
  forEachTarget(t2, e) {
    t2.targetIds.length > 0 ? t2.targetIds.forEach(e) : this.Bt.forEach((t3, n) => {
      this.Wt(n) && e(n);
    });
  }
  Jt(t2) {
    var e;
    const n = t2.targetId, s = t2.Et.count, i = this.Yt(n);
    if (i) {
      const r = i.target;
      if (On(r))
        if (0 === s) {
          const t3 = new ct(r.path);
          this.Qt(n, t3, on.newNoDocument(t3, st.min()));
        } else
          $(1 === s);
      else {
        const i2 = this.Zt(n);
        i2 !== s && (this.Ht(n), this.Ut = this.Ut.add(n), null === (e = ui.instance) || void 0 === e || e.notifyOnExistenceFilterMismatch({
          localCacheCount: i2,
          existenceFilterCount: t2.Et.count
        }));
      }
    }
  }
  Xt(t2) {
    const e = /* @__PURE__ */ new Map();
    this.Bt.forEach((n2, s2) => {
      const i = this.Yt(s2);
      if (i) {
        if (n2.current && On(i.target)) {
          const e2 = new ct(i.target.path);
          null !== this.Lt.get(e2) || this.te(s2, e2) || this.Qt(s2, e2, on.newNoDocument(e2, t2));
        }
        n2.St && (e.set(s2, n2.Ct()), n2.xt());
      }
    });
    let n = ws();
    this.qt.forEach((t3, e2) => {
      let s2 = true;
      e2.forEachWhile((t4) => {
        const e3 = this.Yt(t4);
        return !e3 || 2 === e3.purpose || (s2 = false, false);
      }), s2 && (n = n.add(t3));
    }), this.Lt.forEach((e2, n2) => n2.setReadTime(t2));
    const s = new ai(t2, e, this.Ut, this.Lt, n);
    return this.Lt = rs(), this.qt = mi(), this.Ut = new Ie(X2), s;
  }
  Gt(t2, e) {
    if (!this.Wt(t2))
      return;
    const n = this.te(t2, e.key) ? 2 : 0;
    this.jt(t2).Nt(e.key, n), this.Lt = this.Lt.insert(e.key, e), this.qt = this.qt.insert(e.key, this.ee(e.key).add(t2));
  }
  Qt(t2, e, n) {
    if (!this.Wt(t2))
      return;
    const s = this.jt(t2);
    this.te(t2, e) ? s.Nt(e, 1) : s.kt(e), this.qt = this.qt.insert(e, this.ee(e).delete(t2)), n && (this.Lt = this.Lt.insert(e, n));
  }
  removeTarget(t2) {
    this.Bt.delete(t2);
  }
  Zt(t2) {
    const e = this.jt(t2).Ct();
    return this.Ft.getRemoteKeysForTarget(t2).size + e.addedDocuments.size - e.removedDocuments.size;
  }
  Ot(t2) {
    this.jt(t2).Ot();
  }
  jt(t2) {
    let e = this.Bt.get(t2);
    return e || (e = new wi(), this.Bt.set(t2, e)), e;
  }
  ee(t2) {
    let e = this.qt.get(t2);
    return e || (e = new Ie(X2), this.qt = this.qt.insert(t2, e)), e;
  }
  Wt(t2) {
    const e = null !== this.Yt(t2);
    return e || C2("WatchChangeAggregator", "Detected inactive target", t2), e;
  }
  Yt(t2) {
    const e = this.Bt.get(t2);
    return e && e.Vt ? null : this.Ft.ne(t2);
  }
  Ht(t2) {
    this.Bt.set(t2, new wi());
    this.Ft.getRemoteKeysForTarget(t2).forEach((e) => {
      this.Qt(t2, e, null);
    });
  }
  te(t2, e) {
    return this.Ft.getRemoteKeysForTarget(t2).has(e);
  }
};
function mi() {
  return new ge(ct.comparator);
}
function gi() {
  return new ge(ct.comparator);
}
var yi = (() => {
  const t2 = {
    asc: "ASCENDING",
    desc: "DESCENDING"
  };
  return t2;
})();
var pi = (() => {
  const t2 = {
    "<": "LESS_THAN",
    "<=": "LESS_THAN_OR_EQUAL",
    ">": "GREATER_THAN",
    ">=": "GREATER_THAN_OR_EQUAL",
    "==": "EQUAL",
    "!=": "NOT_EQUAL",
    "array-contains": "ARRAY_CONTAINS",
    in: "IN",
    "not-in": "NOT_IN",
    "array-contains-any": "ARRAY_CONTAINS_ANY"
  };
  return t2;
})();
var Ii = (() => {
  const t2 = {
    and: "AND",
    or: "OR"
  };
  return t2;
})();
var Ti = class {
  constructor(t2, e) {
    this.databaseId = t2, this.useProto3Json = e;
  }
};
function Ei(t2, e) {
  if (t2.useProto3Json) {
    return `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z`;
  }
  return {
    seconds: "" + e.seconds,
    nanos: e.nanoseconds
  };
}
function Ai(t2, e) {
  return t2.useProto3Json ? e.toBase64() : e.toUint8Array();
}
function Ri(t2, e) {
  return Ei(t2, e.toTimestamp());
}
function vi(t2) {
  return $(!!t2), st.fromTimestamp(function(t3) {
    const e = Ve(t3);
    return new nt(e.seconds, e.nanos);
  }(t2));
}
function bi(t2, e) {
  return function(t3) {
    return new rt(["projects", t3.projectId, "databases", t3.database]);
  }(t2).child("documents").child(e).canonicalString();
}
function Pi(t2) {
  const e = rt.fromString(t2);
  return $(Xi(e)), e;
}
function Vi(t2, e) {
  return bi(t2.databaseId, e.path);
}
function Si(t2, e) {
  const n = Pi(e);
  if (n.get(1) !== t2.databaseId.projectId)
    throw new L2(B2.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + n.get(1) + " vs " + t2.databaseId.projectId);
  if (n.get(3) !== t2.databaseId.database)
    throw new L2(B2.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + n.get(3) + " vs " + t2.databaseId.database);
  return new ct(Ni(n));
}
function Di(t2, e) {
  return bi(t2.databaseId, e);
}
function Ci(t2) {
  const e = Pi(t2);
  return 4 === e.length ? rt.emptyPath() : Ni(e);
}
function xi(t2) {
  return new rt(["projects", t2.databaseId.projectId, "databases", t2.databaseId.database]).canonicalString();
}
function Ni(t2) {
  return $(t2.length > 4 && "documents" === t2.get(4)), t2.popFirst(5);
}
function ki(t2, e, n) {
  return {
    name: Vi(t2, e),
    fields: n.value.mapValue.fields
  };
}
function Oi(t2, e, n) {
  const s = Si(t2, e.name), i = vi(e.updateTime), r = e.createTime ? vi(e.createTime) : st.min(), o = new sn({
    mapValue: {
      fields: e.fields
    }
  }), u = on.newFoundDocument(s, i, r, o);
  return n && u.setHasCommittedMutations(), n ? u.setHasCommittedMutations() : u;
}
function $i(t2, e) {
  return "found" in e ? function(t3, e2) {
    $(!!e2.found), e2.found.name, e2.found.updateTime;
    const n = Si(t3, e2.found.name), s = vi(e2.found.updateTime), i = e2.found.createTime ? vi(e2.found.createTime) : st.min(), r = new sn({
      mapValue: {
        fields: e2.found.fields
      }
    });
    return on.newFoundDocument(n, s, i, r);
  }(t2, e) : "missing" in e ? function(t3, e2) {
    $(!!e2.missing), $(!!e2.readTime);
    const n = Si(t3, e2.missing), s = vi(e2.readTime);
    return on.newNoDocument(n, s);
  }(t2, e) : O2();
}
function Mi(t2, e) {
  let n;
  if ("targetChange" in e) {
    e.targetChange;
    const s = function(t3) {
      return "NO_CHANGE" === t3 ? 0 : "ADD" === t3 ? 1 : "REMOVE" === t3 ? 2 : "CURRENT" === t3 ? 3 : "RESET" === t3 ? 4 : O2();
    }(e.targetChange.targetChangeType || "NO_CHANGE"), i = e.targetChange.targetIds || [], r = function(t3, e2) {
      return t3.useProto3Json ? ($(void 0 === e2 || "string" == typeof e2), be.fromBase64String(e2 || "")) : ($(void 0 === e2 || e2 instanceof Uint8Array), be.fromUint8Array(e2 || new Uint8Array()));
    }(t2, e.targetChange.resumeToken), o = e.targetChange.cause, u = o && function(t3) {
      const e2 = void 0 === t3.code ? B2.UNKNOWN : oi(t3.code);
      return new L2(e2, t3.message || "");
    }(o);
    n = new di(s, i, r, u || null);
  } else if ("documentChange" in e) {
    e.documentChange;
    const s = e.documentChange;
    s.document, s.document.name, s.document.updateTime;
    const i = Si(t2, s.document.name), r = vi(s.document.updateTime), o = s.document.createTime ? vi(s.document.createTime) : st.min(), u = new sn({
      mapValue: {
        fields: s.document.fields
      }
    }), c = on.newFoundDocument(i, r, o, u), a = s.targetIds || [], h = s.removedTargetIds || [];
    n = new li(a, h, c.key, c);
  } else if ("documentDelete" in e) {
    e.documentDelete;
    const s = e.documentDelete;
    s.document;
    const i = Si(t2, s.document), r = s.readTime ? vi(s.readTime) : st.min(), o = on.newNoDocument(i, r), u = s.removedTargetIds || [];
    n = new li([], u, o.key, o);
  } else if ("documentRemove" in e) {
    e.documentRemove;
    const s = e.documentRemove;
    s.document;
    const i = Si(t2, s.document), r = s.removedTargetIds || [];
    n = new li([], r, i, null);
  } else {
    if (!("filter" in e))
      return O2();
    {
      e.filter;
      const t3 = e.filter;
      t3.targetId;
      const s = t3.count || 0, i = new ni(s), r = t3.targetId;
      n = new fi(r, i);
    }
  }
  return n;
}
function Fi(t2, e) {
  let n;
  if (e instanceof Ks)
    n = {
      update: ki(t2, e.key, e.value)
    };
  else if (e instanceof Ws)
    n = {
      delete: Vi(t2, e.key)
    };
  else if (e instanceof Gs)
    n = {
      update: ki(t2, e.key, e.data),
      updateMask: Zi(e.fieldMask)
    };
  else {
    if (!(e instanceof Hs))
      return O2();
    n = {
      verify: Vi(t2, e.key)
    };
  }
  return e.fieldTransforms.length > 0 && (n.updateTransforms = e.fieldTransforms.map((t3) => function(t4, e2) {
    const n2 = e2.transform;
    if (n2 instanceof Rs)
      return {
        fieldPath: e2.field.canonicalString(),
        setToServerValue: "REQUEST_TIME"
      };
    if (n2 instanceof vs)
      return {
        fieldPath: e2.field.canonicalString(),
        appendMissingElements: {
          values: n2.elements
        }
      };
    if (n2 instanceof Ps)
      return {
        fieldPath: e2.field.canonicalString(),
        removeAllFromArray: {
          values: n2.elements
        }
      };
    if (n2 instanceof Ss)
      return {
        fieldPath: e2.field.canonicalString(),
        increment: n2._t
      };
    throw O2();
  }(0, t3))), e.precondition.isNone || (n.currentDocument = function(t3, e2) {
    return void 0 !== e2.updateTime ? {
      updateTime: Ri(t3, e2.updateTime)
    } : void 0 !== e2.exists ? {
      exists: e2.exists
    } : O2();
  }(t2, e.precondition)), n;
}
function Bi(t2, e) {
  const n = e.currentDocument ? function(t3) {
    return void 0 !== t3.updateTime ? Os.updateTime(vi(t3.updateTime)) : void 0 !== t3.exists ? Os.exists(t3.exists) : Os.none();
  }(e.currentDocument) : Os.none(), s = e.updateTransforms ? e.updateTransforms.map((e2) => function(t3, e3) {
    let n2 = null;
    if ("setToServerValue" in e3)
      $("REQUEST_TIME" === e3.setToServerValue), n2 = new Rs();
    else if ("appendMissingElements" in e3) {
      const t4 = e3.appendMissingElements.values || [];
      n2 = new vs(t4);
    } else if ("removeAllFromArray" in e3) {
      const t4 = e3.removeAllFromArray.values || [];
      n2 = new Ps(t4);
    } else
      "increment" in e3 ? n2 = new Ss(t3, e3.increment) : O2();
    const s2 = ut.fromServerFormat(e3.fieldPath);
    return new xs(s2, n2);
  }(t2, e2)) : [];
  if (e.update) {
    e.update.name;
    const i = Si(t2, e.update.name), r = new sn({
      mapValue: {
        fields: e.update.fields
      }
    });
    if (e.updateMask) {
      const t3 = function(t4) {
        const e2 = t4.fieldPaths || [];
        return new Ae(e2.map((t5) => ut.fromServerFormat(t5)));
      }(e.updateMask);
      return new Gs(i, r, t3, n, s);
    }
    return new Ks(i, r, n, s);
  }
  if (e.delete) {
    const s2 = Si(t2, e.delete);
    return new Ws(s2, n);
  }
  if (e.verify) {
    const s2 = Si(t2, e.verify);
    return new Hs(s2, n);
  }
  return O2();
}
function Li(t2, e) {
  return t2 && t2.length > 0 ? ($(void 0 !== e), t2.map((t3) => function(t4, e2) {
    let n = t4.updateTime ? vi(t4.updateTime) : vi(e2);
    return n.isEqual(st.min()) && (n = vi(e2)), new ks(n, t4.transformResults || []);
  }(t3, e))) : [];
}
function qi(t2, e) {
  return {
    documents: [Di(t2, e.path)]
  };
}
function Ui(t2, e) {
  const n = {
    structuredQuery: {}
  }, s = e.path;
  null !== e.collectionGroup ? (n.parent = Di(t2, s), n.structuredQuery.from = [{
    collectionId: e.collectionGroup,
    allDescendants: true
  }]) : (n.parent = Di(t2, s.popLast()), n.structuredQuery.from = [{
    collectionId: s.lastSegment()
  }]);
  const i = function(t3) {
    if (0 === t3.length)
      return;
    return Yi(wn.create(t3, "and"));
  }(e.filters);
  i && (n.structuredQuery.where = i);
  const r = function(t3) {
    if (0 === t3.length)
      return;
    return t3.map((t4) => function(t5) {
      return {
        field: Hi(t5.field),
        direction: zi(t5.dir)
      };
    }(t4));
  }(e.orderBy);
  r && (n.structuredQuery.orderBy = r);
  const o = function(t3, e2) {
    return t3.useProto3Json || $t(e2) ? e2 : {
      value: e2
    };
  }(t2, e.limit);
  var u;
  return null !== o && (n.structuredQuery.limit = o), e.startAt && (n.structuredQuery.startAt = {
    before: (u = e.startAt).inclusive,
    values: u.position
  }), e.endAt && (n.structuredQuery.endAt = function(t3) {
    return {
      before: !t3.inclusive,
      values: t3.position
    };
  }(e.endAt)), n;
}
function Ki(t2) {
  let e = Ci(t2.parent);
  const n = t2.structuredQuery, s = n.from ? n.from.length : 0;
  let i = null;
  if (s > 0) {
    $(1 === s);
    const t3 = n.from[0];
    t3.allDescendants ? i = t3.collectionId : e = e.child(t3.collectionId);
  }
  let r = [];
  n.where && (r = function(t3) {
    const e2 = Qi(t3);
    if (e2 instanceof wn && gn(e2))
      return e2.getFilters();
    return [e2];
  }(n.where));
  let o = [];
  n.orderBy && (o = n.orderBy.map((t3) => function(t4) {
    return new hn(
      Ji(t4.field),
      function(t5) {
        switch (t5) {
          case "ASCENDING":
            return "asc";
          case "DESCENDING":
            return "desc";
          default:
            return;
        }
      }(t4.direction)
    );
  }(t3)));
  let u = null;
  n.limit && (u = function(t3) {
    let e2;
    return e2 = "object" == typeof t3 ? t3.value : t3, $t(e2) ? null : e2;
  }(n.limit));
  let c = null;
  n.startAt && (c = function(t3) {
    const e2 = !!t3.before, n2 = t3.values || [];
    return new un(n2, e2);
  }(n.startAt));
  let a = null;
  return n.endAt && (a = function(t3) {
    const e2 = !t3.before, n2 = t3.values || [];
    return new un(n2, e2);
  }(n.endAt)), Ln(e, i, o, r, u, "F", c, a);
}
function Gi(t2, e) {
  const n = function(t3, e2) {
    switch (e2) {
      case 0:
        return null;
      case 1:
        return "existence-filter-mismatch";
      case 2:
        return "limbo-document";
      default:
        return O2();
    }
  }(0, e.purpose);
  return null == n ? null : {
    "goog-listen-tags": n
  };
}
function Qi(t2) {
  return void 0 !== t2.unaryFilter ? function(t3) {
    switch (t3.unaryFilter.op) {
      case "IS_NAN":
        const e = Ji(t3.unaryFilter.field);
        return dn.create(e, "==", {
          doubleValue: NaN
        });
      case "IS_NULL":
        const n = Ji(t3.unaryFilter.field);
        return dn.create(n, "==", {
          nullValue: "NULL_VALUE"
        });
      case "IS_NOT_NAN":
        const s = Ji(t3.unaryFilter.field);
        return dn.create(s, "!=", {
          doubleValue: NaN
        });
      case "IS_NOT_NULL":
        const i = Ji(t3.unaryFilter.field);
        return dn.create(i, "!=", {
          nullValue: "NULL_VALUE"
        });
      default:
        return O2();
    }
  }(t2) : void 0 !== t2.fieldFilter ? function(t3) {
    return dn.create(Ji(t3.fieldFilter.field), function(t4) {
      switch (t4) {
        case "EQUAL":
          return "==";
        case "NOT_EQUAL":
          return "!=";
        case "GREATER_THAN":
          return ">";
        case "GREATER_THAN_OR_EQUAL":
          return ">=";
        case "LESS_THAN":
          return "<";
        case "LESS_THAN_OR_EQUAL":
          return "<=";
        case "ARRAY_CONTAINS":
          return "array-contains";
        case "IN":
          return "in";
        case "NOT_IN":
          return "not-in";
        case "ARRAY_CONTAINS_ANY":
          return "array-contains-any";
        default:
          return O2();
      }
    }(t3.fieldFilter.op), t3.fieldFilter.value);
  }(t2) : void 0 !== t2.compositeFilter ? function(t3) {
    return wn.create(t3.compositeFilter.filters.map((t4) => Qi(t4)), function(t4) {
      switch (t4) {
        case "AND":
          return "and";
        case "OR":
          return "or";
        default:
          return O2();
      }
    }(t3.compositeFilter.op));
  }(t2) : O2();
}
function zi(t2) {
  return yi[t2];
}
function ji(t2) {
  return pi[t2];
}
function Wi(t2) {
  return Ii[t2];
}
function Hi(t2) {
  return {
    fieldPath: t2.canonicalString()
  };
}
function Ji(t2) {
  return ut.fromServerFormat(t2.fieldPath);
}
function Yi(t2) {
  return t2 instanceof dn ? function(t3) {
    if ("==" === t3.op) {
      if (He(t3.value))
        return {
          unaryFilter: {
            field: Hi(t3.field),
            op: "IS_NAN"
          }
        };
      if (We(t3.value))
        return {
          unaryFilter: {
            field: Hi(t3.field),
            op: "IS_NULL"
          }
        };
    } else if ("!=" === t3.op) {
      if (He(t3.value))
        return {
          unaryFilter: {
            field: Hi(t3.field),
            op: "IS_NOT_NAN"
          }
        };
      if (We(t3.value))
        return {
          unaryFilter: {
            field: Hi(t3.field),
            op: "IS_NOT_NULL"
          }
        };
    }
    return {
      fieldFilter: {
        field: Hi(t3.field),
        op: ji(t3.op),
        value: t3.value
      }
    };
  }(t2) : t2 instanceof wn ? function(t3) {
    const e = t3.getFilters().map((t4) => Yi(t4));
    if (1 === e.length)
      return e[0];
    return {
      compositeFilter: {
        op: Wi(t3.op),
        filters: e
      }
    };
  }(t2) : O2();
}
function Zi(t2) {
  const e = [];
  return t2.fields.forEach((t3) => e.push(t3.canonicalString())), {
    fieldPaths: e
  };
}
function Xi(t2) {
  return t2.length >= 4 && "projects" === t2.get(0) && "databases" === t2.get(2);
}
var tr = class {
  constructor(t2, e, n, s, i = st.min(), r = st.min(), o = be.EMPTY_BYTE_STRING) {
    this.target = t2, this.targetId = e, this.purpose = n, this.sequenceNumber = s, this.snapshotVersion = i, this.lastLimboFreeSnapshotVersion = r, this.resumeToken = o;
  }
  withSequenceNumber(t2) {
    return new tr(this.target, this.targetId, this.purpose, t2, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken);
  }
  withResumeToken(t2, e) {
    return new tr(this.target, this.targetId, this.purpose, this.sequenceNumber, e, this.lastLimboFreeSnapshotVersion, t2);
  }
  withLastLimboFreeSnapshotVersion(t2) {
    return new tr(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, t2, this.resumeToken);
  }
};
var er = class {
  constructor(t2) {
    this.se = t2;
  }
};
function nr(t2, e) {
  let n;
  if (e.document)
    n = Oi(t2.se, e.document, !!e.hasCommittedMutations);
  else if (e.noDocument) {
    const t3 = ct.fromSegments(e.noDocument.path), s = or(e.noDocument.readTime);
    n = on.newNoDocument(t3, s), e.hasCommittedMutations && n.setHasCommittedMutations();
  } else {
    if (!e.unknownDocument)
      return O2();
    {
      const t3 = ct.fromSegments(e.unknownDocument.path), s = or(e.unknownDocument.version);
      n = on.newUnknownDocument(t3, s);
    }
  }
  return e.readTime && n.setReadTime(function(t3) {
    const e2 = new nt(t3[0], t3[1]);
    return st.fromTimestamp(e2);
  }(e.readTime)), n;
}
function sr(t2, e) {
  const n = e.key, s = {
    prefixPath: n.getCollectionPath().popLast().toArray(),
    collectionGroup: n.collectionGroup,
    documentId: n.path.lastSegment(),
    readTime: ir(e.readTime),
    hasCommittedMutations: e.hasCommittedMutations
  };
  if (e.isFoundDocument())
    s.document = function(t3, e2) {
      return {
        name: Vi(t3, e2.key),
        fields: e2.data.value.mapValue.fields,
        updateTime: Ei(t3, e2.version.toTimestamp()),
        createTime: Ei(t3, e2.createTime.toTimestamp())
      };
    }(t2.se, e);
  else if (e.isNoDocument())
    s.noDocument = {
      path: n.path.toArray(),
      readTime: rr(e.version)
    };
  else {
    if (!e.isUnknownDocument())
      return O2();
    s.unknownDocument = {
      path: n.path.toArray(),
      version: rr(e.version)
    };
  }
  return s;
}
function ir(t2) {
  const e = t2.toTimestamp();
  return [e.seconds, e.nanoseconds];
}
function rr(t2) {
  const e = t2.toTimestamp();
  return {
    seconds: e.seconds,
    nanoseconds: e.nanoseconds
  };
}
function or(t2) {
  const e = new nt(t2.seconds, t2.nanoseconds);
  return st.fromTimestamp(e);
}
function ur(t2, e) {
  const n = (e.baseMutations || []).map((e2) => Bi(t2.se, e2));
  for (let t3 = 0; t3 < e.mutations.length - 1; ++t3) {
    const n2 = e.mutations[t3];
    if (t3 + 1 < e.mutations.length && void 0 !== e.mutations[t3 + 1].transform) {
      const s2 = e.mutations[t3 + 1];
      n2.updateTransforms = s2.transform.fieldTransforms, e.mutations.splice(t3 + 1, 1), ++t3;
    }
  }
  const s = e.mutations.map((e2) => Bi(t2.se, e2)), i = nt.fromMillis(e.localWriteTimeMs);
  return new Js(e.batchId, i, n, s);
}
function cr(t2) {
  const e = or(t2.readTime), n = void 0 !== t2.lastLimboFreeSnapshotVersion ? or(t2.lastLimboFreeSnapshotVersion) : st.min();
  let s;
  var i;
  return void 0 !== t2.query.documents ? ($(1 === (i = t2.query).documents.length), s = jn(qn(Ci(i.documents[0])))) : s = function(t3) {
    return jn(Ki(t3));
  }(t2.query), new tr(s, t2.targetId, 0, t2.lastListenSequenceNumber, e, n, be.fromBase64String(t2.resumeToken));
}
function ar(t2, e) {
  const n = rr(e.snapshotVersion), s = rr(e.lastLimboFreeSnapshotVersion);
  let i;
  i = On(e.target) ? qi(t2.se, e.target) : Ui(t2.se, e.target);
  const r = e.resumeToken.toBase64();
  return {
    targetId: e.targetId,
    canonicalId: Nn(e.target),
    readTime: n,
    resumeToken: r,
    lastListenSequenceNumber: e.sequenceNumber,
    lastLimboFreeSnapshotVersion: s,
    query: i
  };
}
function hr(t2) {
  const e = Ki({
    parent: t2.parent,
    structuredQuery: t2.structuredQuery
  });
  return "LAST" === t2.limitType ? Hn(e, e.limit, "L") : e;
}
function lr(t2, e) {
  return new Zs(e.largestBatchId, Bi(t2.se, e.overlayMutation));
}
function fr(t2, e) {
  const n = e.path.lastSegment();
  return [t2, Bt(e.path.popLast()), n];
}
function dr(t2, e, n, s) {
  return {
    indexId: t2,
    uid: e.uid || "",
    sequenceNumber: n,
    readTime: rr(s.readTime),
    documentKey: Bt(s.documentKey.path),
    largestBatchId: s.largestBatchId
  };
}
var wr = class {
  getBundleMetadata(t2, e) {
    return _r(t2).get(e).next((t3) => {
      if (t3)
        return {
          id: (e2 = t3).bundleId,
          createTime: or(e2.createTime),
          version: e2.version
        };
      var e2;
    });
  }
  saveBundleMetadata(t2, e) {
    return _r(t2).put({
      bundleId: (n = e).id,
      createTime: rr(vi(n.createTime)),
      version: n.version
    });
    var n;
  }
  getNamedQuery(t2, e) {
    return mr(t2).get(e).next((t3) => {
      if (t3)
        return {
          name: (e2 = t3).name,
          query: hr(e2.bundledQuery),
          readTime: or(e2.readTime)
        };
      var e2;
    });
  }
  saveNamedQuery(t2, e) {
    return mr(t2).put(function(t3) {
      return {
        name: t3.name,
        readTime: rr(vi(t3.readTime)),
        bundledQuery: t3.bundledQuery
      };
    }(e));
  }
};
function _r(t2) {
  return de(t2, "bundles");
}
function mr(t2) {
  return de(t2, "namedQueries");
}
var gr = class {
  constructor(t2, e) {
    this.serializer = t2, this.userId = e;
  }
  static ie(t2, e) {
    const n = e.uid || "";
    return new gr(t2, n);
  }
  getOverlay(t2, e) {
    return yr(t2).get(fr(this.userId, e)).next((t3) => t3 ? lr(this.serializer, t3) : null);
  }
  getOverlays(t2, e) {
    const n = as();
    return At.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      null !== t3 && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    const s = [];
    return n.forEach((n2, i) => {
      const r = new Zs(e, i);
      s.push(this.re(t2, r));
    }), At.waitFor(s);
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = /* @__PURE__ */ new Set();
    e.forEach((t3) => s.add(Bt(t3.getCollectionPath())));
    const i = [];
    return s.forEach((e2) => {
      const s2 = IDBKeyRange.bound(
        [this.userId, e2, n],
        [this.userId, e2, n + 1],
        false,
        true
      );
      i.push(yr(t2).J("collectionPathOverlayIndex", s2));
    }), At.waitFor(i);
  }
  getOverlaysForCollection(t2, e, n) {
    const s = as(), i = Bt(e), r = IDBKeyRange.bound(
      [this.userId, i, n],
      [this.userId, i, Number.POSITIVE_INFINITY],
      true
    );
    return yr(t2).j("collectionPathOverlayIndex", r).next((t3) => {
      for (const e2 of t3) {
        const t4 = lr(this.serializer, e2);
        s.set(t4.getKey(), t4);
      }
      return s;
    });
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    const i = as();
    let r;
    const o = IDBKeyRange.bound(
      [this.userId, e, n],
      [this.userId, e, Number.POSITIVE_INFINITY],
      true
    );
    return yr(t2).Z({
      index: "collectionGroupOverlayIndex",
      range: o
    }, (t3, e2, n2) => {
      const o2 = lr(this.serializer, e2);
      i.size() < s || o2.largestBatchId === r ? (i.set(o2.getKey(), o2), r = o2.largestBatchId) : n2.done();
    }).next(() => i);
  }
  re(t2, e) {
    return yr(t2).put(function(t3, e2, n) {
      const [s, i, r] = fr(e2, n.mutation.key);
      return {
        userId: e2,
        collectionPath: i,
        documentId: r,
        collectionGroup: n.mutation.key.getCollectionGroup(),
        largestBatchId: n.largestBatchId,
        overlayMutation: Fi(t3.se, n.mutation)
      };
    }(this.serializer, this.userId, e));
  }
};
function yr(t2) {
  return de(t2, "documentOverlays");
}
var pr = class {
  constructor() {
  }
  oe(t2, e) {
    this.ue(t2, e), e.ce();
  }
  ue(t2, e) {
    if ("nullValue" in t2)
      this.ae(e, 5);
    else if ("booleanValue" in t2)
      this.ae(e, 10), e.he(t2.booleanValue ? 1 : 0);
    else if ("integerValue" in t2)
      this.ae(e, 15), e.he(Se(t2.integerValue));
    else if ("doubleValue" in t2) {
      const n = Se(t2.doubleValue);
      isNaN(n) ? this.ae(e, 13) : (this.ae(e, 15), Mt(n) ? e.he(0) : e.he(n));
    } else if ("timestampValue" in t2) {
      const n = t2.timestampValue;
      this.ae(e, 20), "string" == typeof n ? e.le(n) : (e.le(`${n.seconds || ""}`), e.he(n.nanos || 0));
    } else if ("stringValue" in t2)
      this.fe(t2.stringValue, e), this.de(e);
    else if ("bytesValue" in t2)
      this.ae(e, 30), e.we(De(t2.bytesValue)), this.de(e);
    else if ("referenceValue" in t2)
      this._e(t2.referenceValue, e);
    else if ("geoPointValue" in t2) {
      const n = t2.geoPointValue;
      this.ae(e, 45), e.he(n.latitude || 0), e.he(n.longitude || 0);
    } else
      "mapValue" in t2 ? Ze(t2) ? this.ae(e, Number.MAX_SAFE_INTEGER) : (this.me(t2.mapValue, e), this.de(e)) : "arrayValue" in t2 ? (this.ge(t2.arrayValue, e), this.de(e)) : O2();
  }
  fe(t2, e) {
    this.ae(e, 25), this.ye(t2, e);
  }
  ye(t2, e) {
    e.le(t2);
  }
  me(t2, e) {
    const n = t2.fields || {};
    this.ae(e, 55);
    for (const t3 of Object.keys(n))
      this.fe(t3, e), this.ue(n[t3], e);
  }
  ge(t2, e) {
    const n = t2.values || [];
    this.ae(e, 50);
    for (const t3 of n)
      this.ue(t3, e);
  }
  _e(t2, e) {
    this.ae(e, 37);
    ct.fromName(t2).path.forEach((t3) => {
      this.ae(e, 60), this.ye(t3, e);
    });
  }
  ae(t2, e) {
    t2.he(e);
  }
  de(t2) {
    t2.he(2);
  }
};
pr.pe = new pr();
function Ir(t2) {
  if (0 === t2)
    return 8;
  let e = 0;
  return t2 >> 4 == 0 && (e += 4, t2 <<= 4), t2 >> 6 == 0 && (e += 2, t2 <<= 2), t2 >> 7 == 0 && (e += 1), e;
}
function Tr(t2) {
  const e = 64 - function(t3) {
    let e2 = 0;
    for (let n = 0; n < 8; ++n) {
      const s = Ir(255 & t3[n]);
      if (e2 += s, 8 !== s)
        break;
    }
    return e2;
  }(t2);
  return Math.ceil(e / 8);
}
var Er = class {
  constructor() {
    this.buffer = new Uint8Array(1024), this.position = 0;
  }
  Ie(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Te(n.value), n = e.next();
    this.Ee();
  }
  Ae(t2) {
    const e = t2[Symbol.iterator]();
    let n = e.next();
    for (; !n.done; )
      this.Re(n.value), n = e.next();
    this.ve();
  }
  be(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Te(t3);
      else if (t3 < 2048)
        this.Te(960 | t3 >>> 6), this.Te(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Te(480 | t3 >>> 12), this.Te(128 | 63 & t3 >>> 6), this.Te(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Te(240 | t4 >>> 18), this.Te(128 | 63 & t4 >>> 12), this.Te(128 | 63 & t4 >>> 6), this.Te(128 | 63 & t4);
      }
    }
    this.Ee();
  }
  Pe(t2) {
    for (const e of t2) {
      const t3 = e.charCodeAt(0);
      if (t3 < 128)
        this.Re(t3);
      else if (t3 < 2048)
        this.Re(960 | t3 >>> 6), this.Re(128 | 63 & t3);
      else if (e < "\uD800" || "\uDBFF" < e)
        this.Re(480 | t3 >>> 12), this.Re(128 | 63 & t3 >>> 6), this.Re(128 | 63 & t3);
      else {
        const t4 = e.codePointAt(0);
        this.Re(240 | t4 >>> 18), this.Re(128 | 63 & t4 >>> 12), this.Re(128 | 63 & t4 >>> 6), this.Re(128 | 63 & t4);
      }
    }
    this.ve();
  }
  Ve(t2) {
    const e = this.Se(t2), n = Tr(e);
    this.De(1 + n), this.buffer[this.position++] = 255 & n;
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = 255 & e[t3];
  }
  Ce(t2) {
    const e = this.Se(t2), n = Tr(e);
    this.De(1 + n), this.buffer[this.position++] = ~(255 & n);
    for (let t3 = e.length - n; t3 < e.length; ++t3)
      this.buffer[this.position++] = ~(255 & e[t3]);
  }
  xe() {
    this.Ne(255), this.Ne(255);
  }
  ke() {
    this.Oe(255), this.Oe(255);
  }
  reset() {
    this.position = 0;
  }
  seed(t2) {
    this.De(t2.length), this.buffer.set(t2, this.position), this.position += t2.length;
  }
  $e() {
    return this.buffer.slice(0, this.position);
  }
  Se(t2) {
    const e = function(t3) {
      const e2 = new DataView(new ArrayBuffer(8));
      return e2.setFloat64(0, t3, false), new Uint8Array(e2.buffer);
    }(t2), n = 0 != (128 & e[0]);
    e[0] ^= n ? 255 : 128;
    for (let t3 = 1; t3 < e.length; ++t3)
      e[t3] ^= n ? 255 : 0;
    return e;
  }
  Te(t2) {
    const e = 255 & t2;
    0 === e ? (this.Ne(0), this.Ne(255)) : 255 === e ? (this.Ne(255), this.Ne(0)) : this.Ne(e);
  }
  Re(t2) {
    const e = 255 & t2;
    0 === e ? (this.Oe(0), this.Oe(255)) : 255 === e ? (this.Oe(255), this.Oe(0)) : this.Oe(t2);
  }
  Ee() {
    this.Ne(0), this.Ne(1);
  }
  ve() {
    this.Oe(0), this.Oe(1);
  }
  Ne(t2) {
    this.De(1), this.buffer[this.position++] = t2;
  }
  Oe(t2) {
    this.De(1), this.buffer[this.position++] = ~t2;
  }
  De(t2) {
    const e = t2 + this.position;
    if (e <= this.buffer.length)
      return;
    let n = 2 * this.buffer.length;
    n < e && (n = e);
    const s = new Uint8Array(n);
    s.set(this.buffer), this.buffer = s;
  }
};
var Ar = class {
  constructor(t2) {
    this.Me = t2;
  }
  we(t2) {
    this.Me.Ie(t2);
  }
  le(t2) {
    this.Me.be(t2);
  }
  he(t2) {
    this.Me.Ve(t2);
  }
  ce() {
    this.Me.xe();
  }
};
var Rr = class {
  constructor(t2) {
    this.Me = t2;
  }
  we(t2) {
    this.Me.Ae(t2);
  }
  le(t2) {
    this.Me.Pe(t2);
  }
  he(t2) {
    this.Me.Ce(t2);
  }
  ce() {
    this.Me.ke();
  }
};
var vr = class {
  constructor() {
    this.Me = new Er(), this.Fe = new Ar(this.Me), this.Be = new Rr(this.Me);
  }
  seed(t2) {
    this.Me.seed(t2);
  }
  Le(t2) {
    return 0 === t2 ? this.Fe : this.Be;
  }
  $e() {
    return this.Me.$e();
  }
  reset() {
    this.Me.reset();
  }
};
var br = class {
  constructor(t2, e, n, s) {
    this.indexId = t2, this.documentKey = e, this.arrayValue = n, this.directionalValue = s;
  }
  qe() {
    const t2 = this.directionalValue.length, e = 0 === t2 || 255 === this.directionalValue[t2 - 1] ? t2 + 1 : t2, n = new Uint8Array(e);
    return n.set(this.directionalValue, 0), e !== t2 ? n.set([0], this.directionalValue.length) : ++n[n.length - 1], new br(this.indexId, this.documentKey, this.arrayValue, n);
  }
};
function Pr(t2, e) {
  let n = t2.indexId - e.indexId;
  return 0 !== n ? n : (n = Vr(t2.arrayValue, e.arrayValue), 0 !== n ? n : (n = Vr(t2.directionalValue, e.directionalValue), 0 !== n ? n : ct.comparator(t2.documentKey, e.documentKey)));
}
function Vr(t2, e) {
  for (let n = 0; n < t2.length && n < e.length; ++n) {
    const s = t2[n] - e[n];
    if (0 !== s)
      return s;
  }
  return t2.length - e.length;
}
var Sr = class {
  constructor(t2) {
    this.collectionId = null != t2.collectionGroup ? t2.collectionGroup : t2.path.lastSegment(), this.Ue = t2.orderBy, this.Ke = [];
    for (const e of t2.filters) {
      const t3 = e;
      t3.isInequality() ? this.Ge = t3 : this.Ke.push(t3);
    }
  }
  Qe(t2) {
    $(t2.collectionGroup === this.collectionId);
    const e = ht(t2);
    if (void 0 !== e && !this.ze(e))
      return false;
    const n = lt(t2);
    let s = 0, i = 0;
    for (; s < n.length && this.ze(n[s]); ++s)
      ;
    if (s === n.length)
      return true;
    if (void 0 !== this.Ge) {
      const t3 = n[s];
      if (!this.je(this.Ge, t3) || !this.We(this.Ue[i++], t3))
        return false;
      ++s;
    }
    for (; s < n.length; ++s) {
      const t3 = n[s];
      if (i >= this.Ue.length || !this.We(this.Ue[i++], t3))
        return false;
    }
    return true;
  }
  ze(t2) {
    for (const e of this.Ke)
      if (this.je(e, t2))
        return true;
    return false;
  }
  je(t2, e) {
    if (void 0 === t2 || !t2.field.isEqual(e.fieldPath))
      return false;
    const n = "array-contains" === t2.op || "array-contains-any" === t2.op;
    return 2 === e.kind === n;
  }
  We(t2, e) {
    return !!t2.field.isEqual(e.fieldPath) && (0 === e.kind && "asc" === t2.dir || 1 === e.kind && "desc" === t2.dir);
  }
};
function Dr(t2) {
  var e, n;
  if ($(t2 instanceof dn || t2 instanceof wn), t2 instanceof dn) {
    if (t2 instanceof Vn) {
      const s2 = (null === (n = null === (e = t2.value.arrayValue) || void 0 === e ? void 0 : e.values) || void 0 === n ? void 0 : n.map((e2) => dn.create(t2.field, "==", e2))) || [];
      return wn.create(s2, "or");
    }
    return t2;
  }
  const s = t2.filters.map((t3) => Dr(t3));
  return wn.create(s, t2.op);
}
function Cr(t2) {
  if (0 === t2.getFilters().length)
    return [];
  const e = Or(Dr(t2));
  return $(kr(e)), xr(e) || Nr(e) ? [e] : e.getFilters();
}
function xr(t2) {
  return t2 instanceof dn;
}
function Nr(t2) {
  return t2 instanceof wn && gn(t2);
}
function kr(t2) {
  return xr(t2) || Nr(t2) || function(t3) {
    if (t3 instanceof wn && mn(t3)) {
      for (const e of t3.getFilters())
        if (!xr(e) && !Nr(e))
          return false;
      return true;
    }
    return false;
  }(t2);
}
function Or(t2) {
  if ($(t2 instanceof dn || t2 instanceof wn), t2 instanceof dn)
    return t2;
  if (1 === t2.filters.length)
    return Or(t2.filters[0]);
  const e = t2.filters.map((t3) => Or(t3));
  let n = wn.create(e, t2.op);
  return n = Fr(n), kr(n) ? n : ($(n instanceof wn), $(_n(n)), $(n.filters.length > 1), n.filters.reduce((t3, e2) => $r(t3, e2)));
}
function $r(t2, e) {
  let n;
  return $(t2 instanceof dn || t2 instanceof wn), $(e instanceof dn || e instanceof wn), n = t2 instanceof dn ? e instanceof dn ? function(t3, e2) {
    return wn.create([t3, e2], "and");
  }(t2, e) : Mr(t2, e) : e instanceof dn ? Mr(e, t2) : function(t3, e2) {
    if ($(t3.filters.length > 0 && e2.filters.length > 0), _n(t3) && _n(e2))
      return Tn(t3, e2.getFilters());
    const n2 = mn(t3) ? t3 : e2, s = mn(t3) ? e2 : t3, i = n2.filters.map((t4) => $r(t4, s));
    return wn.create(i, "or");
  }(t2, e), Fr(n);
}
function Mr(t2, e) {
  if (_n(e))
    return Tn(e, t2.getFilters());
  {
    const n = e.filters.map((e2) => $r(t2, e2));
    return wn.create(n, "or");
  }
}
function Fr(t2) {
  if ($(t2 instanceof dn || t2 instanceof wn), t2 instanceof dn)
    return t2;
  const e = t2.getFilters();
  if (1 === e.length)
    return Fr(e[0]);
  if (yn(t2))
    return t2;
  const n = e.map((t3) => Fr(t3)), s = [];
  return n.forEach((e2) => {
    e2 instanceof dn ? s.push(e2) : e2 instanceof wn && (e2.op === t2.op ? s.push(...e2.filters) : s.push(e2));
  }), 1 === s.length ? s[0] : wn.create(s, t2.op);
}
var Br = class {
  constructor() {
    this.He = new Lr();
  }
  addToCollectionParentIndex(t2, e) {
    return this.He.add(e), At.resolve();
  }
  getCollectionParents(t2, e) {
    return At.resolve(this.He.getEntries(e));
  }
  addFieldIndex(t2, e) {
    return At.resolve();
  }
  deleteFieldIndex(t2, e) {
    return At.resolve();
  }
  getDocumentsMatchingTarget(t2, e) {
    return At.resolve(null);
  }
  getIndexType(t2, e) {
    return At.resolve(0);
  }
  getFieldIndexes(t2, e) {
    return At.resolve([]);
  }
  getNextCollectionGroupToUpdate(t2) {
    return At.resolve(null);
  }
  getMinOffset(t2, e) {
    return At.resolve(yt.min());
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return At.resolve(yt.min());
  }
  updateCollectionGroup(t2, e, n) {
    return At.resolve();
  }
  updateIndexEntries(t2, e) {
    return At.resolve();
  }
};
var Lr = class {
  constructor() {
    this.index = {};
  }
  add(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e] || new Ie(rt.comparator), i = !s.has(n);
    return this.index[e] = s.add(n), i;
  }
  has(t2) {
    const e = t2.lastSegment(), n = t2.popLast(), s = this.index[e];
    return s && s.has(n);
  }
  getEntries(t2) {
    return (this.index[t2] || new Ie(rt.comparator)).toArray();
  }
};
var qr = new Uint8Array(0);
var Ur = class {
  constructor(t2, e) {
    this.user = t2, this.databaseId = e, this.Je = new Lr(), this.Ye = new ss((t3) => Nn(t3), (t3, e2) => kn(t3, e2)), this.uid = t2.uid || "";
  }
  addToCollectionParentIndex(t2, e) {
    if (!this.Je.has(e)) {
      const n = e.lastSegment(), s = e.popLast();
      t2.addOnCommittedListener(() => {
        this.Je.add(e);
      });
      const i = {
        collectionId: n,
        parent: Bt(s)
      };
      return Kr(t2).put(i);
    }
    return At.resolve();
  }
  getCollectionParents(t2, e) {
    const n = [], s = IDBKeyRange.bound(
      [e, ""],
      [et(e), ""],
      false,
      true
    );
    return Kr(t2).j(s).next((t3) => {
      for (const s2 of t3) {
        if (s2.collectionId !== e)
          break;
        n.push(Ut(s2.parent));
      }
      return n;
    });
  }
  addFieldIndex(t2, e) {
    const n = Qr(t2), s = function(t3) {
      return {
        indexId: t3.indexId,
        collectionGroup: t3.collectionGroup,
        fields: t3.fields.map((t4) => [t4.fieldPath.canonicalString(), t4.kind])
      };
    }(e);
    delete s.indexId;
    const i = n.add(s);
    if (e.indexState) {
      const n2 = zr(t2);
      return i.next((t3) => {
        n2.put(dr(t3, this.user, e.indexState.sequenceNumber, e.indexState.offset));
      });
    }
    return i.next();
  }
  deleteFieldIndex(t2, e) {
    const n = Qr(t2), s = zr(t2), i = Gr(t2);
    return n.delete(e.indexId).next(() => s.delete(IDBKeyRange.bound(
      [e.indexId],
      [e.indexId + 1],
      false,
      true
    ))).next(() => i.delete(IDBKeyRange.bound(
      [e.indexId],
      [e.indexId + 1],
      false,
      true
    )));
  }
  getDocumentsMatchingTarget(t2, e) {
    const n = Gr(t2);
    let s = true;
    const i = /* @__PURE__ */ new Map();
    return At.forEach(this.Ze(e), (e2) => this.Xe(t2, e2).next((t3) => {
      s && (s = !!t3), i.set(e2, t3);
    })).next(() => {
      if (s) {
        let t3 = ws();
        const s2 = [];
        return At.forEach(i, (i2, r) => {
          var o;
          C2("IndexedDbIndexManager", `Using index ${o = i2, `id=${o.indexId}|cg=${o.collectionGroup}|f=${o.fields.map((t4) => `${t4.fieldPath}:${t4.kind}`).join(",")}`} to execute ${Nn(e)}`);
          const u = function(t4, e2) {
            const n2 = ht(e2);
            if (void 0 === n2)
              return null;
            for (const e3 of $n(t4, n2.fieldPath))
              switch (e3.op) {
                case "array-contains-any":
                  return e3.value.arrayValue.values || [];
                case "array-contains":
                  return [e3.value];
              }
            return null;
          }(r, i2), c = function(t4, e2) {
            const n2 = /* @__PURE__ */ new Map();
            for (const s3 of lt(e2))
              for (const e3 of $n(t4, s3.fieldPath))
                switch (e3.op) {
                  case "==":
                  case "in":
                    n2.set(s3.fieldPath.canonicalString(), e3.value);
                    break;
                  case "not-in":
                  case "!=":
                    return n2.set(s3.fieldPath.canonicalString(), e3.value), Array.from(n2.values());
                }
            return null;
          }(r, i2), a = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of lt(e2)) {
              const e3 = 0 === i3.kind ? Mn(t4, i3.fieldPath, t4.startAt) : Fn(t4, i3.fieldPath, t4.startAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new un(n2, s3);
          }(r, i2), h = function(t4, e2) {
            const n2 = [];
            let s3 = true;
            for (const i3 of lt(e2)) {
              const e3 = 0 === i3.kind ? Fn(t4, i3.fieldPath, t4.endAt) : Mn(t4, i3.fieldPath, t4.endAt);
              n2.push(e3.value), s3 && (s3 = e3.inclusive);
            }
            return new un(n2, s3);
          }(r, i2), l2 = this.tn(i2, r, a), f = this.tn(i2, r, h), d = this.en(i2, r, c), w2 = this.nn(i2.indexId, u, l2, a.inclusive, f, h.inclusive, d);
          return At.forEach(w2, (i3) => n.H(i3, e.limit).next((e2) => {
            e2.forEach((e3) => {
              const n2 = ct.fromSegments(e3.documentKey);
              t3.has(n2) || (t3 = t3.add(n2), s2.push(n2));
            });
          }));
        }).next(() => s2);
      }
      return At.resolve(null);
    });
  }
  Ze(t2) {
    let e = this.Ye.get(t2);
    if (e)
      return e;
    if (0 === t2.filters.length)
      e = [t2];
    else {
      e = Cr(wn.create(t2.filters, "and")).map((e2) => xn(t2.path, t2.collectionGroup, t2.orderBy, e2.getFilters(), t2.limit, t2.startAt, t2.endAt));
    }
    return this.Ye.set(t2, e), e;
  }
  nn(t2, e, n, s, i, r, o) {
    const u = (null != e ? e.length : 1) * Math.max(n.length, i.length), c = u / (null != e ? e.length : 1), a = [];
    for (let h = 0; h < u; ++h) {
      const u2 = e ? this.sn(e[h / c]) : qr, l2 = this.rn(t2, u2, n[h % c], s), f = this.on(t2, u2, i[h % c], r), d = o.map((e2) => this.rn(
        t2,
        u2,
        e2,
        true
      ));
      a.push(...this.createRange(l2, f, d));
    }
    return a;
  }
  rn(t2, e, n, s) {
    const i = new br(t2, ct.empty(), e, n);
    return s ? i : i.qe();
  }
  on(t2, e, n, s) {
    const i = new br(t2, ct.empty(), e, n);
    return s ? i.qe() : i;
  }
  Xe(t2, e) {
    const n = new Sr(e), s = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment();
    return this.getFieldIndexes(t2, s).next((t3) => {
      let e2 = null;
      for (const s2 of t3) {
        n.Qe(s2) && (!e2 || s2.fields.length > e2.fields.length) && (e2 = s2);
      }
      return e2;
    });
  }
  getIndexType(t2, e) {
    let n = 2;
    const s = this.Ze(e);
    return At.forEach(s, (e2) => this.Xe(t2, e2).next((t3) => {
      t3 ? 0 !== n && t3.fields.length < function(t4) {
        let e3 = new Ie(ut.comparator), n2 = false;
        for (const s2 of t4.filters)
          for (const t5 of s2.getFlattenedFilters())
            t5.field.isKeyField() || ("array-contains" === t5.op || "array-contains-any" === t5.op ? n2 = true : e3 = e3.add(t5.field));
        for (const n3 of t4.orderBy)
          n3.field.isKeyField() || (e3 = e3.add(n3.field));
        return e3.size + (n2 ? 1 : 0);
      }(e2) && (n = 1) : n = 0;
    })).next(() => function(t3) {
      return null !== t3.limit;
    }(e) && s.length > 1 && 2 === n ? 1 : n);
  }
  un(t2, e) {
    const n = new vr();
    for (const s of lt(t2)) {
      const t3 = e.data.field(s.fieldPath);
      if (null == t3)
        return null;
      const i = n.Le(s.kind);
      pr.pe.oe(t3, i);
    }
    return n.$e();
  }
  sn(t2) {
    const e = new vr();
    return pr.pe.oe(t2, e.Le(0)), e.$e();
  }
  cn(t2, e) {
    const n = new vr();
    return pr.pe.oe(Qe(this.databaseId, e), n.Le(function(t3) {
      const e2 = lt(t3);
      return 0 === e2.length ? 0 : e2[e2.length - 1].kind;
    }(t2))), n.$e();
  }
  en(t2, e, n) {
    if (null === n)
      return [];
    let s = [];
    s.push(new vr());
    let i = 0;
    for (const r of lt(t2)) {
      const t3 = n[i++];
      for (const n2 of s)
        if (this.an(e, r.fieldPath) && je(t3))
          s = this.hn(s, r, t3);
        else {
          const e2 = n2.Le(r.kind);
          pr.pe.oe(t3, e2);
        }
    }
    return this.ln(s);
  }
  tn(t2, e, n) {
    return this.en(t2, e, n.position);
  }
  ln(t2) {
    const e = [];
    for (let n = 0; n < t2.length; ++n)
      e[n] = t2[n].$e();
    return e;
  }
  hn(t2, e, n) {
    const s = [...t2], i = [];
    for (const t3 of n.arrayValue.values || [])
      for (const n2 of s) {
        const s2 = new vr();
        s2.seed(n2.$e()), pr.pe.oe(t3, s2.Le(e.kind)), i.push(s2);
      }
    return i;
  }
  an(t2, e) {
    return !!t2.filters.find((t3) => t3 instanceof dn && t3.field.isEqual(e) && ("in" === t3.op || "not-in" === t3.op));
  }
  getFieldIndexes(t2, e) {
    const n = Qr(t2), s = zr(t2);
    return (e ? n.j("collectionGroupIndex", IDBKeyRange.bound(e, e)) : n.j()).next((t3) => {
      const e2 = [];
      return At.forEach(t3, (t4) => s.get([t4.indexId, this.uid]).next((n2) => {
        e2.push(function(t5, e3) {
          const n3 = e3 ? new _t(e3.sequenceNumber, new yt(or(e3.readTime), new ct(Ut(e3.documentKey)), e3.largestBatchId)) : _t.empty(), s2 = t5.fields.map(([t6, e4]) => new dt(ut.fromServerFormat(t6), e4));
          return new at(t5.indexId, t5.collectionGroup, s2, n3);
        }(t4, n2));
      })).next(() => e2);
    });
  }
  getNextCollectionGroupToUpdate(t2) {
    return this.getFieldIndexes(t2).next((t3) => 0 === t3.length ? null : (t3.sort((t4, e) => {
      const n = t4.indexState.sequenceNumber - e.indexState.sequenceNumber;
      return 0 !== n ? n : X2(t4.collectionGroup, e.collectionGroup);
    }), t3[0].collectionGroup));
  }
  updateCollectionGroup(t2, e, n) {
    const s = Qr(t2), i = zr(t2);
    return this.fn(t2).next((t3) => s.j("collectionGroupIndex", IDBKeyRange.bound(e, e)).next((e2) => At.forEach(e2, (e3) => i.put(dr(e3.indexId, this.user, t3, n)))));
  }
  updateIndexEntries(t2, e) {
    const n = /* @__PURE__ */ new Map();
    return At.forEach(e, (e2, s) => {
      const i = n.get(e2.collectionGroup);
      return (i ? At.resolve(i) : this.getFieldIndexes(t2, e2.collectionGroup)).next((i2) => (n.set(e2.collectionGroup, i2), At.forEach(i2, (n2) => this.dn(t2, e2, n2).next((e3) => {
        const i3 = this.wn(s, n2);
        return e3.isEqual(i3) ? At.resolve() : this._n(t2, s, n2, e3, i3);
      }))));
    });
  }
  mn(t2, e, n, s) {
    return Gr(t2).put({
      indexId: s.indexId,
      uid: this.uid,
      arrayValue: s.arrayValue,
      directionalValue: s.directionalValue,
      orderedDocumentKey: this.cn(n, e.key),
      documentKey: e.key.path.toArray()
    });
  }
  gn(t2, e, n, s) {
    return Gr(t2).delete([s.indexId, this.uid, s.arrayValue, s.directionalValue, this.cn(n, e.key), e.key.path.toArray()]);
  }
  dn(t2, e, n) {
    const s = Gr(t2);
    let i = new Ie(Pr);
    return s.Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only([n.indexId, this.uid, this.cn(n, e)])
    }, (t3, s2) => {
      i = i.add(new br(n.indexId, e, s2.arrayValue, s2.directionalValue));
    }).next(() => i);
  }
  wn(t2, e) {
    let n = new Ie(Pr);
    const s = this.un(e, t2);
    if (null == s)
      return n;
    const i = ht(e);
    if (null != i) {
      const r = t2.data.field(i.fieldPath);
      if (je(r))
        for (const i2 of r.arrayValue.values || [])
          n = n.add(new br(e.indexId, t2.key, this.sn(i2), s));
    } else
      n = n.add(new br(e.indexId, t2.key, qr, s));
    return n;
  }
  _n(t2, e, n, s, i) {
    C2("IndexedDbIndexManager", "Updating index entries for document '%s'", e.key);
    const r = [];
    return function(t3, e2, n2, s2, i2) {
      const r2 = t3.getIterator(), o = e2.getIterator();
      let u = Ee(r2), c = Ee(o);
      for (; u || c; ) {
        let t4 = false, e3 = false;
        if (u && c) {
          const s3 = n2(u, c);
          s3 < 0 ? e3 = true : s3 > 0 && (t4 = true);
        } else
          null != u ? e3 = true : t4 = true;
        t4 ? (s2(c), c = Ee(o)) : e3 ? (i2(u), u = Ee(r2)) : (u = Ee(r2), c = Ee(o));
      }
    }(s, i, Pr, (s2) => {
      r.push(this.mn(t2, e, n, s2));
    }, (s2) => {
      r.push(this.gn(t2, e, n, s2));
    }), At.waitFor(r);
  }
  fn(t2) {
    let e = 1;
    return zr(t2).Z({
      index: "sequenceNumberIndex",
      reverse: true,
      range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER])
    }, (t3, n, s) => {
      s.done(), e = n.sequenceNumber + 1;
    }).next(() => e);
  }
  createRange(t2, e, n) {
    n = n.sort((t3, e2) => Pr(t3, e2)).filter((t3, e2, n2) => !e2 || 0 !== Pr(t3, n2[e2 - 1]));
    const s = [];
    s.push(t2);
    for (const i2 of n) {
      const n2 = Pr(i2, t2), r = Pr(i2, e);
      if (0 === n2)
        s[0] = t2.qe();
      else if (n2 > 0 && r < 0)
        s.push(i2), s.push(i2.qe());
      else if (r > 0)
        break;
    }
    s.push(e);
    const i = [];
    for (let t3 = 0; t3 < s.length; t3 += 2) {
      if (this.yn(s[t3], s[t3 + 1]))
        return [];
      const e2 = [s[t3].indexId, this.uid, s[t3].arrayValue, s[t3].directionalValue, qr, []], n2 = [s[t3 + 1].indexId, this.uid, s[t3 + 1].arrayValue, s[t3 + 1].directionalValue, qr, []];
      i.push(IDBKeyRange.bound(e2, n2));
    }
    return i;
  }
  yn(t2, e) {
    return Pr(t2, e) > 0;
  }
  getMinOffsetFromCollectionGroup(t2, e) {
    return this.getFieldIndexes(t2, e).next(jr);
  }
  getMinOffset(t2, e) {
    return At.mapArray(this.Ze(e), (e2) => this.Xe(t2, e2).next((t3) => t3 || O2())).next(jr);
  }
};
function Kr(t2) {
  return de(t2, "collectionParents");
}
function Gr(t2) {
  return de(t2, "indexEntries");
}
function Qr(t2) {
  return de(t2, "indexConfiguration");
}
function zr(t2) {
  return de(t2, "indexState");
}
function jr(t2) {
  $(0 !== t2.length);
  let e = t2[0].indexState.offset, n = e.largestBatchId;
  for (let s = 1; s < t2.length; s++) {
    const i = t2[s].indexState.offset;
    pt(i, e) < 0 && (e = i), n < i.largestBatchId && (n = i.largestBatchId);
  }
  return new yt(e.readTime, e.documentKey, n);
}
var Wr = {
  didRun: false,
  sequenceNumbersCollected: 0,
  targetsRemoved: 0,
  documentsRemoved: 0
};
var Hr = class {
  constructor(t2, e, n) {
    this.cacheSizeCollectionThreshold = t2, this.percentileToCollect = e, this.maximumSequenceNumbersToCollect = n;
  }
  static withCacheSize(t2) {
    return new Hr(t2, Hr.DEFAULT_COLLECTION_PERCENTILE, Hr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT);
  }
};
function Jr(t2, e, n) {
  const s = t2.store("mutations"), i = t2.store("documentMutations"), r = [], o = IDBKeyRange.only(n.batchId);
  let u = 0;
  const c = s.Z({
    range: o
  }, (t3, e2, n2) => (u++, n2.delete()));
  r.push(c.next(() => {
    $(1 === u);
  }));
  const a = [];
  for (const t3 of n.mutations) {
    const s2 = Qt(e, t3.key.path, n.batchId);
    r.push(i.delete(s2)), a.push(t3.key);
  }
  return At.waitFor(r).next(() => a);
}
function Yr(t2) {
  if (!t2)
    return 0;
  let e;
  if (t2.document)
    e = t2.document;
  else if (t2.unknownDocument)
    e = t2.unknownDocument;
  else {
    if (!t2.noDocument)
      throw O2();
    e = t2.noDocument;
  }
  return JSON.stringify(e).length;
}
Hr.DEFAULT_COLLECTION_PERCENTILE = 10, Hr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Hr.DEFAULT = new Hr(41943040, Hr.DEFAULT_COLLECTION_PERCENTILE, Hr.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Hr.DISABLED = new Hr(-1, 0, 0);
var Zr = class {
  constructor(t2, e, n, s) {
    this.userId = t2, this.serializer = e, this.indexManager = n, this.referenceDelegate = s, this.pn = {};
  }
  static ie(t2, e, n, s) {
    $("" !== t2.uid);
    const i = t2.isAuthenticated() ? t2.uid : "";
    return new Zr(i, e, n, s);
  }
  checkEmpty(t2) {
    let e = true;
    const n = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]);
    return to(t2).Z({
      index: "userMutationsIndex",
      range: n
    }, (t3, n2, s) => {
      e = false, s.done();
    }).next(() => e);
  }
  addMutationBatch(t2, e, n, s) {
    const i = eo(t2), r = to(t2);
    return r.add({}).next((o) => {
      $("number" == typeof o);
      const u = new Js(o, e, n, s), c = function(t3, e2, n2) {
        const s2 = n2.baseMutations.map((e3) => Fi(t3.se, e3)), i2 = n2.mutations.map((e3) => Fi(t3.se, e3));
        return {
          userId: e2,
          batchId: n2.batchId,
          localWriteTimeMs: n2.localWriteTime.toMillis(),
          baseMutations: s2,
          mutations: i2
        };
      }(this.serializer, this.userId, u), a = [];
      let h = new Ie((t3, e2) => X2(t3.canonicalString(), e2.canonicalString()));
      for (const t3 of s) {
        const e2 = Qt(this.userId, t3.key.path, o);
        h = h.add(t3.key.path.popLast()), a.push(r.put(c)), a.push(i.put(e2, zt));
      }
      return h.forEach((e2) => {
        a.push(this.indexManager.addToCollectionParentIndex(t2, e2));
      }), t2.addOnCommittedListener(() => {
        this.pn[o] = u.keys();
      }), At.waitFor(a).next(() => u);
    });
  }
  lookupMutationBatch(t2, e) {
    return to(t2).get(e).next((t3) => t3 ? ($(t3.userId === this.userId), ur(this.serializer, t3)) : null);
  }
  In(t2, e) {
    return this.pn[e] ? At.resolve(this.pn[e]) : this.lookupMutationBatch(t2, e).next((t3) => {
      if (t3) {
        const n = t3.keys();
        return this.pn[e] = n, n;
      }
      return null;
    });
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = IDBKeyRange.lowerBound([this.userId, n]);
    let i = null;
    return to(t2).Z({
      index: "userMutationsIndex",
      range: s
    }, (t3, e2, s2) => {
      e2.userId === this.userId && ($(e2.batchId >= n), i = ur(this.serializer, e2)), s2.done();
    }).next(() => i);
  }
  getHighestUnacknowledgedBatchId(t2) {
    const e = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]);
    let n = -1;
    return to(t2).Z({
      index: "userMutationsIndex",
      range: e,
      reverse: true
    }, (t3, e2, s) => {
      n = e2.batchId, s.done();
    }).next(() => n);
  }
  getAllMutationBatches(t2) {
    const e = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]);
    return to(t2).j("userMutationsIndex", e).next((t3) => t3.map((t4) => ur(this.serializer, t4)));
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = Gt(this.userId, e.path), s = IDBKeyRange.lowerBound(n), i = [];
    return eo(t2).Z({
      range: s
    }, (n2, s2, r) => {
      const [o, u, c] = n2, a = Ut(u);
      if (o === this.userId && e.path.isEqual(a))
        return to(t2).get(c).next((t3) => {
          if (!t3)
            throw O2();
          $(t3.userId === this.userId), i.push(ur(this.serializer, t3));
        });
      r.done();
    }).next(() => i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Ie(X2);
    const s = [];
    return e.forEach((e2) => {
      const i = Gt(this.userId, e2.path), r = IDBKeyRange.lowerBound(i), o = eo(t2).Z({
        range: r
      }, (t3, s2, i2) => {
        const [r2, o2, u] = t3, c = Ut(o2);
        r2 === this.userId && e2.path.isEqual(c) ? n = n.add(u) : i2.done();
      });
      s.push(o);
    }), At.waitFor(s).next(() => this.Tn(t2, n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1, i = Gt(this.userId, n), r = IDBKeyRange.lowerBound(i);
    let o = new Ie(X2);
    return eo(t2).Z({
      range: r
    }, (t3, e2, i2) => {
      const [r2, u, c] = t3, a = Ut(u);
      r2 === this.userId && n.isPrefixOf(a) ? a.length === s && (o = o.add(c)) : i2.done();
    }).next(() => this.Tn(t2, o));
  }
  Tn(t2, e) {
    const n = [], s = [];
    return e.forEach((e2) => {
      s.push(to(t2).get(e2).next((t3) => {
        if (null === t3)
          throw O2();
        $(t3.userId === this.userId), n.push(ur(this.serializer, t3));
      }));
    }), At.waitFor(s).next(() => n);
  }
  removeMutationBatch(t2, e) {
    return Jr(t2.at, this.userId, e).next((n) => (t2.addOnCommittedListener(() => {
      this.En(e.batchId);
    }), At.forEach(n, (e2) => this.referenceDelegate.markPotentiallyOrphaned(t2, e2))));
  }
  En(t2) {
    delete this.pn[t2];
  }
  performConsistencyCheck(t2) {
    return this.checkEmpty(t2).next((e) => {
      if (!e)
        return At.resolve();
      const n = IDBKeyRange.lowerBound([this.userId]);
      const s = [];
      return eo(t2).Z({
        range: n
      }, (t3, e2, n2) => {
        if (t3[0] === this.userId) {
          const e3 = Ut(t3[1]);
          s.push(e3);
        } else
          n2.done();
      }).next(() => {
        $(0 === s.length);
      });
    });
  }
  containsKey(t2, e) {
    return Xr(t2, this.userId, e);
  }
  An(t2) {
    return no(t2).get(this.userId).next((t3) => t3 || {
      userId: this.userId,
      lastAcknowledgedBatchId: -1,
      lastStreamToken: ""
    });
  }
};
function Xr(t2, e, n) {
  const s = Gt(e, n.path), i = s[1], r = IDBKeyRange.lowerBound(s);
  let o = false;
  return eo(t2).Z({
    range: r,
    Y: true
  }, (t3, n2, s2) => {
    const [r2, u, c] = t3;
    r2 === e && u === i && (o = true), s2.done();
  }).next(() => o);
}
function to(t2) {
  return de(t2, "mutations");
}
function eo(t2) {
  return de(t2, "documentMutations");
}
function no(t2) {
  return de(t2, "mutationQueues");
}
var so = class {
  constructor(t2) {
    this.Rn = t2;
  }
  next() {
    return this.Rn += 2, this.Rn;
  }
  static vn() {
    return new so(0);
  }
  static bn() {
    return new so(-1);
  }
};
var io = class {
  constructor(t2, e) {
    this.referenceDelegate = t2, this.serializer = e;
  }
  allocateTargetId(t2) {
    return this.Pn(t2).next((e) => {
      const n = new so(e.highestTargetId);
      return e.highestTargetId = n.next(), this.Vn(t2, e).next(() => e.highestTargetId);
    });
  }
  getLastRemoteSnapshotVersion(t2) {
    return this.Pn(t2).next((t3) => st.fromTimestamp(new nt(t3.lastRemoteSnapshotVersion.seconds, t3.lastRemoteSnapshotVersion.nanoseconds)));
  }
  getHighestSequenceNumber(t2) {
    return this.Pn(t2).next((t3) => t3.highestListenSequenceNumber);
  }
  setTargetsMetadata(t2, e, n) {
    return this.Pn(t2).next((s) => (s.highestListenSequenceNumber = e, n && (s.lastRemoteSnapshotVersion = n.toTimestamp()), e > s.highestListenSequenceNumber && (s.highestListenSequenceNumber = e), this.Vn(t2, s)));
  }
  addTargetData(t2, e) {
    return this.Sn(t2, e).next(() => this.Pn(t2).next((n) => (n.targetCount += 1, this.Dn(e, n), this.Vn(t2, n))));
  }
  updateTargetData(t2, e) {
    return this.Sn(t2, e);
  }
  removeTargetData(t2, e) {
    return this.removeMatchingKeysForTargetId(t2, e.targetId).next(() => ro(t2).delete(e.targetId)).next(() => this.Pn(t2)).next((e2) => ($(e2.targetCount > 0), e2.targetCount -= 1, this.Vn(t2, e2)));
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return ro(t2).Z((r, o) => {
      const u = cr(o);
      u.sequenceNumber <= e && null === n.get(u.targetId) && (s++, i.push(this.removeTargetData(t2, u)));
    }).next(() => At.waitFor(i)).next(() => s);
  }
  forEachTarget(t2, e) {
    return ro(t2).Z((t3, n) => {
      const s = cr(n);
      e(s);
    });
  }
  Pn(t2) {
    return oo(t2).get("targetGlobalKey").next((t3) => ($(null !== t3), t3));
  }
  Vn(t2, e) {
    return oo(t2).put("targetGlobalKey", e);
  }
  Sn(t2, e) {
    return ro(t2).put(ar(this.serializer, e));
  }
  Dn(t2, e) {
    let n = false;
    return t2.targetId > e.highestTargetId && (e.highestTargetId = t2.targetId, n = true), t2.sequenceNumber > e.highestListenSequenceNumber && (e.highestListenSequenceNumber = t2.sequenceNumber, n = true), n;
  }
  getTargetCount(t2) {
    return this.Pn(t2).next((t3) => t3.targetCount);
  }
  getTargetData(t2, e) {
    const n = Nn(e), s = IDBKeyRange.bound([n, Number.NEGATIVE_INFINITY], [n, Number.POSITIVE_INFINITY]);
    let i = null;
    return ro(t2).Z({
      range: s,
      index: "queryTargetsIndex"
    }, (t3, n2, s2) => {
      const r = cr(n2);
      kn(e, r.target) && (i = r, s2.done());
    }).next(() => i);
  }
  addMatchingKeys(t2, e, n) {
    const s = [], i = uo(t2);
    return e.forEach((e2) => {
      const r = Bt(e2.path);
      s.push(i.put({
        targetId: n,
        path: r
      })), s.push(this.referenceDelegate.addReference(t2, n, e2));
    }), At.waitFor(s);
  }
  removeMatchingKeys(t2, e, n) {
    const s = uo(t2);
    return At.forEach(e, (e2) => {
      const i = Bt(e2.path);
      return At.waitFor([s.delete([n, i]), this.referenceDelegate.removeReference(t2, n, e2)]);
    });
  }
  removeMatchingKeysForTargetId(t2, e) {
    const n = uo(t2), s = IDBKeyRange.bound(
      [e],
      [e + 1],
      false,
      true
    );
    return n.delete(s);
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = IDBKeyRange.bound(
      [e],
      [e + 1],
      false,
      true
    ), s = uo(t2);
    let i = ws();
    return s.Z({
      range: n,
      Y: true
    }, (t3, e2, n2) => {
      const s2 = Ut(t3[1]), r = new ct(s2);
      i = i.add(r);
    }).next(() => i);
  }
  containsKey(t2, e) {
    const n = Bt(e.path), s = IDBKeyRange.bound(
      [n],
      [et(n)],
      false,
      true
    );
    let i = 0;
    return uo(t2).Z({
      index: "documentTargetsIndex",
      Y: true,
      range: s
    }, ([t3, e2], n2, s2) => {
      0 !== t3 && (i++, s2.done());
    }).next(() => i > 0);
  }
  ne(t2, e) {
    return ro(t2).get(e).next((t3) => t3 ? cr(t3) : null);
  }
};
function ro(t2) {
  return de(t2, "targets");
}
function oo(t2) {
  return de(t2, "targetGlobal");
}
function uo(t2) {
  return de(t2, "targetDocuments");
}
function co([t2, e], [n, s]) {
  const i = X2(t2, n);
  return 0 === i ? X2(e, s) : i;
}
var ao = class {
  constructor(t2) {
    this.Cn = t2, this.buffer = new Ie(co), this.xn = 0;
  }
  Nn() {
    return ++this.xn;
  }
  kn(t2) {
    const e = [t2, this.Nn()];
    if (this.buffer.size < this.Cn)
      this.buffer = this.buffer.add(e);
    else {
      const t3 = this.buffer.last();
      co(e, t3) < 0 && (this.buffer = this.buffer.delete(t3).add(e));
    }
  }
  get maxValue() {
    return this.buffer.last()[0];
  }
};
var ho = class {
  constructor(t2, e, n) {
    this.garbageCollector = t2, this.asyncQueue = e, this.localStore = n, this.On = null;
  }
  start() {
    -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.$n(6e4);
  }
  stop() {
    this.On && (this.On.cancel(), this.On = null);
  }
  get started() {
    return null !== this.On;
  }
  $n(t2) {
    C2("LruGarbageCollector", `Garbage collection scheduled in ${t2}ms`), this.On = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", t2, async () => {
      this.On = null;
      try {
        await this.localStore.collectGarbage(this.garbageCollector);
      } catch (t3) {
        Vt(t3) ? C2("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", t3) : await Et(t3);
      }
      await this.$n(3e5);
    });
  }
};
var lo = class {
  constructor(t2, e) {
    this.Mn = t2, this.params = e;
  }
  calculateTargetCount(t2, e) {
    return this.Mn.Fn(t2).next((t3) => Math.floor(e / 100 * t3));
  }
  nthSequenceNumber(t2, e) {
    if (0 === e)
      return At.resolve(Ot.ct);
    const n = new ao(e);
    return this.Mn.forEachTarget(t2, (t3) => n.kn(t3.sequenceNumber)).next(() => this.Mn.Bn(t2, (t3) => n.kn(t3))).next(() => n.maxValue);
  }
  removeTargets(t2, e, n) {
    return this.Mn.removeTargets(t2, e, n);
  }
  removeOrphanedDocuments(t2, e) {
    return this.Mn.removeOrphanedDocuments(t2, e);
  }
  collect(t2, e) {
    return -1 === this.params.cacheSizeCollectionThreshold ? (C2("LruGarbageCollector", "Garbage collection skipped; disabled"), At.resolve(Wr)) : this.getCacheSize(t2).next((n) => n < this.params.cacheSizeCollectionThreshold ? (C2("LruGarbageCollector", `Garbage collection skipped; Cache size ${n} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), Wr) : this.Ln(t2, e));
  }
  getCacheSize(t2) {
    return this.Mn.getCacheSize(t2);
  }
  Ln(t2, e) {
    let n, s, i, r, o, c, a;
    const h = Date.now();
    return this.calculateTargetCount(t2, this.params.percentileToCollect).next((e2) => (e2 > this.params.maximumSequenceNumbersToCollect ? (C2("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${e2}`), s = this.params.maximumSequenceNumbersToCollect) : s = e2, r = Date.now(), this.nthSequenceNumber(t2, s))).next((s2) => (n = s2, o = Date.now(), this.removeTargets(t2, n, e))).next((e2) => (i = e2, c = Date.now(), this.removeOrphanedDocuments(t2, n))).next((t3) => {
      if (a = Date.now(), S2() <= LogLevel.DEBUG) {
        C2("LruGarbageCollector", `LRU Garbage Collection
	Counted targets in ${r - h}ms
	Determined least recently used ${s} in ` + (o - r) + `ms
	Removed ${i} targets in ` + (c - o) + `ms
	Removed ${t3} documents in ` + (a - c) + `ms
Total Duration: ${a - h}ms`);
      }
      return At.resolve({
        didRun: true,
        sequenceNumbersCollected: s,
        targetsRemoved: i,
        documentsRemoved: t3
      });
    });
  }
};
var fo = class {
  constructor(t2, e) {
    this.db = t2, this.garbageCollector = function(t3, e2) {
      return new lo(t3, e2);
    }(this, e);
  }
  Fn(t2) {
    const e = this.qn(t2);
    return this.db.getTargetCache().getTargetCount(t2).next((t3) => e.next((e2) => t3 + e2));
  }
  qn(t2) {
    let e = 0;
    return this.Bn(t2, (t3) => {
      e++;
    }).next(() => e);
  }
  forEachTarget(t2, e) {
    return this.db.getTargetCache().forEachTarget(t2, e);
  }
  Bn(t2, e) {
    return this.Un(t2, (t3, n) => e(n));
  }
  addReference(t2, e, n) {
    return wo(t2, n);
  }
  removeReference(t2, e, n) {
    return wo(t2, n);
  }
  removeTargets(t2, e, n) {
    return this.db.getTargetCache().removeTargets(t2, e, n);
  }
  markPotentiallyOrphaned(t2, e) {
    return wo(t2, e);
  }
  Kn(t2, e) {
    return function(t3, e2) {
      let n = false;
      return no(t3).X((s) => Xr(t3, s, e2).next((t4) => (t4 && (n = true), At.resolve(!t4)))).next(() => n);
    }(t2, e);
  }
  removeOrphanedDocuments(t2, e) {
    const n = this.db.getRemoteDocumentCache().newChangeBuffer(), s = [];
    let i = 0;
    return this.Un(t2, (r, o) => {
      if (o <= e) {
        const e2 = this.Kn(t2, r).next((e3) => {
          if (!e3)
            return i++, n.getEntry(t2, r).next(() => (n.removeEntry(r, st.min()), uo(t2).delete([0, Bt(r.path)])));
        });
        s.push(e2);
      }
    }).next(() => At.waitFor(s)).next(() => n.apply(t2)).next(() => i);
  }
  removeTarget(t2, e) {
    const n = e.withSequenceNumber(t2.currentSequenceNumber);
    return this.db.getTargetCache().updateTargetData(t2, n);
  }
  updateLimboDocument(t2, e) {
    return wo(t2, e);
  }
  Un(t2, e) {
    const n = uo(t2);
    let s, i = Ot.ct;
    return n.Z({
      index: "documentTargetsIndex"
    }, ([t3, n2], { path: r, sequenceNumber: o }) => {
      0 === t3 ? (i !== Ot.ct && e(new ct(Ut(s)), i), i = o, s = r) : i = Ot.ct;
    }).next(() => {
      i !== Ot.ct && e(new ct(Ut(s)), i);
    });
  }
  getCacheSize(t2) {
    return this.db.getRemoteDocumentCache().getSize(t2);
  }
};
function wo(t2, e) {
  return uo(t2).put(
    function(t3, e2) {
      return {
        targetId: 0,
        path: Bt(t3.path),
        sequenceNumber: e2
      };
    }(e, t2.currentSequenceNumber)
  );
}
var _o = class {
  constructor() {
    this.changes = new ss((t2) => t2.toString(), (t2, e) => t2.isEqual(e)), this.changesApplied = false;
  }
  addEntry(t2) {
    this.assertNotApplied(), this.changes.set(t2.key, t2);
  }
  removeEntry(t2, e) {
    this.assertNotApplied(), this.changes.set(t2, on.newInvalidDocument(t2).setReadTime(e));
  }
  getEntry(t2, e) {
    this.assertNotApplied();
    const n = this.changes.get(e);
    return void 0 !== n ? At.resolve(n) : this.getFromCache(t2, e);
  }
  getEntries(t2, e) {
    return this.getAllFromCache(t2, e);
  }
  apply(t2) {
    return this.assertNotApplied(), this.changesApplied = true, this.applyChanges(t2);
  }
  assertNotApplied() {
  }
};
var mo = class {
  constructor(t2) {
    this.serializer = t2;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e, n) {
    return Io(t2).put(n);
  }
  removeEntry(t2, e, n) {
    return Io(t2).delete(
      function(t3, e2) {
        const n2 = t3.path.toArray();
        return [
          n2.slice(0, n2.length - 2),
          n2[n2.length - 2],
          ir(e2),
          n2[n2.length - 1]
        ];
      }(e, n)
    );
  }
  updateMetadata(t2, e) {
    return this.getMetadata(t2).next((n) => (n.byteSize += e, this.Gn(t2, n)));
  }
  getEntry(t2, e) {
    let n = on.newInvalidDocument(e);
    return Io(t2).Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(To(e))
    }, (t3, s) => {
      n = this.Qn(e, s);
    }).next(() => n);
  }
  zn(t2, e) {
    let n = {
      size: 0,
      document: on.newInvalidDocument(e)
    };
    return Io(t2).Z({
      index: "documentKeyIndex",
      range: IDBKeyRange.only(To(e))
    }, (t3, s) => {
      n = {
        document: this.Qn(e, s),
        size: Yr(s)
      };
    }).next(() => n);
  }
  getEntries(t2, e) {
    let n = rs();
    return this.jn(t2, e, (t3, e2) => {
      const s = this.Qn(t3, e2);
      n = n.insert(t3, s);
    }).next(() => n);
  }
  Wn(t2, e) {
    let n = rs(), s = new ge(ct.comparator);
    return this.jn(t2, e, (t3, e2) => {
      const i = this.Qn(t3, e2);
      n = n.insert(t3, i), s = s.insert(t3, Yr(e2));
    }).next(() => ({
      documents: n,
      Hn: s
    }));
  }
  jn(t2, e, n) {
    if (e.isEmpty())
      return At.resolve();
    let s = new Ie(Ao);
    e.forEach((t3) => s = s.add(t3));
    const i = IDBKeyRange.bound(To(s.first()), To(s.last())), r = s.getIterator();
    let o = r.getNext();
    return Io(t2).Z({
      index: "documentKeyIndex",
      range: i
    }, (t3, e2, s2) => {
      const i2 = ct.fromSegments([...e2.prefixPath, e2.collectionGroup, e2.documentId]);
      for (; o && Ao(o, i2) < 0; )
        n(o, null), o = r.getNext();
      o && o.isEqual(i2) && (n(o, e2), o = r.hasNext() ? r.getNext() : null), o ? s2.G(To(o)) : s2.done();
    }).next(() => {
      for (; o; )
        n(o, null), o = r.hasNext() ? r.getNext() : null;
    });
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    const i = e.path, r = [i.popLast().toArray(), i.lastSegment(), ir(n.readTime), n.documentKey.path.isEmpty() ? "" : n.documentKey.path.lastSegment()], o = [i.popLast().toArray(), i.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""];
    return Io(t2).j(IDBKeyRange.bound(r, o, true)).next((t3) => {
      let n2 = rs();
      for (const i2 of t3) {
        const t4 = this.Qn(ct.fromSegments(i2.prefixPath.concat(i2.collectionGroup, i2.documentId)), i2);
        t4.isFoundDocument() && (Xn(e, t4) || s.has(t4.key)) && (n2 = n2.insert(t4.key, t4));
      }
      return n2;
    });
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    let i = rs();
    const r = Eo(e, n), o = Eo(e, yt.max());
    return Io(t2).Z({
      index: "collectionGroupIndex",
      range: IDBKeyRange.bound(r, o, true)
    }, (t3, e2, n2) => {
      const r2 = this.Qn(ct.fromSegments(e2.prefixPath.concat(e2.collectionGroup, e2.documentId)), e2);
      i = i.insert(r2.key, r2), i.size === s && n2.done();
    }).next(() => i);
  }
  newChangeBuffer(t2) {
    return new yo(this, !!t2 && t2.trackRemovals);
  }
  getSize(t2) {
    return this.getMetadata(t2).next((t3) => t3.byteSize);
  }
  getMetadata(t2) {
    return po(t2).get("remoteDocumentGlobalKey").next((t3) => ($(!!t3), t3));
  }
  Gn(t2, e) {
    return po(t2).put("remoteDocumentGlobalKey", e);
  }
  Qn(t2, e) {
    if (e) {
      const t3 = nr(this.serializer, e);
      if (!(t3.isNoDocument() && t3.version.isEqual(st.min())))
        return t3;
    }
    return on.newInvalidDocument(t2);
  }
};
function go(t2) {
  return new mo(t2);
}
var yo = class extends _o {
  constructor(t2, e) {
    super(), this.Jn = t2, this.trackRemovals = e, this.Yn = new ss((t3) => t3.toString(), (t3, e2) => t3.isEqual(e2));
  }
  applyChanges(t2) {
    const e = [];
    let n = 0, s = new Ie((t3, e2) => X2(t3.canonicalString(), e2.canonicalString()));
    return this.changes.forEach((i, r) => {
      const o = this.Yn.get(i);
      if (e.push(this.Jn.removeEntry(t2, i, o.readTime)), r.isValidDocument()) {
        const u = sr(this.Jn.serializer, r);
        s = s.add(i.path.popLast());
        const c = Yr(u);
        n += c - o.size, e.push(this.Jn.addEntry(t2, i, u));
      } else if (n -= o.size, this.trackRemovals) {
        const n2 = sr(this.Jn.serializer, r.convertToNoDocument(st.min()));
        e.push(this.Jn.addEntry(t2, i, n2));
      }
    }), s.forEach((n2) => {
      e.push(this.Jn.indexManager.addToCollectionParentIndex(t2, n2));
    }), e.push(this.Jn.updateMetadata(t2, n)), At.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Jn.zn(t2, e).next((t3) => (this.Yn.set(e, {
      size: t3.size,
      readTime: t3.document.readTime
    }), t3.document));
  }
  getAllFromCache(t2, e) {
    return this.Jn.Wn(t2, e).next(({ documents: t3, Hn: e2 }) => (e2.forEach((e3, n) => {
      this.Yn.set(e3, {
        size: n,
        readTime: t3.get(e3).readTime
      });
    }), t3));
  }
};
function po(t2) {
  return de(t2, "remoteDocumentGlobal");
}
function Io(t2) {
  return de(t2, "remoteDocumentsV14");
}
function To(t2) {
  const e = t2.path.toArray();
  return [
    e.slice(0, e.length - 2),
    e[e.length - 2],
    e[e.length - 1]
  ];
}
function Eo(t2, e) {
  const n = e.documentKey.path.toArray();
  return [
    t2,
    ir(e.readTime),
    n.slice(0, n.length - 2),
    n.length > 0 ? n[n.length - 1] : ""
  ];
}
function Ao(t2, e) {
  const n = t2.path.toArray(), s = e.path.toArray();
  let i = 0;
  for (let t3 = 0; t3 < n.length - 2 && t3 < s.length - 2; ++t3)
    if (i = X2(n[t3], s[t3]), i)
      return i;
  return i = X2(n.length, s.length), i || (i = X2(n[n.length - 2], s[s.length - 2]), i || X2(n[n.length - 1], s[s.length - 1]));
}
var Ro = class {
  constructor(t2, e) {
    this.overlayedDocument = t2, this.mutatedFields = e;
  }
};
var vo = class {
  constructor(t2, e, n, s) {
    this.remoteDocumentCache = t2, this.mutationQueue = e, this.documentOverlayCache = n, this.indexManager = s;
  }
  getDocument(t2, e) {
    let n = null;
    return this.documentOverlayCache.getOverlay(t2, e).next((s) => (n = s, this.remoteDocumentCache.getEntry(t2, e))).next((t3) => (null !== n && Ls(n.mutation, t3, Ae.empty(), nt.now()), t3));
  }
  getDocuments(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.getLocalViewOfDocuments(t2, e2, ws()).next(() => e2));
  }
  getLocalViewOfDocuments(t2, e, n = ws()) {
    const s = as();
    return this.populateOverlays(t2, s, e).next(() => this.computeViews(t2, e, s, n).next((t3) => {
      let e2 = us();
      return t3.forEach((t4, n2) => {
        e2 = e2.insert(t4, n2.overlayedDocument);
      }), e2;
    }));
  }
  getOverlayedDocuments(t2, e) {
    const n = as();
    return this.populateOverlays(t2, n, e).next(() => this.computeViews(t2, e, n, ws()));
  }
  populateOverlays(t2, e, n) {
    const s = [];
    return n.forEach((t3) => {
      e.has(t3) || s.push(t3);
    }), this.documentOverlayCache.getOverlays(t2, s).next((t3) => {
      t3.forEach((t4, n2) => {
        e.set(t4, n2);
      });
    });
  }
  computeViews(t2, e, n, s) {
    let i = rs();
    const r = ls(), o = ls();
    return e.forEach((t3, e2) => {
      const o2 = n.get(e2.key);
      s.has(e2.key) && (void 0 === o2 || o2.mutation instanceof Gs) ? i = i.insert(e2.key, e2) : void 0 !== o2 ? (r.set(e2.key, o2.mutation.getFieldMask()), Ls(o2.mutation, e2, o2.mutation.getFieldMask(), nt.now())) : r.set(e2.key, Ae.empty());
    }), this.recalculateAndSaveOverlays(t2, i).next((t3) => (t3.forEach((t4, e2) => r.set(t4, e2)), e.forEach((t4, e2) => {
      var n2;
      return o.set(t4, new Ro(e2, null !== (n2 = r.get(t4)) && void 0 !== n2 ? n2 : null));
    }), o));
  }
  recalculateAndSaveOverlays(t2, e) {
    const n = ls();
    let s = new ge((t3, e2) => t3 - e2), i = ws();
    return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(t2, e).next((t3) => {
      for (const i2 of t3)
        i2.keys().forEach((t4) => {
          const r = e.get(t4);
          if (null === r)
            return;
          let o = n.get(t4) || Ae.empty();
          o = i2.applyToLocalView(r, o), n.set(t4, o);
          const u = (s.get(i2.batchId) || ws()).add(t4);
          s = s.insert(i2.batchId, u);
        });
    }).next(() => {
      const r = [], o = s.getReverseIterator();
      for (; o.hasNext(); ) {
        const s2 = o.getNext(), u = s2.key, c = s2.value, a = hs();
        c.forEach((t3) => {
          if (!i.has(t3)) {
            const s3 = Fs(e.get(t3), n.get(t3));
            null !== s3 && a.set(t3, s3), i = i.add(t3);
          }
        }), r.push(this.documentOverlayCache.saveOverlays(t2, u, a));
      }
      return At.waitFor(r);
    }).next(() => n);
  }
  recalculateAndSaveOverlaysForDocumentKeys(t2, e) {
    return this.remoteDocumentCache.getEntries(t2, e).next((e2) => this.recalculateAndSaveOverlays(t2, e2));
  }
  getDocumentsMatchingQuery(t2, e, n) {
    return function(t3) {
      return ct.isDocumentKey(t3.path) && null === t3.collectionGroup && 0 === t3.filters.length;
    }(e) ? this.getDocumentsMatchingDocumentQuery(t2, e.path) : Qn(e) ? this.getDocumentsMatchingCollectionGroupQuery(t2, e, n) : this.getDocumentsMatchingCollectionQuery(t2, e, n);
  }
  getNextDocuments(t2, e, n, s) {
    return this.remoteDocumentCache.getAllFromCollectionGroup(t2, e, n, s).next((i) => {
      const r = s - i.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(t2, e, n.largestBatchId, s - i.size) : At.resolve(as());
      let o = -1, u = i;
      return r.next((e2) => At.forEach(e2, (e3, n2) => (o < n2.largestBatchId && (o = n2.largestBatchId), i.get(e3) ? At.resolve() : this.remoteDocumentCache.getEntry(t2, e3).next((t3) => {
        u = u.insert(e3, t3);
      }))).next(() => this.populateOverlays(t2, e2, i)).next(() => this.computeViews(t2, u, e2, ws())).next((t3) => ({
        batchId: o,
        changes: cs(t3)
      })));
    });
  }
  getDocumentsMatchingDocumentQuery(t2, e) {
    return this.getDocument(t2, new ct(e)).next((t3) => {
      let e2 = us();
      return t3.isFoundDocument() && (e2 = e2.insert(t3.key, t3)), e2;
    });
  }
  getDocumentsMatchingCollectionGroupQuery(t2, e, n) {
    const s = e.collectionGroup;
    let i = us();
    return this.indexManager.getCollectionParents(t2, s).next((r) => At.forEach(r, (r2) => {
      const o = function(t3, e2) {
        return new Bn(
          e2,
          null,
          t3.explicitOrderBy.slice(),
          t3.filters.slice(),
          t3.limit,
          t3.limitType,
          t3.startAt,
          t3.endAt
        );
      }(e, r2.child(s));
      return this.getDocumentsMatchingCollectionQuery(t2, o, n).next((t3) => {
        t3.forEach((t4, e2) => {
          i = i.insert(t4, e2);
        });
      });
    }).next(() => i));
  }
  getDocumentsMatchingCollectionQuery(t2, e, n) {
    let s;
    return this.documentOverlayCache.getOverlaysForCollection(t2, e.path, n.largestBatchId).next((i) => (s = i, this.remoteDocumentCache.getDocumentsMatchingQuery(t2, e, n, s))).next((t3) => {
      s.forEach((e2, n3) => {
        const s2 = n3.getKey();
        null === t3.get(s2) && (t3 = t3.insert(s2, on.newInvalidDocument(s2)));
      });
      let n2 = us();
      return t3.forEach((t4, i) => {
        const r = s.get(t4);
        void 0 !== r && Ls(r.mutation, i, Ae.empty(), nt.now()), Xn(e, i) && (n2 = n2.insert(t4, i));
      }), n2;
    });
  }
};
var bo = class {
  constructor(t2) {
    this.serializer = t2, this.Zn = /* @__PURE__ */ new Map(), this.Xn = /* @__PURE__ */ new Map();
  }
  getBundleMetadata(t2, e) {
    return At.resolve(this.Zn.get(e));
  }
  saveBundleMetadata(t2, e) {
    var n;
    return this.Zn.set(e.id, {
      id: (n = e).id,
      version: n.version,
      createTime: vi(n.createTime)
    }), At.resolve();
  }
  getNamedQuery(t2, e) {
    return At.resolve(this.Xn.get(e));
  }
  saveNamedQuery(t2, e) {
    return this.Xn.set(e.name, function(t3) {
      return {
        name: t3.name,
        query: hr(t3.bundledQuery),
        readTime: vi(t3.readTime)
      };
    }(e)), At.resolve();
  }
};
var Po = class {
  constructor() {
    this.overlays = new ge(ct.comparator), this.ts = /* @__PURE__ */ new Map();
  }
  getOverlay(t2, e) {
    return At.resolve(this.overlays.get(e));
  }
  getOverlays(t2, e) {
    const n = as();
    return At.forEach(e, (e2) => this.getOverlay(t2, e2).next((t3) => {
      null !== t3 && n.set(e2, t3);
    })).next(() => n);
  }
  saveOverlays(t2, e, n) {
    return n.forEach((n2, s) => {
      this.re(t2, e, s);
    }), At.resolve();
  }
  removeOverlaysForBatchId(t2, e, n) {
    const s = this.ts.get(n);
    return void 0 !== s && (s.forEach((t3) => this.overlays = this.overlays.remove(t3)), this.ts.delete(n)), At.resolve();
  }
  getOverlaysForCollection(t2, e, n) {
    const s = as(), i = e.length + 1, r = new ct(e.child("")), o = this.overlays.getIteratorFrom(r);
    for (; o.hasNext(); ) {
      const t3 = o.getNext().value, r2 = t3.getKey();
      if (!e.isPrefixOf(r2.path))
        break;
      r2.path.length === i && (t3.largestBatchId > n && s.set(t3.getKey(), t3));
    }
    return At.resolve(s);
  }
  getOverlaysForCollectionGroup(t2, e, n, s) {
    let i = new ge((t3, e2) => t3 - e2);
    const r = this.overlays.getIterator();
    for (; r.hasNext(); ) {
      const t3 = r.getNext().value;
      if (t3.getKey().getCollectionGroup() === e && t3.largestBatchId > n) {
        let e2 = i.get(t3.largestBatchId);
        null === e2 && (e2 = as(), i = i.insert(t3.largestBatchId, e2)), e2.set(t3.getKey(), t3);
      }
    }
    const o = as(), u = i.getIterator();
    for (; u.hasNext(); ) {
      if (u.getNext().value.forEach((t3, e2) => o.set(t3, e2)), o.size() >= s)
        break;
    }
    return At.resolve(o);
  }
  re(t2, e, n) {
    const s = this.overlays.get(n.key);
    if (null !== s) {
      const t3 = this.ts.get(s.largestBatchId).delete(n.key);
      this.ts.set(s.largestBatchId, t3);
    }
    this.overlays = this.overlays.insert(n.key, new Zs(e, n));
    let i = this.ts.get(e);
    void 0 === i && (i = ws(), this.ts.set(e, i)), this.ts.set(e, i.add(n.key));
  }
};
var Vo = class {
  constructor() {
    this.es = new Ie(So.ns), this.ss = new Ie(So.rs);
  }
  isEmpty() {
    return this.es.isEmpty();
  }
  addReference(t2, e) {
    const n = new So(t2, e);
    this.es = this.es.add(n), this.ss = this.ss.add(n);
  }
  os(t2, e) {
    t2.forEach((t3) => this.addReference(t3, e));
  }
  removeReference(t2, e) {
    this.us(new So(t2, e));
  }
  cs(t2, e) {
    t2.forEach((t3) => this.removeReference(t3, e));
  }
  hs(t2) {
    const e = new ct(new rt([])), n = new So(e, t2), s = new So(e, t2 + 1), i = [];
    return this.ss.forEachInRange([n, s], (t3) => {
      this.us(t3), i.push(t3.key);
    }), i;
  }
  ls() {
    this.es.forEach((t2) => this.us(t2));
  }
  us(t2) {
    this.es = this.es.delete(t2), this.ss = this.ss.delete(t2);
  }
  fs(t2) {
    const e = new ct(new rt([])), n = new So(e, t2), s = new So(e, t2 + 1);
    let i = ws();
    return this.ss.forEachInRange([n, s], (t3) => {
      i = i.add(t3.key);
    }), i;
  }
  containsKey(t2) {
    const e = new So(t2, 0), n = this.es.firstAfterOrEqual(e);
    return null !== n && t2.isEqual(n.key);
  }
};
var So = class {
  constructor(t2, e) {
    this.key = t2, this.ds = e;
  }
  static ns(t2, e) {
    return ct.comparator(t2.key, e.key) || X2(t2.ds, e.ds);
  }
  static rs(t2, e) {
    return X2(t2.ds, e.ds) || ct.comparator(t2.key, e.key);
  }
};
var Do = class {
  constructor(t2, e) {
    this.indexManager = t2, this.referenceDelegate = e, this.mutationQueue = [], this.ws = 1, this._s = new Ie(So.ns);
  }
  checkEmpty(t2) {
    return At.resolve(0 === this.mutationQueue.length);
  }
  addMutationBatch(t2, e, n, s) {
    const i = this.ws;
    this.ws++, this.mutationQueue.length > 0 && this.mutationQueue[this.mutationQueue.length - 1];
    const r = new Js(i, e, n, s);
    this.mutationQueue.push(r);
    for (const e2 of s)
      this._s = this._s.add(new So(e2.key, i)), this.indexManager.addToCollectionParentIndex(t2, e2.key.path.popLast());
    return At.resolve(r);
  }
  lookupMutationBatch(t2, e) {
    return At.resolve(this.gs(e));
  }
  getNextMutationBatchAfterBatchId(t2, e) {
    const n = e + 1, s = this.ys(n), i = s < 0 ? 0 : s;
    return At.resolve(this.mutationQueue.length > i ? this.mutationQueue[i] : null);
  }
  getHighestUnacknowledgedBatchId() {
    return At.resolve(0 === this.mutationQueue.length ? -1 : this.ws - 1);
  }
  getAllMutationBatches(t2) {
    return At.resolve(this.mutationQueue.slice());
  }
  getAllMutationBatchesAffectingDocumentKey(t2, e) {
    const n = new So(e, 0), s = new So(e, Number.POSITIVE_INFINITY), i = [];
    return this._s.forEachInRange([n, s], (t3) => {
      const e2 = this.gs(t3.ds);
      i.push(e2);
    }), At.resolve(i);
  }
  getAllMutationBatchesAffectingDocumentKeys(t2, e) {
    let n = new Ie(X2);
    return e.forEach((t3) => {
      const e2 = new So(t3, 0), s = new So(t3, Number.POSITIVE_INFINITY);
      this._s.forEachInRange([e2, s], (t4) => {
        n = n.add(t4.ds);
      });
    }), At.resolve(this.ps(n));
  }
  getAllMutationBatchesAffectingQuery(t2, e) {
    const n = e.path, s = n.length + 1;
    let i = n;
    ct.isDocumentKey(i) || (i = i.child(""));
    const r = new So(new ct(i), 0);
    let o = new Ie(X2);
    return this._s.forEachWhile((t3) => {
      const e2 = t3.key.path;
      return !!n.isPrefixOf(e2) && (e2.length === s && (o = o.add(t3.ds)), true);
    }, r), At.resolve(this.ps(o));
  }
  ps(t2) {
    const e = [];
    return t2.forEach((t3) => {
      const n = this.gs(t3);
      null !== n && e.push(n);
    }), e;
  }
  removeMutationBatch(t2, e) {
    $(0 === this.Is(e.batchId, "removed")), this.mutationQueue.shift();
    let n = this._s;
    return At.forEach(e.mutations, (s) => {
      const i = new So(s.key, e.batchId);
      return n = n.delete(i), this.referenceDelegate.markPotentiallyOrphaned(t2, s.key);
    }).next(() => {
      this._s = n;
    });
  }
  En(t2) {
  }
  containsKey(t2, e) {
    const n = new So(e, 0), s = this._s.firstAfterOrEqual(n);
    return At.resolve(e.isEqual(s && s.key));
  }
  performConsistencyCheck(t2) {
    return this.mutationQueue.length, At.resolve();
  }
  Is(t2, e) {
    return this.ys(t2);
  }
  ys(t2) {
    if (0 === this.mutationQueue.length)
      return 0;
    return t2 - this.mutationQueue[0].batchId;
  }
  gs(t2) {
    const e = this.ys(t2);
    if (e < 0 || e >= this.mutationQueue.length)
      return null;
    return this.mutationQueue[e];
  }
};
var Co = class {
  constructor(t2) {
    this.Ts = t2, this.docs = new ge(ct.comparator), this.size = 0;
  }
  setIndexManager(t2) {
    this.indexManager = t2;
  }
  addEntry(t2, e) {
    const n = e.key, s = this.docs.get(n), i = s ? s.size : 0, r = this.Ts(e);
    return this.docs = this.docs.insert(n, {
      document: e.mutableCopy(),
      size: r
    }), this.size += r - i, this.indexManager.addToCollectionParentIndex(t2, n.path.popLast());
  }
  removeEntry(t2) {
    const e = this.docs.get(t2);
    e && (this.docs = this.docs.remove(t2), this.size -= e.size);
  }
  getEntry(t2, e) {
    const n = this.docs.get(e);
    return At.resolve(n ? n.document.mutableCopy() : on.newInvalidDocument(e));
  }
  getEntries(t2, e) {
    let n = rs();
    return e.forEach((t3) => {
      const e2 = this.docs.get(t3);
      n = n.insert(t3, e2 ? e2.document.mutableCopy() : on.newInvalidDocument(t3));
    }), At.resolve(n);
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    let i = rs();
    const r = e.path, o = new ct(r.child("")), u = this.docs.getIteratorFrom(o);
    for (; u.hasNext(); ) {
      const { key: t3, value: { document: o2 } } = u.getNext();
      if (!r.isPrefixOf(t3.path))
        break;
      t3.path.length > r.length + 1 || (pt(gt(o2), n) <= 0 || (s.has(o2.key) || Xn(e, o2)) && (i = i.insert(o2.key, o2.mutableCopy())));
    }
    return At.resolve(i);
  }
  getAllFromCollectionGroup(t2, e, n, s) {
    O2();
  }
  Es(t2, e) {
    return At.forEach(this.docs, (t3) => e(t3));
  }
  newChangeBuffer(t2) {
    return new xo(this);
  }
  getSize(t2) {
    return At.resolve(this.size);
  }
};
var xo = class extends _o {
  constructor(t2) {
    super(), this.Jn = t2;
  }
  applyChanges(t2) {
    const e = [];
    return this.changes.forEach((n, s) => {
      s.isValidDocument() ? e.push(this.Jn.addEntry(t2, s)) : this.Jn.removeEntry(n);
    }), At.waitFor(e);
  }
  getFromCache(t2, e) {
    return this.Jn.getEntry(t2, e);
  }
  getAllFromCache(t2, e) {
    return this.Jn.getEntries(t2, e);
  }
};
var No = class {
  constructor(t2) {
    this.persistence = t2, this.As = new ss((t3) => Nn(t3), kn), this.lastRemoteSnapshotVersion = st.min(), this.highestTargetId = 0, this.Rs = 0, this.vs = new Vo(), this.targetCount = 0, this.bs = so.vn();
  }
  forEachTarget(t2, e) {
    return this.As.forEach((t3, n) => e(n)), At.resolve();
  }
  getLastRemoteSnapshotVersion(t2) {
    return At.resolve(this.lastRemoteSnapshotVersion);
  }
  getHighestSequenceNumber(t2) {
    return At.resolve(this.Rs);
  }
  allocateTargetId(t2) {
    return this.highestTargetId = this.bs.next(), At.resolve(this.highestTargetId);
  }
  setTargetsMetadata(t2, e, n) {
    return n && (this.lastRemoteSnapshotVersion = n), e > this.Rs && (this.Rs = e), At.resolve();
  }
  Sn(t2) {
    this.As.set(t2.target, t2);
    const e = t2.targetId;
    e > this.highestTargetId && (this.bs = new so(e), this.highestTargetId = e), t2.sequenceNumber > this.Rs && (this.Rs = t2.sequenceNumber);
  }
  addTargetData(t2, e) {
    return this.Sn(e), this.targetCount += 1, At.resolve();
  }
  updateTargetData(t2, e) {
    return this.Sn(e), At.resolve();
  }
  removeTargetData(t2, e) {
    return this.As.delete(e.target), this.vs.hs(e.targetId), this.targetCount -= 1, At.resolve();
  }
  removeTargets(t2, e, n) {
    let s = 0;
    const i = [];
    return this.As.forEach((r, o) => {
      o.sequenceNumber <= e && null === n.get(o.targetId) && (this.As.delete(r), i.push(this.removeMatchingKeysForTargetId(t2, o.targetId)), s++);
    }), At.waitFor(i).next(() => s);
  }
  getTargetCount(t2) {
    return At.resolve(this.targetCount);
  }
  getTargetData(t2, e) {
    const n = this.As.get(e) || null;
    return At.resolve(n);
  }
  addMatchingKeys(t2, e, n) {
    return this.vs.os(e, n), At.resolve();
  }
  removeMatchingKeys(t2, e, n) {
    this.vs.cs(e, n);
    const s = this.persistence.referenceDelegate, i = [];
    return s && e.forEach((e2) => {
      i.push(s.markPotentiallyOrphaned(t2, e2));
    }), At.waitFor(i);
  }
  removeMatchingKeysForTargetId(t2, e) {
    return this.vs.hs(e), At.resolve();
  }
  getMatchingKeysForTargetId(t2, e) {
    const n = this.vs.fs(e);
    return At.resolve(n);
  }
  containsKey(t2, e) {
    return At.resolve(this.vs.containsKey(e));
  }
};
var ko = class {
  constructor(t2, e) {
    this.Ps = {}, this.overlays = {}, this.Vs = new Ot(0), this.Ss = false, this.Ss = true, this.referenceDelegate = t2(this), this.Ds = new No(this);
    this.indexManager = new Br(), this.remoteDocumentCache = function(t3) {
      return new Co(t3);
    }((t3) => this.referenceDelegate.Cs(t3)), this.serializer = new er(e), this.xs = new bo(this.serializer);
  }
  start() {
    return Promise.resolve();
  }
  shutdown() {
    return this.Ss = false, Promise.resolve();
  }
  get started() {
    return this.Ss;
  }
  setDatabaseDeletedListener() {
  }
  setNetworkEnabled() {
  }
  getIndexManager(t2) {
    return this.indexManager;
  }
  getDocumentOverlayCache(t2) {
    let e = this.overlays[t2.toKey()];
    return e || (e = new Po(), this.overlays[t2.toKey()] = e), e;
  }
  getMutationQueue(t2, e) {
    let n = this.Ps[t2.toKey()];
    return n || (n = new Do(e, this.referenceDelegate), this.Ps[t2.toKey()] = n), n;
  }
  getTargetCache() {
    return this.Ds;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getBundleCache() {
    return this.xs;
  }
  runTransaction(t2, e, n) {
    C2("MemoryPersistence", "Starting transaction:", t2);
    const s = new Oo(this.Vs.next());
    return this.referenceDelegate.Ns(), n(s).next((t3) => this.referenceDelegate.ks(s).next(() => t3)).toPromise().then((t3) => (s.raiseOnCommittedEvent(), t3));
  }
  Os(t2, e) {
    return At.or(Object.values(this.Ps).map((n) => () => n.containsKey(t2, e)));
  }
};
var Oo = class extends Tt {
  constructor(t2) {
    super(), this.currentSequenceNumber = t2;
  }
};
var $o = class {
  constructor(t2) {
    this.persistence = t2, this.$s = new Vo(), this.Ms = null;
  }
  static Fs(t2) {
    return new $o(t2);
  }
  get Bs() {
    if (this.Ms)
      return this.Ms;
    throw O2();
  }
  addReference(t2, e, n) {
    return this.$s.addReference(n, e), this.Bs.delete(n.toString()), At.resolve();
  }
  removeReference(t2, e, n) {
    return this.$s.removeReference(n, e), this.Bs.add(n.toString()), At.resolve();
  }
  markPotentiallyOrphaned(t2, e) {
    return this.Bs.add(e.toString()), At.resolve();
  }
  removeTarget(t2, e) {
    this.$s.hs(e.targetId).forEach((t3) => this.Bs.add(t3.toString()));
    const n = this.persistence.getTargetCache();
    return n.getMatchingKeysForTargetId(t2, e.targetId).next((t3) => {
      t3.forEach((t4) => this.Bs.add(t4.toString()));
    }).next(() => n.removeTargetData(t2, e));
  }
  Ns() {
    this.Ms = /* @__PURE__ */ new Set();
  }
  ks(t2) {
    const e = this.persistence.getRemoteDocumentCache().newChangeBuffer();
    return At.forEach(this.Bs, (n) => {
      const s = ct.fromPath(n);
      return this.Ls(t2, s).next((t3) => {
        t3 || e.removeEntry(s, st.min());
      });
    }).next(() => (this.Ms = null, e.apply(t2)));
  }
  updateLimboDocument(t2, e) {
    return this.Ls(t2, e).next((t3) => {
      t3 ? this.Bs.delete(e.toString()) : this.Bs.add(e.toString());
    });
  }
  Cs(t2) {
    return 0;
  }
  Ls(t2, e) {
    return At.or([() => At.resolve(this.$s.containsKey(e)), () => this.persistence.getTargetCache().containsKey(t2, e), () => this.persistence.Os(t2, e)]);
  }
};
var Mo = class {
  constructor(t2) {
    this.serializer = t2;
  }
  M(t2, e, n, s) {
    const i = new Rt("createOrUpgrade", e);
    n < 1 && s >= 1 && (function(t3) {
      t3.createObjectStore("owner");
    }(t2), function(t3) {
      t3.createObjectStore("mutationQueues", {
        keyPath: "userId"
      });
      t3.createObjectStore("mutations", {
        keyPath: "batchId",
        autoIncrement: true
      }).createIndex("userMutationsIndex", Kt, {
        unique: true
      }), t3.createObjectStore("documentMutations");
    }(t2), Fo(t2), function(t3) {
      t3.createObjectStore("remoteDocuments");
    }(t2));
    let r = At.resolve();
    return n < 3 && s >= 3 && (0 !== n && (!function(t3) {
      t3.deleteObjectStore("targetDocuments"), t3.deleteObjectStore("targets"), t3.deleteObjectStore("targetGlobal");
    }(t2), Fo(t2)), r = r.next(() => function(t3) {
      const e2 = t3.store("targetGlobal"), n2 = {
        highestTargetId: 0,
        highestListenSequenceNumber: 0,
        lastRemoteSnapshotVersion: st.min().toTimestamp(),
        targetCount: 0
      };
      return e2.put("targetGlobalKey", n2);
    }(i))), n < 4 && s >= 4 && (0 !== n && (r = r.next(() => function(t3, e2) {
      return e2.store("mutations").j().next((n2) => {
        t3.deleteObjectStore("mutations");
        t3.createObjectStore("mutations", {
          keyPath: "batchId",
          autoIncrement: true
        }).createIndex("userMutationsIndex", Kt, {
          unique: true
        });
        const s2 = e2.store("mutations"), i2 = n2.map((t4) => s2.put(t4));
        return At.waitFor(i2);
      });
    }(t2, i))), r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("clientMetadata", {
          keyPath: "clientId"
        });
      }(t2);
    })), n < 5 && s >= 5 && (r = r.next(() => this.qs(i))), n < 6 && s >= 6 && (r = r.next(() => (function(t3) {
      t3.createObjectStore("remoteDocumentGlobal");
    }(t2), this.Us(i)))), n < 7 && s >= 7 && (r = r.next(() => this.Ks(i))), n < 8 && s >= 8 && (r = r.next(() => this.Gs(t2, i))), n < 9 && s >= 9 && (r = r.next(() => {
      !function(t3) {
        t3.objectStoreNames.contains("remoteDocumentChanges") && t3.deleteObjectStore("remoteDocumentChanges");
      }(t2);
    })), n < 10 && s >= 10 && (r = r.next(() => this.Qs(i))), n < 11 && s >= 11 && (r = r.next(() => {
      !function(t3) {
        t3.createObjectStore("bundles", {
          keyPath: "bundleId"
        });
      }(t2), function(t3) {
        t3.createObjectStore("namedQueries", {
          keyPath: "name"
        });
      }(t2);
    })), n < 12 && s >= 12 && (r = r.next(() => {
      !function(t3) {
        const e2 = t3.createObjectStore("documentOverlays", {
          keyPath: ie
        });
        e2.createIndex("collectionPathOverlayIndex", re, {
          unique: false
        }), e2.createIndex("collectionGroupOverlayIndex", oe, {
          unique: false
        });
      }(t2);
    })), n < 13 && s >= 13 && (r = r.next(() => function(t3) {
      const e2 = t3.createObjectStore("remoteDocumentsV14", {
        keyPath: jt
      });
      e2.createIndex("documentKeyIndex", Wt), e2.createIndex("collectionGroupIndex", Ht);
    }(t2)).next(() => this.zs(t2, i)).next(() => t2.deleteObjectStore("remoteDocuments"))), n < 14 && s >= 14 && (r = r.next(() => this.js(t2, i))), n < 15 && s >= 15 && (r = r.next(() => function(t3) {
      t3.createObjectStore("indexConfiguration", {
        keyPath: "indexId",
        autoIncrement: true
      }).createIndex("collectionGroupIndex", "collectionGroup", {
        unique: false
      });
      t3.createObjectStore("indexState", {
        keyPath: te
      }).createIndex("sequenceNumberIndex", ee, {
        unique: false
      });
      t3.createObjectStore("indexEntries", {
        keyPath: ne
      }).createIndex("documentKeyIndex", se, {
        unique: false
      });
    }(t2))), r;
  }
  Us(t2) {
    let e = 0;
    return t2.store("remoteDocuments").Z((t3, n) => {
      e += Yr(n);
    }).next(() => {
      const n = {
        byteSize: e
      };
      return t2.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", n);
    });
  }
  qs(t2) {
    const e = t2.store("mutationQueues"), n = t2.store("mutations");
    return e.j().next((e2) => At.forEach(e2, (e3) => {
      const s = IDBKeyRange.bound([e3.userId, -1], [e3.userId, e3.lastAcknowledgedBatchId]);
      return n.j("userMutationsIndex", s).next((n2) => At.forEach(n2, (n3) => {
        $(n3.userId === e3.userId);
        const s2 = ur(this.serializer, n3);
        return Jr(t2, e3.userId, s2).next(() => {
        });
      }));
    }));
  }
  Ks(t2) {
    const e = t2.store("targetDocuments"), n = t2.store("remoteDocuments");
    return t2.store("targetGlobal").get("targetGlobalKey").next((t3) => {
      const s = [];
      return n.Z((n2, i) => {
        const r = new rt(n2), o = function(t4) {
          return [0, Bt(t4)];
        }(r);
        s.push(e.get(o).next((n3) => n3 ? At.resolve() : ((n4) => e.put({
          targetId: 0,
          path: Bt(n4),
          sequenceNumber: t3.highestListenSequenceNumber
        }))(r)));
      }).next(() => At.waitFor(s));
    });
  }
  Gs(t2, e) {
    t2.createObjectStore("collectionParents", {
      keyPath: Xt
    });
    const n = e.store("collectionParents"), s = new Lr(), i = (t3) => {
      if (s.add(t3)) {
        const e2 = t3.lastSegment(), s2 = t3.popLast();
        return n.put({
          collectionId: e2,
          parent: Bt(s2)
        });
      }
    };
    return e.store("remoteDocuments").Z({
      Y: true
    }, (t3, e2) => {
      const n2 = new rt(t3);
      return i(n2.popLast());
    }).next(() => e.store("documentMutations").Z({
      Y: true
    }, ([t3, e2, n2], s2) => {
      const r = Ut(e2);
      return i(r.popLast());
    }));
  }
  Qs(t2) {
    const e = t2.store("targets");
    return e.Z((t3, n) => {
      const s = cr(n), i = ar(this.serializer, s);
      return e.put(i);
    });
  }
  zs(t2, e) {
    const n = e.store("remoteDocuments"), s = [];
    return n.Z((t3, n2) => {
      const i = e.store("remoteDocumentsV14"), r = (o = n2, o.document ? new ct(rt.fromString(o.document.name).popFirst(5)) : o.noDocument ? ct.fromSegments(o.noDocument.path) : o.unknownDocument ? ct.fromSegments(o.unknownDocument.path) : O2()).path.toArray();
      var o;
      const u = {
        prefixPath: r.slice(0, r.length - 2),
        collectionGroup: r[r.length - 2],
        documentId: r[r.length - 1],
        readTime: n2.readTime || [0, 0],
        unknownDocument: n2.unknownDocument,
        noDocument: n2.noDocument,
        document: n2.document,
        hasCommittedMutations: !!n2.hasCommittedMutations
      };
      s.push(i.put(u));
    }).next(() => At.waitFor(s));
  }
  js(t2, e) {
    const n = e.store("mutations"), s = go(this.serializer), i = new ko($o.Fs, this.serializer.se);
    return n.j().next((t3) => {
      const n2 = /* @__PURE__ */ new Map();
      return t3.forEach((t4) => {
        var e2;
        let s2 = null !== (e2 = n2.get(t4.userId)) && void 0 !== e2 ? e2 : ws();
        ur(this.serializer, t4).keys().forEach((t5) => s2 = s2.add(t5)), n2.set(t4.userId, s2);
      }), At.forEach(n2, (t4, n3) => {
        const r = new b(n3), o = gr.ie(this.serializer, r), u = i.getIndexManager(r), c = Zr.ie(r, this.serializer, u, i.referenceDelegate);
        return new vo(s, c, o, u).recalculateAndSaveOverlaysForDocumentKeys(new fe(e, Ot.ct), t4).next();
      });
    });
  }
};
function Fo(t2) {
  t2.createObjectStore("targetDocuments", {
    keyPath: Yt
  }).createIndex("documentTargetsIndex", Zt, {
    unique: true
  });
  t2.createObjectStore("targets", {
    keyPath: "targetId"
  }).createIndex("queryTargetsIndex", Jt, {
    unique: true
  }), t2.createObjectStore("targetGlobal");
}
var Bo = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time.";
var Lo = class {
  constructor(t2, e, n, s, i, r, o, u, c, a, h = 15) {
    if (this.allowTabSynchronization = t2, this.persistenceKey = e, this.clientId = n, this.Ws = i, this.window = r, this.document = o, this.Hs = c, this.Js = a, this.Ys = h, this.Vs = null, this.Ss = false, this.isPrimary = false, this.networkEnabled = true, this.Zs = null, this.inForeground = false, this.Xs = null, this.ti = null, this.ei = Number.NEGATIVE_INFINITY, this.ni = (t3) => Promise.resolve(), !Lo.D())
      throw new L2(B2.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled.");
    this.referenceDelegate = new fo(this, s), this.si = e + "main", this.serializer = new er(u), this.ii = new vt(this.si, this.Ys, new Mo(this.serializer)), this.Ds = new io(this.referenceDelegate, this.serializer), this.remoteDocumentCache = go(this.serializer), this.xs = new wr(), this.window && this.window.localStorage ? this.ri = this.window.localStorage : (this.ri = null, false === a && x2("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page."));
  }
  start() {
    return this.oi().then(() => {
      if (!this.isPrimary && !this.allowTabSynchronization)
        throw new L2(B2.FAILED_PRECONDITION, Bo);
      return this.ui(), this.ci(), this.ai(), this.runTransaction("getHighestListenSequenceNumber", "readonly", (t2) => this.Ds.getHighestSequenceNumber(t2));
    }).then((t2) => {
      this.Vs = new Ot(t2, this.Hs);
    }).then(() => {
      this.Ss = true;
    }).catch((t2) => (this.ii && this.ii.close(), Promise.reject(t2)));
  }
  hi(t2) {
    return this.ni = async (e) => {
      if (this.started)
        return t2(e);
    }, t2(this.isPrimary);
  }
  setDatabaseDeletedListener(t2) {
    this.ii.B(async (e) => {
      null === e.newVersion && await t2();
    });
  }
  setNetworkEnabled(t2) {
    this.networkEnabled !== t2 && (this.networkEnabled = t2, this.Ws.enqueueAndForget(async () => {
      this.started && await this.oi();
    }));
  }
  oi() {
    return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", (t2) => Uo(t2).put({
      clientId: this.clientId,
      updateTimeMs: Date.now(),
      networkEnabled: this.networkEnabled,
      inForeground: this.inForeground
    }).next(() => {
      if (this.isPrimary)
        return this.li(t2).next((t3) => {
          t3 || (this.isPrimary = false, this.Ws.enqueueRetryable(() => this.ni(false)));
        });
    }).next(() => this.fi(t2)).next((e) => this.isPrimary && !e ? this.di(t2).next(() => false) : !!e && this.wi(t2).next(() => true))).catch((t2) => {
      if (Vt(t2))
        return C2("IndexedDbPersistence", "Failed to extend owner lease: ", t2), this.isPrimary;
      if (!this.allowTabSynchronization)
        throw t2;
      return C2("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", t2), false;
    }).then((t2) => {
      this.isPrimary !== t2 && this.Ws.enqueueRetryable(() => this.ni(t2)), this.isPrimary = t2;
    });
  }
  li(t2) {
    return qo(t2).get("owner").next((t3) => At.resolve(this._i(t3)));
  }
  mi(t2) {
    return Uo(t2).delete(this.clientId);
  }
  async gi() {
    if (this.isPrimary && !this.yi(this.ei, 18e5)) {
      this.ei = Date.now();
      const t2 = await this.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", (t3) => {
        const e = de(t3, "clientMetadata");
        return e.j().next((t4) => {
          const n = this.pi(t4, 18e5), s = t4.filter((t5) => -1 === n.indexOf(t5));
          return At.forEach(s, (t5) => e.delete(t5.clientId)).next(() => s);
        });
      }).catch(() => []);
      if (this.ri)
        for (const e of t2)
          this.ri.removeItem(this.Ii(e.clientId));
    }
  }
  ai() {
    this.ti = this.Ws.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.oi().then(() => this.gi()).then(() => this.ai()));
  }
  _i(t2) {
    return !!t2 && t2.ownerId === this.clientId;
  }
  fi(t2) {
    if (this.Js)
      return At.resolve(true);
    return qo(t2).get("owner").next((e) => {
      if (null !== e && this.yi(e.leaseTimestampMs, 5e3) && !this.Ti(e.ownerId)) {
        if (this._i(e) && this.networkEnabled)
          return true;
        if (!this._i(e)) {
          if (!e.allowTabSynchronization)
            throw new L2(B2.FAILED_PRECONDITION, Bo);
          return false;
        }
      }
      return !(!this.networkEnabled || !this.inForeground) || Uo(t2).j().next((t3) => void 0 === this.pi(t3, 5e3).find((t4) => {
        if (this.clientId !== t4.clientId) {
          const e2 = !this.networkEnabled && t4.networkEnabled, n = !this.inForeground && t4.inForeground, s = this.networkEnabled === t4.networkEnabled;
          if (e2 || n && s)
            return true;
        }
        return false;
      }));
    }).next((t3) => (this.isPrimary !== t3 && C2("IndexedDbPersistence", `Client ${t3 ? "is" : "is not"} eligible for a primary lease.`), t3));
  }
  async shutdown() {
    this.Ss = false, this.Ei(), this.ti && (this.ti.cancel(), this.ti = null), this.Ai(), this.Ri(), await this.ii.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], (t2) => {
      const e = new fe(t2, Ot.ct);
      return this.di(e).next(() => this.mi(e));
    }), this.ii.close(), this.vi();
  }
  pi(t2, e) {
    return t2.filter((t3) => this.yi(t3.updateTimeMs, e) && !this.Ti(t3.clientId));
  }
  bi() {
    return this.runTransaction("getActiveClients", "readonly", (t2) => Uo(t2).j().next((t3) => this.pi(t3, 18e5).map((t4) => t4.clientId)));
  }
  get started() {
    return this.Ss;
  }
  getMutationQueue(t2, e) {
    return Zr.ie(t2, this.serializer, e, this.referenceDelegate);
  }
  getTargetCache() {
    return this.Ds;
  }
  getRemoteDocumentCache() {
    return this.remoteDocumentCache;
  }
  getIndexManager(t2) {
    return new Ur(t2, this.serializer.se.databaseId);
  }
  getDocumentOverlayCache(t2) {
    return gr.ie(this.serializer, t2);
  }
  getBundleCache() {
    return this.xs;
  }
  runTransaction(t2, e, n) {
    C2("IndexedDbPersistence", "Starting transaction:", t2);
    const s = "readonly" === e ? "readonly" : "readwrite", i = 15 === (r = this.Ys) ? le : 14 === r ? he : 13 === r ? ae : 12 === r ? ce : 11 === r ? ue : void O2();
    var r;
    let o;
    return this.ii.runTransaction(t2, s, i, (s2) => (o = new fe(s2, this.Vs ? this.Vs.next() : Ot.ct), "readwrite-primary" === e ? this.li(o).next((t3) => !!t3 || this.fi(o)).next((e2) => {
      if (!e2)
        throw x2(`Failed to obtain primary lease for action '${t2}'.`), this.isPrimary = false, this.Ws.enqueueRetryable(() => this.ni(false)), new L2(B2.FAILED_PRECONDITION, It);
      return n(o);
    }).next((t3) => this.wi(o).next(() => t3)) : this.Pi(o).next(() => n(o)))).then((t3) => (o.raiseOnCommittedEvent(), t3));
  }
  Pi(t2) {
    return qo(t2).get("owner").next((t3) => {
      if (null !== t3 && this.yi(t3.leaseTimestampMs, 5e3) && !this.Ti(t3.ownerId) && !this._i(t3) && !(this.Js || this.allowTabSynchronization && t3.allowTabSynchronization))
        throw new L2(B2.FAILED_PRECONDITION, Bo);
    });
  }
  wi(t2) {
    const e = {
      ownerId: this.clientId,
      allowTabSynchronization: this.allowTabSynchronization,
      leaseTimestampMs: Date.now()
    };
    return qo(t2).put("owner", e);
  }
  static D() {
    return vt.D();
  }
  di(t2) {
    const e = qo(t2);
    return e.get("owner").next((t3) => this._i(t3) ? (C2("IndexedDbPersistence", "Releasing primary lease."), e.delete("owner")) : At.resolve());
  }
  yi(t2, e) {
    const n = Date.now();
    return !(t2 < n - e) && (!(t2 > n) || (x2(`Detected an update time that is in the future: ${t2} > ${n}`), false));
  }
  ui() {
    null !== this.document && "function" == typeof this.document.addEventListener && (this.Xs = () => {
      this.Ws.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this.oi()));
    }, this.document.addEventListener("visibilitychange", this.Xs), this.inForeground = "visible" === this.document.visibilityState);
  }
  Ai() {
    this.Xs && (this.document.removeEventListener("visibilitychange", this.Xs), this.Xs = null);
  }
  ci() {
    var t2;
    "function" == typeof (null === (t2 = this.window) || void 0 === t2 ? void 0 : t2.addEventListener) && (this.Zs = () => {
      this.Ei();
      const t3 = /(?:Version|Mobile)\/1[456]/;
      isSafari() && (navigator.appVersion.match(t3) || navigator.userAgent.match(t3)) && this.Ws.enterRestrictedMode(true), this.Ws.enqueueAndForget(() => this.shutdown());
    }, this.window.addEventListener("pagehide", this.Zs));
  }
  Ri() {
    this.Zs && (this.window.removeEventListener("pagehide", this.Zs), this.Zs = null);
  }
  Ti(t2) {
    var e;
    try {
      const n = null !== (null === (e = this.ri) || void 0 === e ? void 0 : e.getItem(this.Ii(t2)));
      return C2("IndexedDbPersistence", `Client '${t2}' ${n ? "is" : "is not"} zombied in LocalStorage`), n;
    } catch (t3) {
      return x2("IndexedDbPersistence", "Failed to get zombied client id.", t3), false;
    }
  }
  Ei() {
    if (this.ri)
      try {
        this.ri.setItem(this.Ii(this.clientId), String(Date.now()));
      } catch (t2) {
        x2("Failed to set zombie client id.", t2);
      }
  }
  vi() {
    if (this.ri)
      try {
        this.ri.removeItem(this.Ii(this.clientId));
      } catch (t2) {
      }
  }
  Ii(t2) {
    return `firestore_zombie_${this.persistenceKey}_${t2}`;
  }
};
function qo(t2) {
  return de(t2, "owner");
}
function Uo(t2) {
  return de(t2, "clientMetadata");
}
function Ko(t2, e) {
  let n = t2.projectId;
  return t2.isDefaultDatabase || (n += "." + t2.database), "firestore/" + e + "/" + n + "/";
}
var Go = class {
  constructor(t2, e, n, s) {
    this.targetId = t2, this.fromCache = e, this.Vi = n, this.Si = s;
  }
  static Di(t2, e) {
    let n = ws(), s = ws();
    for (const t3 of e.docChanges)
      switch (t3.type) {
        case 0:
          n = n.add(t3.doc.key);
          break;
        case 1:
          s = s.add(t3.doc.key);
      }
    return new Go(t2, e.fromCache, n, s);
  }
};
var Qo = class {
  constructor() {
    this.Ci = false;
  }
  initialize(t2, e) {
    this.xi = t2, this.indexManager = e, this.Ci = true;
  }
  getDocumentsMatchingQuery(t2, e, n, s) {
    return this.Ni(t2, e).next((i) => i || this.ki(t2, e, s, n)).next((n2) => n2 || this.Oi(t2, e));
  }
  Ni(t2, e) {
    if (Un(e))
      return At.resolve(null);
    let n = jn(e);
    return this.indexManager.getIndexType(t2, n).next((s) => 0 === s ? null : (null !== e.limit && 1 === s && (e = Hn(e, null, "F"), n = jn(e)), this.indexManager.getDocumentsMatchingTarget(t2, n).next((s2) => {
      const i = ws(...s2);
      return this.xi.getDocuments(t2, i).next((s3) => this.indexManager.getMinOffset(t2, n).next((n2) => {
        const r = this.$i(e, s3);
        return this.Mi(e, r, i, n2.readTime) ? this.Ni(t2, Hn(e, null, "F")) : this.Fi(t2, r, e, n2);
      }));
    })));
  }
  ki(t2, e, n, s) {
    return Un(e) || s.isEqual(st.min()) ? this.Oi(t2, e) : this.xi.getDocuments(t2, n).next((i) => {
      const r = this.$i(e, i);
      return this.Mi(e, r, n, s) ? this.Oi(t2, e) : (S2() <= LogLevel.DEBUG && C2("QueryEngine", "Re-using previous result from %s to execute query: %s", s.toString(), Zn(e)), this.Fi(t2, r, e, mt(s, -1)));
    });
  }
  $i(t2, e) {
    let n = new Ie(es(t2));
    return e.forEach((e2, s) => {
      Xn(t2, s) && (n = n.add(s));
    }), n;
  }
  Mi(t2, e, n, s) {
    if (null === t2.limit)
      return false;
    if (n.size !== e.size)
      return true;
    const i = "F" === t2.limitType ? e.last() : e.first();
    return !!i && (i.hasPendingWrites || i.version.compareTo(s) > 0);
  }
  Oi(t2, e) {
    return S2() <= LogLevel.DEBUG && C2("QueryEngine", "Using full collection scan to execute query:", Zn(e)), this.xi.getDocumentsMatchingQuery(t2, e, yt.min());
  }
  Fi(t2, e, n, s) {
    return this.xi.getDocumentsMatchingQuery(t2, n, s).next((t3) => (e.forEach((e2) => {
      t3 = t3.insert(e2.key, e2);
    }), t3));
  }
};
var zo = class {
  constructor(t2, e, n, s) {
    this.persistence = t2, this.Bi = e, this.serializer = s, this.Li = new ge(X2), this.qi = new ss((t3) => Nn(t3), kn), this.Ui = /* @__PURE__ */ new Map(), this.Ki = t2.getRemoteDocumentCache(), this.Ds = t2.getTargetCache(), this.xs = t2.getBundleCache(), this.Gi(n);
  }
  Gi(t2) {
    this.documentOverlayCache = this.persistence.getDocumentOverlayCache(t2), this.indexManager = this.persistence.getIndexManager(t2), this.mutationQueue = this.persistence.getMutationQueue(t2, this.indexManager), this.localDocuments = new vo(this.Ki, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Ki.setIndexManager(this.indexManager), this.Bi.initialize(this.localDocuments, this.indexManager);
  }
  collectGarbage(t2) {
    return this.persistence.runTransaction("Collect garbage", "readwrite-primary", (e) => t2.collect(e, this.Li));
  }
};
function jo(t2, e, n, s) {
  return new zo(t2, e, n, s);
}
async function Wo(t2, e) {
  const n = F(t2);
  return await n.persistence.runTransaction("Handle user change", "readonly", (t3) => {
    let s;
    return n.mutationQueue.getAllMutationBatches(t3).next((i) => (s = i, n.Gi(e), n.mutationQueue.getAllMutationBatches(t3))).next((e2) => {
      const i = [], r = [];
      let o = ws();
      for (const t4 of s) {
        i.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      for (const t4 of e2) {
        r.push(t4.batchId);
        for (const e3 of t4.mutations)
          o = o.add(e3.key);
      }
      return n.localDocuments.getDocuments(t3, o).next((t4) => ({
        Qi: t4,
        removedBatchIds: i,
        addedBatchIds: r
      }));
    });
  });
}
function Ho(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Acknowledge batch", "readwrite-primary", (t3) => {
    const s = e.batch.keys(), i = n.Ki.newChangeBuffer({
      trackRemovals: true
    });
    return function(t4, e2, n2, s2) {
      const i2 = n2.batch, r = i2.keys();
      let o = At.resolve();
      return r.forEach((t5) => {
        o = o.next(() => s2.getEntry(e2, t5)).next((e3) => {
          const r2 = n2.docVersions.get(t5);
          $(null !== r2), e3.version.compareTo(r2) < 0 && (i2.applyToRemoteDocument(e3, n2), e3.isValidDocument() && (e3.setReadTime(n2.commitVersion), s2.addEntry(e3)));
        });
      }), o.next(() => t4.mutationQueue.removeMutationBatch(e2, i2));
    }(n, t3, e, i).next(() => i.apply(t3)).next(() => n.mutationQueue.performConsistencyCheck(t3)).next(() => n.documentOverlayCache.removeOverlaysForBatchId(t3, s, e.batch.batchId)).next(() => n.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t3, function(t4) {
      let e2 = ws();
      for (let n2 = 0; n2 < t4.mutationResults.length; ++n2) {
        t4.mutationResults[n2].transformResults.length > 0 && (e2 = e2.add(t4.batch.mutations[n2].key));
      }
      return e2;
    }(e))).next(() => n.localDocuments.getDocuments(t3, s));
  });
}
function Jo(t2) {
  const e = F(t2);
  return e.persistence.runTransaction("Get last remote snapshot version", "readonly", (t3) => e.Ds.getLastRemoteSnapshotVersion(t3));
}
function Yo(t2, e) {
  const n = F(t2), s = e.snapshotVersion;
  let i = n.Li;
  return n.persistence.runTransaction("Apply remote event", "readwrite-primary", (t3) => {
    const r = n.Ki.newChangeBuffer({
      trackRemovals: true
    });
    i = n.Li;
    const o = [];
    e.targetChanges.forEach((r2, u2) => {
      const c2 = i.get(u2);
      if (!c2)
        return;
      o.push(n.Ds.removeMatchingKeys(t3, r2.removedDocuments, u2).next(() => n.Ds.addMatchingKeys(t3, r2.addedDocuments, u2)));
      let a = c2.withSequenceNumber(t3.currentSequenceNumber);
      e.targetMismatches.has(u2) ? a = a.withResumeToken(be.EMPTY_BYTE_STRING, st.min()).withLastLimboFreeSnapshotVersion(st.min()) : r2.resumeToken.approximateByteSize() > 0 && (a = a.withResumeToken(r2.resumeToken, s)), i = i.insert(u2, a), function(t4, e2, n2) {
        if (0 === t4.resumeToken.approximateByteSize())
          return true;
        if (e2.snapshotVersion.toMicroseconds() - t4.snapshotVersion.toMicroseconds() >= 3e8)
          return true;
        return n2.addedDocuments.size + n2.modifiedDocuments.size + n2.removedDocuments.size > 0;
      }(c2, a, r2) && o.push(n.Ds.updateTargetData(t3, a));
    });
    let u = rs(), c = ws();
    if (e.documentUpdates.forEach((s2) => {
      e.resolvedLimboDocuments.has(s2) && o.push(n.persistence.referenceDelegate.updateLimboDocument(t3, s2));
    }), o.push(Zo(t3, r, e.documentUpdates).next((t4) => {
      u = t4.zi, c = t4.ji;
    })), !s.isEqual(st.min())) {
      const e2 = n.Ds.getLastRemoteSnapshotVersion(t3).next((e3) => n.Ds.setTargetsMetadata(t3, t3.currentSequenceNumber, s));
      o.push(e2);
    }
    return At.waitFor(o).next(() => r.apply(t3)).next(() => n.localDocuments.getLocalViewOfDocuments(t3, u, c)).next(() => u);
  }).then((t3) => (n.Li = i, t3));
}
function Zo(t2, e, n) {
  let s = ws(), i = ws();
  return n.forEach((t3) => s = s.add(t3)), e.getEntries(t2, s).next((t3) => {
    let s2 = rs();
    return n.forEach((n2, r) => {
      const o = t3.get(n2);
      r.isFoundDocument() !== o.isFoundDocument() && (i = i.add(n2)), r.isNoDocument() && r.version.isEqual(st.min()) ? (e.removeEntry(n2, r.readTime), s2 = s2.insert(n2, r)) : !o.isValidDocument() || r.version.compareTo(o.version) > 0 || 0 === r.version.compareTo(o.version) && o.hasPendingWrites ? (e.addEntry(r), s2 = s2.insert(n2, r)) : C2("LocalStore", "Ignoring outdated watch update for ", n2, ". Current version:", o.version, " Watch version:", r.version);
    }), {
      zi: s2,
      ji: i
    };
  });
}
function Xo(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Get next mutation batch", "readonly", (t3) => (void 0 === e && (e = -1), n.mutationQueue.getNextMutationBatchAfterBatchId(t3, e)));
}
function tu(t2, e) {
  const n = F(t2);
  return n.persistence.runTransaction("Allocate target", "readwrite", (t3) => {
    let s;
    return n.Ds.getTargetData(t3, e).next((i) => i ? (s = i, At.resolve(s)) : n.Ds.allocateTargetId(t3).next((i2) => (s = new tr(e, i2, 0, t3.currentSequenceNumber), n.Ds.addTargetData(t3, s).next(() => s))));
  }).then((t3) => {
    const s = n.Li.get(t3.targetId);
    return (null === s || t3.snapshotVersion.compareTo(s.snapshotVersion) > 0) && (n.Li = n.Li.insert(t3.targetId, t3), n.qi.set(e, t3.targetId)), t3;
  });
}
async function eu(t2, e, n) {
  const s = F(t2), i = s.Li.get(e), r = n ? "readwrite" : "readwrite-primary";
  try {
    n || await s.persistence.runTransaction("Release target", r, (t3) => s.persistence.referenceDelegate.removeTarget(t3, i));
  } catch (t3) {
    if (!Vt(t3))
      throw t3;
    C2("LocalStore", `Failed to update sequence numbers for target ${e}: ${t3}`);
  }
  s.Li = s.Li.remove(e), s.qi.delete(i.target);
}
function nu(t2, e, n) {
  const s = F(t2);
  let i = st.min(), r = ws();
  return s.persistence.runTransaction("Execute query", "readonly", (t3) => function(t4, e2, n2) {
    const s2 = F(t4), i2 = s2.qi.get(n2);
    return void 0 !== i2 ? At.resolve(s2.Li.get(i2)) : s2.Ds.getTargetData(e2, n2);
  }(s, t3, jn(e)).next((e2) => {
    if (e2)
      return i = e2.lastLimboFreeSnapshotVersion, s.Ds.getMatchingKeysForTargetId(t3, e2.targetId).next((t4) => {
        r = t4;
      });
  }).next(() => s.Bi.getDocumentsMatchingQuery(t3, e, n ? i : st.min(), n ? r : ws())).next((t4) => (ru(s, ts(e), t4), {
    documents: t4,
    Wi: r
  })));
}
function su(t2, e) {
  const n = F(t2), s = F(n.Ds), i = n.Li.get(e);
  return i ? Promise.resolve(i.target) : n.persistence.runTransaction("Get target data", "readonly", (t3) => s.ne(t3, e).next((t4) => t4 ? t4.target : null));
}
function iu(t2, e) {
  const n = F(t2), s = n.Ui.get(e) || st.min();
  return n.persistence.runTransaction("Get new document changes", "readonly", (t3) => n.Ki.getAllFromCollectionGroup(
    t3,
    e,
    mt(s, -1),
    Number.MAX_SAFE_INTEGER
  )).then((t3) => (ru(n, e, t3), t3));
}
function ru(t2, e, n) {
  let s = t2.Ui.get(e) || st.min();
  n.forEach((t3, e2) => {
    e2.readTime.compareTo(s) > 0 && (s = e2.readTime);
  }), t2.Ui.set(e, s);
}
async function ou(t2, e, n, s) {
  const i = F(t2);
  let r = ws(), o = rs();
  for (const t3 of n) {
    const n2 = e.Hi(t3.metadata.name);
    t3.document && (r = r.add(n2));
    const s2 = e.Ji(t3);
    s2.setReadTime(e.Yi(t3.metadata.readTime)), o = o.insert(n2, s2);
  }
  const u = i.Ki.newChangeBuffer({
    trackRemovals: true
  }), c = await tu(i, function(t3) {
    return jn(qn(rt.fromString(`__bundle__/docs/${t3}`)));
  }(s));
  return i.persistence.runTransaction("Apply bundle documents", "readwrite", (t3) => Zo(t3, u, o).next((e2) => (u.apply(t3), e2)).next((e2) => i.Ds.removeMatchingKeysForTargetId(t3, c.targetId).next(() => i.Ds.addMatchingKeys(t3, r, c.targetId)).next(() => i.localDocuments.getLocalViewOfDocuments(t3, e2.zi, e2.ji)).next(() => e2.zi)));
}
async function uu(t2, e, n = ws()) {
  const s = await tu(t2, jn(hr(e.bundledQuery))), i = F(t2);
  return i.persistence.runTransaction("Save named query", "readwrite", (t3) => {
    const r = vi(e.readTime);
    if (s.snapshotVersion.compareTo(r) >= 0)
      return i.xs.saveNamedQuery(t3, e);
    const o = s.withResumeToken(be.EMPTY_BYTE_STRING, r);
    return i.Li = i.Li.insert(o.targetId, o), i.Ds.updateTargetData(t3, o).next(() => i.Ds.removeMatchingKeysForTargetId(t3, s.targetId)).next(() => i.Ds.addMatchingKeys(t3, n, s.targetId)).next(() => i.xs.saveNamedQuery(t3, e));
  });
}
function cu(t2, e) {
  return `firestore_clients_${t2}_${e}`;
}
function au(t2, e, n) {
  let s = `firestore_mutations_${t2}_${n}`;
  return e.isAuthenticated() && (s += `_${e.uid}`), s;
}
function hu(t2, e) {
  return `firestore_targets_${t2}_${e}`;
}
var lu = class {
  constructor(t2, e, n, s) {
    this.user = t2, this.batchId = e, this.state = n, this.error = s;
  }
  static Zi(t2, e, n) {
    const s = JSON.parse(n);
    let i, r = "object" == typeof s && -1 !== ["pending", "acknowledged", "rejected"].indexOf(s.state) && (void 0 === s.error || "object" == typeof s.error);
    return r && s.error && (r = "string" == typeof s.error.message && "string" == typeof s.error.code, r && (i = new L2(s.error.code, s.error.message))), r ? new lu(t2, e, s.state, i) : (x2("SharedClientState", `Failed to parse mutation state for ID '${e}': ${n}`), null);
  }
  Xi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var fu = class {
  constructor(t2, e, n) {
    this.targetId = t2, this.state = e, this.error = n;
  }
  static Zi(t2, e) {
    const n = JSON.parse(e);
    let s, i = "object" == typeof n && -1 !== ["not-current", "current", "rejected"].indexOf(n.state) && (void 0 === n.error || "object" == typeof n.error);
    return i && n.error && (i = "string" == typeof n.error.message && "string" == typeof n.error.code, i && (s = new L2(n.error.code, n.error.message))), i ? new fu(t2, n.state, s) : (x2("SharedClientState", `Failed to parse target state for ID '${t2}': ${e}`), null);
  }
  Xi() {
    const t2 = {
      state: this.state,
      updateTimeMs: Date.now()
    };
    return this.error && (t2.error = {
      code: this.error.code,
      message: this.error.message
    }), JSON.stringify(t2);
  }
};
var du = class {
  constructor(t2, e) {
    this.clientId = t2, this.activeTargetIds = e;
  }
  static Zi(t2, e) {
    const n = JSON.parse(e);
    let s = "object" == typeof n && n.activeTargetIds instanceof Array, i = ms();
    for (let t3 = 0; s && t3 < n.activeTargetIds.length; ++t3)
      s = Ft(n.activeTargetIds[t3]), i = i.add(n.activeTargetIds[t3]);
    return s ? new du(t2, i) : (x2("SharedClientState", `Failed to parse client data for instance '${t2}': ${e}`), null);
  }
};
var wu = class {
  constructor(t2, e) {
    this.clientId = t2, this.onlineState = e;
  }
  static Zi(t2) {
    const e = JSON.parse(t2);
    return "object" == typeof e && -1 !== ["Unknown", "Online", "Offline"].indexOf(e.onlineState) && "string" == typeof e.clientId ? new wu(e.clientId, e.onlineState) : (x2("SharedClientState", `Failed to parse online state: ${t2}`), null);
  }
};
var _u = class {
  constructor() {
    this.activeTargetIds = ms();
  }
  tr(t2) {
    this.activeTargetIds = this.activeTargetIds.add(t2);
  }
  er(t2) {
    this.activeTargetIds = this.activeTargetIds.delete(t2);
  }
  Xi() {
    const t2 = {
      activeTargetIds: this.activeTargetIds.toArray(),
      updateTimeMs: Date.now()
    };
    return JSON.stringify(t2);
  }
};
var mu = class {
  constructor(t2, e, n, s, i) {
    this.window = t2, this.Ws = e, this.persistenceKey = n, this.nr = s, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this.sr = this.ir.bind(this), this.rr = new ge(X2), this.started = false, this.ur = [];
    const r = n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    this.storage = this.window.localStorage, this.currentUser = i, this.cr = cu(this.persistenceKey, this.nr), this.ar = function(t3) {
      return `firestore_sequence_number_${t3}`;
    }(this.persistenceKey), this.rr = this.rr.insert(this.nr, new _u()), this.hr = new RegExp(`^firestore_clients_${r}_([^_]*)$`), this.lr = new RegExp(`^firestore_mutations_${r}_(\\d+)(?:_(.*))?$`), this.dr = new RegExp(`^firestore_targets_${r}_(\\d+)$`), this.wr = function(t3) {
      return `firestore_online_state_${t3}`;
    }(this.persistenceKey), this._r = function(t3) {
      return `firestore_bundle_loaded_v2_${t3}`;
    }(this.persistenceKey), this.window.addEventListener("storage", this.sr);
  }
  static D(t2) {
    return !(!t2 || !t2.localStorage);
  }
  async start() {
    const t2 = await this.syncEngine.bi();
    for (const e2 of t2) {
      if (e2 === this.nr)
        continue;
      const t3 = this.getItem(cu(this.persistenceKey, e2));
      if (t3) {
        const n = du.Zi(e2, t3);
        n && (this.rr = this.rr.insert(n.clientId, n));
      }
    }
    this.mr();
    const e = this.storage.getItem(this.wr);
    if (e) {
      const t3 = this.gr(e);
      t3 && this.yr(t3);
    }
    for (const t3 of this.ur)
      this.ir(t3);
    this.ur = [], this.window.addEventListener("pagehide", () => this.shutdown()), this.started = true;
  }
  writeSequenceNumber(t2) {
    this.setItem(this.ar, JSON.stringify(t2));
  }
  getAllActiveQueryTargets() {
    return this.pr(this.rr);
  }
  isActiveQueryTarget(t2) {
    let e = false;
    return this.rr.forEach((n, s) => {
      s.activeTargetIds.has(t2) && (e = true);
    }), e;
  }
  addPendingMutation(t2) {
    this.Ir(t2, "pending");
  }
  updateMutationState(t2, e, n) {
    this.Ir(t2, e, n), this.Tr(t2);
  }
  addLocalQueryTarget(t2) {
    let e = "not-current";
    if (this.isActiveQueryTarget(t2)) {
      const n = this.storage.getItem(hu(this.persistenceKey, t2));
      if (n) {
        const s = fu.Zi(t2, n);
        s && (e = s.state);
      }
    }
    return this.Er.tr(t2), this.mr(), e;
  }
  removeLocalQueryTarget(t2) {
    this.Er.er(t2), this.mr();
  }
  isLocalQueryTarget(t2) {
    return this.Er.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    this.removeItem(hu(this.persistenceKey, t2));
  }
  updateQueryState(t2, e, n) {
    this.Ar(t2, e, n);
  }
  handleUserChange(t2, e, n) {
    e.forEach((t3) => {
      this.Tr(t3);
    }), this.currentUser = t2, n.forEach((t3) => {
      this.addPendingMutation(t3);
    });
  }
  setOnlineState(t2) {
    this.Rr(t2);
  }
  notifyBundleLoaded(t2) {
    this.vr(t2);
  }
  shutdown() {
    this.started && (this.window.removeEventListener("storage", this.sr), this.removeItem(this.cr), this.started = false);
  }
  getItem(t2) {
    const e = this.storage.getItem(t2);
    return C2("SharedClientState", "READ", t2, e), e;
  }
  setItem(t2, e) {
    C2("SharedClientState", "SET", t2, e), this.storage.setItem(t2, e);
  }
  removeItem(t2) {
    C2("SharedClientState", "REMOVE", t2), this.storage.removeItem(t2);
  }
  ir(t2) {
    const e = t2;
    if (e.storageArea === this.storage) {
      if (C2("SharedClientState", "EVENT", e.key, e.newValue), e.key === this.cr)
        return void x2("Received WebStorage notification for local change. Another client might have garbage-collected our state");
      this.Ws.enqueueRetryable(async () => {
        if (this.started) {
          if (null !== e.key) {
            if (this.hr.test(e.key)) {
              if (null == e.newValue) {
                const t3 = this.br(e.key);
                return this.Pr(t3, null);
              }
              {
                const t3 = this.Vr(e.key, e.newValue);
                if (t3)
                  return this.Pr(t3.clientId, t3);
              }
            } else if (this.lr.test(e.key)) {
              if (null !== e.newValue) {
                const t3 = this.Sr(e.key, e.newValue);
                if (t3)
                  return this.Dr(t3);
              }
            } else if (this.dr.test(e.key)) {
              if (null !== e.newValue) {
                const t3 = this.Cr(e.key, e.newValue);
                if (t3)
                  return this.Nr(t3);
              }
            } else if (e.key === this.wr) {
              if (null !== e.newValue) {
                const t3 = this.gr(e.newValue);
                if (t3)
                  return this.yr(t3);
              }
            } else if (e.key === this.ar) {
              const t3 = function(t4) {
                let e2 = Ot.ct;
                if (null != t4)
                  try {
                    const n = JSON.parse(t4);
                    $("number" == typeof n), e2 = n;
                  } catch (t5) {
                    x2("SharedClientState", "Failed to read sequence number from WebStorage", t5);
                  }
                return e2;
              }(e.newValue);
              t3 !== Ot.ct && this.sequenceNumberHandler(t3);
            } else if (e.key === this._r) {
              const t3 = this.kr(e.newValue);
              await Promise.all(t3.map((t4) => this.syncEngine.Or(t4)));
            }
          }
        } else
          this.ur.push(e);
      });
    }
  }
  get Er() {
    return this.rr.get(this.nr);
  }
  mr() {
    this.setItem(this.cr, this.Er.Xi());
  }
  Ir(t2, e, n) {
    const s = new lu(this.currentUser, t2, e, n), i = au(this.persistenceKey, this.currentUser, t2);
    this.setItem(i, s.Xi());
  }
  Tr(t2) {
    const e = au(this.persistenceKey, this.currentUser, t2);
    this.removeItem(e);
  }
  Rr(t2) {
    const e = {
      clientId: this.nr,
      onlineState: t2
    };
    this.storage.setItem(this.wr, JSON.stringify(e));
  }
  Ar(t2, e, n) {
    const s = hu(this.persistenceKey, t2), i = new fu(t2, e, n);
    this.setItem(s, i.Xi());
  }
  vr(t2) {
    const e = JSON.stringify(Array.from(t2));
    this.setItem(this._r, e);
  }
  br(t2) {
    const e = this.hr.exec(t2);
    return e ? e[1] : null;
  }
  Vr(t2, e) {
    const n = this.br(t2);
    return du.Zi(n, e);
  }
  Sr(t2, e) {
    const n = this.lr.exec(t2), s = Number(n[1]), i = void 0 !== n[2] ? n[2] : null;
    return lu.Zi(new b(i), s, e);
  }
  Cr(t2, e) {
    const n = this.dr.exec(t2), s = Number(n[1]);
    return fu.Zi(s, e);
  }
  gr(t2) {
    return wu.Zi(t2);
  }
  kr(t2) {
    return JSON.parse(t2);
  }
  async Dr(t2) {
    if (t2.user.uid === this.currentUser.uid)
      return this.syncEngine.$r(t2.batchId, t2.state, t2.error);
    C2("SharedClientState", `Ignoring mutation for non-active user ${t2.user.uid}`);
  }
  Nr(t2) {
    return this.syncEngine.Mr(t2.targetId, t2.state, t2.error);
  }
  Pr(t2, e) {
    const n = e ? this.rr.insert(t2, e) : this.rr.remove(t2), s = this.pr(this.rr), i = this.pr(n), r = [], o = [];
    return i.forEach((t3) => {
      s.has(t3) || r.push(t3);
    }), s.forEach((t3) => {
      i.has(t3) || o.push(t3);
    }), this.syncEngine.Fr(r, o).then(() => {
      this.rr = n;
    });
  }
  yr(t2) {
    this.rr.get(t2.clientId) && this.onlineStateHandler(t2.onlineState);
  }
  pr(t2) {
    let e = ms();
    return t2.forEach((t3, n) => {
      e = e.unionWith(n.activeTargetIds);
    }), e;
  }
};
var gu = class {
  constructor() {
    this.Br = new _u(), this.Lr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null;
  }
  addPendingMutation(t2) {
  }
  updateMutationState(t2, e, n) {
  }
  addLocalQueryTarget(t2) {
    return this.Br.tr(t2), this.Lr[t2] || "not-current";
  }
  updateQueryState(t2, e, n) {
    this.Lr[t2] = e;
  }
  removeLocalQueryTarget(t2) {
    this.Br.er(t2);
  }
  isLocalQueryTarget(t2) {
    return this.Br.activeTargetIds.has(t2);
  }
  clearQueryState(t2) {
    delete this.Lr[t2];
  }
  getAllActiveQueryTargets() {
    return this.Br.activeTargetIds;
  }
  isActiveQueryTarget(t2) {
    return this.Br.activeTargetIds.has(t2);
  }
  start() {
    return this.Br = new _u(), Promise.resolve();
  }
  handleUserChange(t2, e, n) {
  }
  setOnlineState(t2) {
  }
  shutdown() {
  }
  writeSequenceNumber(t2) {
  }
  notifyBundleLoaded(t2) {
  }
};
var yu = class {
  qr(t2) {
  }
  shutdown() {
  }
};
var pu = class {
  constructor() {
    this.Ur = () => this.Kr(), this.Gr = () => this.Qr(), this.zr = [], this.jr();
  }
  qr(t2) {
    this.zr.push(t2);
  }
  shutdown() {
    window.removeEventListener("online", this.Ur), window.removeEventListener("offline", this.Gr);
  }
  jr() {
    window.addEventListener("online", this.Ur), window.addEventListener("offline", this.Gr);
  }
  Kr() {
    C2("ConnectivityMonitor", "Network connectivity changed: AVAILABLE");
    for (const t2 of this.zr)
      t2(0);
  }
  Qr() {
    C2("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE");
    for (const t2 of this.zr)
      t2(1);
  }
  static D() {
    return "undefined" != typeof window && void 0 !== window.addEventListener && void 0 !== window.removeEventListener;
  }
};
var Iu = null;
function Tu() {
  return null === Iu ? Iu = 268435456 + Math.round(2147483648 * Math.random()) : Iu++, "0x" + Iu.toString(16);
}
var Eu = {
  BatchGetDocuments: "batchGet",
  Commit: "commit",
  RunQuery: "runQuery",
  RunAggregationQuery: "runAggregationQuery"
};
var Au = class {
  constructor(t2) {
    this.Wr = t2.Wr, this.Hr = t2.Hr;
  }
  Jr(t2) {
    this.Yr = t2;
  }
  Zr(t2) {
    this.Xr = t2;
  }
  onMessage(t2) {
    this.eo = t2;
  }
  close() {
    this.Hr();
  }
  send(t2) {
    this.Wr(t2);
  }
  no() {
    this.Yr();
  }
  so(t2) {
    this.Xr(t2);
  }
  io(t2) {
    this.eo(t2);
  }
};
var Ru = "WebChannelConnection";
var vu = class extends class {
  constructor(t2) {
    this.databaseInfo = t2, this.databaseId = t2.databaseId;
    const e = t2.ssl ? "https" : "http";
    this.ro = e + "://" + t2.host, this.oo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents";
  }
  get uo() {
    return false;
  }
  co(t2, e, n, s, i) {
    const r = Tu(), o = this.ao(t2, e);
    C2("RestConnection", `Sending RPC '${t2}' ${r}:`, o, n);
    const u = {};
    return this.ho(u, s, i), this.lo(t2, o, u, n).then((e2) => (C2("RestConnection", `Received RPC '${t2}' ${r}: `, e2), e2), (e2) => {
      throw N2("RestConnection", `RPC '${t2}' ${r} failed with error: `, e2, "url: ", o, "request:", n), e2;
    });
  }
  fo(t2, e, n, s, i, r) {
    return this.co(t2, e, n, s, i);
  }
  ho(t2, e, n) {
    t2["X-Goog-Api-Client"] = "gl-js/ fire/" + P2, t2["Content-Type"] = "text/plain", this.databaseInfo.appId && (t2["X-Firebase-GMPID"] = this.databaseInfo.appId), e && e.headers.forEach((e2, n2) => t2[n2] = e2), n && n.headers.forEach((e2, n2) => t2[n2] = e2);
  }
  ao(t2, e) {
    const n = Eu[t2];
    return `${this.ro}/v1/${e}:${n}`;
  }
} {
  constructor(t2) {
    super(t2), this.forceLongPolling = t2.forceLongPolling, this.autoDetectLongPolling = t2.autoDetectLongPolling, this.useFetchStreams = t2.useFetchStreams;
  }
  lo(t2, e, n, s) {
    const i = Tu();
    return new Promise((r, o) => {
      const u = new XhrIo();
      u.setWithCredentials(true), u.listenOnce(EventType.COMPLETE, () => {
        try {
          switch (u.getLastErrorCode()) {
            case ErrorCode.NO_ERROR:
              const e2 = u.getResponseJson();
              C2(Ru, `XHR for RPC '${t2}' ${i} received:`, JSON.stringify(e2)), r(e2);
              break;
            case ErrorCode.TIMEOUT:
              C2(Ru, `RPC '${t2}' ${i} timed out`), o(new L2(B2.DEADLINE_EXCEEDED, "Request time out"));
              break;
            case ErrorCode.HTTP_ERROR:
              const n2 = u.getStatus();
              if (C2(Ru, `RPC '${t2}' ${i} failed with status:`, n2, "response text:", u.getResponseText()), n2 > 0) {
                let t3 = u.getResponseJson();
                Array.isArray(t3) && (t3 = t3[0]);
                const e3 = null == t3 ? void 0 : t3.error;
                if (e3 && e3.status && e3.message) {
                  const t4 = function(t5) {
                    const e4 = t5.toLowerCase().replace(/_/g, "-");
                    return Object.values(B2).indexOf(e4) >= 0 ? e4 : B2.UNKNOWN;
                  }(e3.status);
                  o(new L2(t4, e3.message));
                } else
                  o(new L2(B2.UNKNOWN, "Server responded with status " + u.getStatus()));
              } else
                o(new L2(B2.UNAVAILABLE, "Connection failed."));
              break;
            default:
              O2();
          }
        } finally {
          C2(Ru, `RPC '${t2}' ${i} completed.`);
        }
      });
      const c = JSON.stringify(s);
      C2(Ru, `RPC '${t2}' ${i} sending request:`, s), u.send(e, "POST", c, n, 15);
    });
  }
  wo(t2, e, n) {
    const s = Tu(), i = [this.ro, "/", "google.firestore.v1.Firestore", "/", t2, "/channel"], r = createWebChannelTransport(), o = getStatEventTarget(), u = {
      httpSessionIdParam: "gsessionid",
      initMessageHeaders: {},
      messageUrlParams: {
        database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}`
      },
      sendRawJson: true,
      supportsCrossDomainXhr: true,
      internalChannelParams: {
        forwardChannelRequestTimeoutMs: 6e5
      },
      forceLongPolling: this.forceLongPolling,
      detectBufferingProxy: this.autoDetectLongPolling
    };
    this.useFetchStreams && (u.xmlHttpFactory = new FetchXmlHttpFactory({})), this.ho(u.initMessageHeaders, e, n), u.encodeInitMessageHeaders = true;
    const c = i.join("");
    C2(Ru, `Creating RPC '${t2}' stream ${s}: ${c}`, u);
    const a = r.createWebChannel(c, u);
    let h = false, l2 = false;
    const f = new Au({
      Wr: (e2) => {
        l2 ? C2(Ru, `Not sending because RPC '${t2}' stream ${s} is closed:`, e2) : (h || (C2(Ru, `Opening RPC '${t2}' stream ${s} transport.`), a.open(), h = true), C2(Ru, `RPC '${t2}' stream ${s} sending:`, e2), a.send(e2));
      },
      Hr: () => a.close()
    }), d = (t3, e2, n2) => {
      t3.listen(e2, (t4) => {
        try {
          n2(t4);
        } catch (t5) {
          setTimeout(() => {
            throw t5;
          }, 0);
        }
      });
    };
    return d(a, WebChannel.EventType.OPEN, () => {
      l2 || C2(Ru, `RPC '${t2}' stream ${s} transport opened.`);
    }), d(a, WebChannel.EventType.CLOSE, () => {
      l2 || (l2 = true, C2(Ru, `RPC '${t2}' stream ${s} transport closed`), f.so());
    }), d(a, WebChannel.EventType.ERROR, (e2) => {
      l2 || (l2 = true, N2(Ru, `RPC '${t2}' stream ${s} transport errored:`, e2), f.so(new L2(B2.UNAVAILABLE, "The operation could not be completed")));
    }), d(a, WebChannel.EventType.MESSAGE, (e2) => {
      var n2;
      if (!l2) {
        const i2 = e2.data[0];
        $(!!i2);
        const r2 = i2, o2 = r2.error || (null === (n2 = r2[0]) || void 0 === n2 ? void 0 : n2.error);
        if (o2) {
          C2(Ru, `RPC '${t2}' stream ${s} received error:`, o2);
          const e3 = o2.status;
          let n3 = function(t3) {
            const e4 = si[t3];
            if (void 0 !== e4)
              return oi(e4);
          }(e3), i3 = o2.message;
          void 0 === n3 && (n3 = B2.INTERNAL, i3 = "Unknown error status: " + e3 + " with message " + o2.message), l2 = true, f.so(new L2(n3, i3)), a.close();
        } else
          C2(Ru, `RPC '${t2}' stream ${s} received:`, i2), f.io(i2);
      }
    }), d(o, Event.STAT_EVENT, (e2) => {
      e2.stat === Stat.PROXY ? C2(Ru, `RPC '${t2}' stream ${s} detected buffering proxy`) : e2.stat === Stat.NOPROXY && C2(Ru, `RPC '${t2}' stream ${s} detected no buffering proxy`);
    }), setTimeout(() => {
      f.no();
    }, 0), f;
  }
};
function bu() {
  return "undefined" != typeof window ? window : null;
}
function Pu() {
  return "undefined" != typeof document ? document : null;
}
function Vu(t2) {
  return new Ti(t2, true);
}
var Su = class {
  constructor(t2, e, n = 1e3, s = 1.5, i = 6e4) {
    this.Ws = t2, this.timerId = e, this._o = n, this.mo = s, this.yo = i, this.po = 0, this.Io = null, this.To = Date.now(), this.reset();
  }
  reset() {
    this.po = 0;
  }
  Eo() {
    this.po = this.yo;
  }
  Ao(t2) {
    this.cancel();
    const e = Math.floor(this.po + this.Ro()), n = Math.max(0, Date.now() - this.To), s = Math.max(0, e - n);
    s > 0 && C2("ExponentialBackoff", `Backing off for ${s} ms (base delay: ${this.po} ms, delay with jitter: ${e} ms, last attempt: ${n} ms ago)`), this.Io = this.Ws.enqueueAfterDelay(this.timerId, s, () => (this.To = Date.now(), t2())), this.po *= this.mo, this.po < this._o && (this.po = this._o), this.po > this.yo && (this.po = this.yo);
  }
  vo() {
    null !== this.Io && (this.Io.skipDelay(), this.Io = null);
  }
  cancel() {
    null !== this.Io && (this.Io.cancel(), this.Io = null);
  }
  Ro() {
    return (Math.random() - 0.5) * this.po;
  }
};
var Du = class {
  constructor(t2, e, n, s, i, r, o, u) {
    this.Ws = t2, this.bo = n, this.Po = s, this.connection = i, this.authCredentialsProvider = r, this.appCheckCredentialsProvider = o, this.listener = u, this.state = 0, this.Vo = 0, this.So = null, this.Do = null, this.stream = null, this.Co = new Su(t2, e);
  }
  xo() {
    return 1 === this.state || 5 === this.state || this.No();
  }
  No() {
    return 2 === this.state || 3 === this.state;
  }
  start() {
    4 !== this.state ? this.auth() : this.ko();
  }
  async stop() {
    this.xo() && await this.close(0);
  }
  Oo() {
    this.state = 0, this.Co.reset();
  }
  $o() {
    this.No() && null === this.So && (this.So = this.Ws.enqueueAfterDelay(this.bo, 6e4, () => this.Mo()));
  }
  Fo(t2) {
    this.Bo(), this.stream.send(t2);
  }
  async Mo() {
    if (this.No())
      return this.close(0);
  }
  Bo() {
    this.So && (this.So.cancel(), this.So = null);
  }
  Lo() {
    this.Do && (this.Do.cancel(), this.Do = null);
  }
  async close(t2, e) {
    this.Bo(), this.Lo(), this.Co.cancel(), this.Vo++, 4 !== t2 ? this.Co.reset() : e && e.code === B2.RESOURCE_EXHAUSTED ? (x2(e.toString()), x2("Using maximum backoff delay to prevent overloading the backend."), this.Co.Eo()) : e && e.code === B2.UNAUTHENTICATED && 3 !== this.state && (this.authCredentialsProvider.invalidateToken(), this.appCheckCredentialsProvider.invalidateToken()), null !== this.stream && (this.qo(), this.stream.close(), this.stream = null), this.state = t2, await this.listener.Zr(e);
  }
  qo() {
  }
  auth() {
    this.state = 1;
    const t2 = this.Uo(this.Vo), e = this.Vo;
    Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([t3, n]) => {
      this.Vo === e && this.Ko(t3, n);
    }, (e2) => {
      t2(() => {
        const t3 = new L2(B2.UNKNOWN, "Fetching auth token failed: " + e2.message);
        return this.Go(t3);
      });
    });
  }
  Ko(t2, e) {
    const n = this.Uo(this.Vo);
    this.stream = this.Qo(t2, e), this.stream.Jr(() => {
      n(() => (this.state = 2, this.Do = this.Ws.enqueueAfterDelay(this.Po, 1e4, () => (this.No() && (this.state = 3), Promise.resolve())), this.listener.Jr()));
    }), this.stream.Zr((t3) => {
      n(() => this.Go(t3));
    }), this.stream.onMessage((t3) => {
      n(() => this.onMessage(t3));
    });
  }
  ko() {
    this.state = 5, this.Co.Ao(async () => {
      this.state = 0, this.start();
    });
  }
  Go(t2) {
    return C2("PersistentStream", `close with error: ${t2}`), this.stream = null, this.close(4, t2);
  }
  Uo(t2) {
    return (e) => {
      this.Ws.enqueueAndForget(() => this.Vo === t2 ? e() : (C2("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve()));
    };
  }
};
var Cu = class extends Du {
  constructor(t2, e, n, s, i, r) {
    super(t2, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", e, n, s, r), this.serializer = i;
  }
  Qo(t2, e) {
    return this.connection.wo("Listen", t2, e);
  }
  onMessage(t2) {
    this.Co.reset();
    const e = Mi(this.serializer, t2), n = function(t3) {
      if (!("targetChange" in t3))
        return st.min();
      const e2 = t3.targetChange;
      return e2.targetIds && e2.targetIds.length ? st.min() : e2.readTime ? vi(e2.readTime) : st.min();
    }(t2);
    return this.listener.zo(e, n);
  }
  jo(t2) {
    const e = {};
    e.database = xi(this.serializer), e.addTarget = function(t3, e2) {
      let n2;
      const s = e2.target;
      return n2 = On(s) ? {
        documents: qi(t3, s)
      } : {
        query: Ui(t3, s)
      }, n2.targetId = e2.targetId, e2.resumeToken.approximateByteSize() > 0 ? n2.resumeToken = Ai(t3, e2.resumeToken) : e2.snapshotVersion.compareTo(st.min()) > 0 && (n2.readTime = Ei(t3, e2.snapshotVersion.toTimestamp())), n2;
    }(this.serializer, t2);
    const n = Gi(this.serializer, t2);
    n && (e.labels = n), this.Fo(e);
  }
  Wo(t2) {
    const e = {};
    e.database = xi(this.serializer), e.removeTarget = t2, this.Fo(e);
  }
};
var xu = class extends Du {
  constructor(t2, e, n, s, i, r) {
    super(t2, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", e, n, s, r), this.serializer = i, this.Ho = false;
  }
  get Jo() {
    return this.Ho;
  }
  start() {
    this.Ho = false, this.lastStreamToken = void 0, super.start();
  }
  qo() {
    this.Ho && this.Yo([]);
  }
  Qo(t2, e) {
    return this.connection.wo("Write", t2, e);
  }
  onMessage(t2) {
    if ($(!!t2.streamToken), this.lastStreamToken = t2.streamToken, this.Ho) {
      this.Co.reset();
      const e = Li(t2.writeResults, t2.commitTime), n = vi(t2.commitTime);
      return this.listener.Zo(n, e);
    }
    return $(!t2.writeResults || 0 === t2.writeResults.length), this.Ho = true, this.listener.Xo();
  }
  tu() {
    const t2 = {};
    t2.database = xi(this.serializer), this.Fo(t2);
  }
  Yo(t2) {
    const e = {
      streamToken: this.lastStreamToken,
      writes: t2.map((t3) => Fi(this.serializer, t3))
    };
    this.Fo(e);
  }
};
var Nu = class extends class {
} {
  constructor(t2, e, n, s) {
    super(), this.authCredentials = t2, this.appCheckCredentials = e, this.connection = n, this.serializer = s, this.eu = false;
  }
  nu() {
    if (this.eu)
      throw new L2(B2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  co(t2, e, n) {
    return this.nu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([s, i]) => this.connection.co(t2, e, n, s, i)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === B2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new L2(B2.UNKNOWN, t3.toString());
    });
  }
  fo(t2, e, n, s) {
    return this.nu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([i, r]) => this.connection.fo(t2, e, n, i, r, s)).catch((t3) => {
      throw "FirebaseError" === t3.name ? (t3.code === B2.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), t3) : new L2(B2.UNKNOWN, t3.toString());
    });
  }
  terminate() {
    this.eu = true;
  }
};
async function ku(t2, e, n) {
  const s = F(t2), i = function(t3, e2, n2) {
    const s2 = Ui(t3, e2), i2 = [];
    return n2.forEach((t4) => {
      "count" === t4.yt ? i2.push({
        alias: t4.alias.canonicalString(),
        count: {}
      }) : "avg" === t4.yt ? i2.push({
        alias: t4.alias.canonicalString(),
        avg: {
          field: Hi(t4.fieldPath)
        }
      }) : "sum" === t4.yt && i2.push({
        alias: t4.alias.canonicalString(),
        sum: {
          field: Hi(t4.fieldPath)
        }
      });
    }), {
      structuredAggregationQuery: {
        aggregations: i2,
        structuredQuery: s2.structuredQuery
      },
      parent: s2.parent
    };
  }(s.serializer, jn(e), n), r = i.parent;
  s.connection.uo || delete i.parent;
  const o = (await s.fo("RunAggregationQuery", r, i, 1)).filter((t3) => !!t3.result);
  return $(1 === o.length), (u = o[0]).result, u.result.aggregateFields, new sn({
    mapValue: {
      fields: null === (c = u.result) || void 0 === c ? void 0 : c.aggregateFields
    }
  });
  var u, c;
}
var Ou = class {
  constructor(t2, e) {
    this.asyncQueue = t2, this.onlineStateHandler = e, this.state = "Unknown", this.su = 0, this.iu = null, this.ru = true;
  }
  ou() {
    0 === this.su && (this.uu("Unknown"), this.iu = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this.iu = null, this.cu("Backend didn't respond within 10 seconds."), this.uu("Offline"), Promise.resolve())));
  }
  au(t2) {
    "Online" === this.state ? this.uu("Unknown") : (this.su++, this.su >= 1 && (this.hu(), this.cu(`Connection failed 1 times. Most recent error: ${t2.toString()}`), this.uu("Offline")));
  }
  set(t2) {
    this.hu(), this.su = 0, "Online" === t2 && (this.ru = false), this.uu(t2);
  }
  uu(t2) {
    t2 !== this.state && (this.state = t2, this.onlineStateHandler(t2));
  }
  cu(t2) {
    const e = `Could not reach Cloud Firestore backend. ${t2}
This typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`;
    this.ru ? (x2(e), this.ru = false) : C2("OnlineStateTracker", e);
  }
  hu() {
    null !== this.iu && (this.iu.cancel(), this.iu = null);
  }
};
var $u = class {
  constructor(t2, e, n, s, i) {
    this.localStore = t2, this.datastore = e, this.asyncQueue = n, this.remoteSyncer = {}, this.lu = [], this.fu = /* @__PURE__ */ new Map(), this.du = /* @__PURE__ */ new Set(), this.wu = [], this._u = i, this._u.qr((t3) => {
      n.enqueueAndForget(async () => {
        Qu(this) && (C2("RemoteStore", "Restarting streams for network reachability change."), await async function(t4) {
          const e2 = F(t4);
          e2.du.add(4), await Fu(e2), e2.mu.set("Unknown"), e2.du.delete(4), await Mu(e2);
        }(this));
      });
    }), this.mu = new Ou(n, s);
  }
};
async function Mu(t2) {
  if (Qu(t2))
    for (const e of t2.wu)
      await e(true);
}
async function Fu(t2) {
  for (const e of t2.wu)
    await e(false);
}
function Bu(t2, e) {
  const n = F(t2);
  n.fu.has(e.targetId) || (n.fu.set(e.targetId, e), Gu(n) ? Ku(n) : ac2(n).No() && qu(n, e));
}
function Lu(t2, e) {
  const n = F(t2), s = ac2(n);
  n.fu.delete(e), s.No() && Uu(n, e), 0 === n.fu.size && (s.No() ? s.$o() : Qu(n) && n.mu.set("Unknown"));
}
function qu(t2, e) {
  t2.gu.Ot(e.targetId), ac2(t2).jo(e);
}
function Uu(t2, e) {
  t2.gu.Ot(e), ac2(t2).Wo(e);
}
function Ku(t2) {
  t2.gu = new _i({
    getRemoteKeysForTarget: (e) => t2.remoteSyncer.getRemoteKeysForTarget(e),
    ne: (e) => t2.fu.get(e) || null
  }), ac2(t2).start(), t2.mu.ou();
}
function Gu(t2) {
  return Qu(t2) && !ac2(t2).xo() && t2.fu.size > 0;
}
function Qu(t2) {
  return 0 === F(t2).du.size;
}
function zu(t2) {
  t2.gu = void 0;
}
async function ju(t2) {
  t2.fu.forEach((e, n) => {
    qu(t2, e);
  });
}
async function Wu(t2, e) {
  zu(t2), Gu(t2) ? (t2.mu.au(e), Ku(t2)) : t2.mu.set("Unknown");
}
async function Hu(t2, e, n) {
  if (t2.mu.set("Online"), e instanceof di && 2 === e.state && e.cause)
    try {
      await async function(t3, e2) {
        const n2 = e2.cause;
        for (const s of e2.targetIds)
          t3.fu.has(s) && (await t3.remoteSyncer.rejectListen(s, n2), t3.fu.delete(s), t3.gu.removeTarget(s));
      }(t2, e);
    } catch (n2) {
      C2("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), n2), await Ju(t2, n2);
    }
  else if (e instanceof li ? t2.gu.Kt(e) : e instanceof fi ? t2.gu.Jt(e) : t2.gu.zt(e), !n.isEqual(st.min()))
    try {
      const e2 = await Jo(t2.localStore);
      n.compareTo(e2) >= 0 && await function(t3, e3) {
        const n2 = t3.gu.Xt(e3);
        return n2.targetChanges.forEach((n3, s) => {
          if (n3.resumeToken.approximateByteSize() > 0) {
            const i = t3.fu.get(s);
            i && t3.fu.set(s, i.withResumeToken(n3.resumeToken, e3));
          }
        }), n2.targetMismatches.forEach((e4) => {
          const n3 = t3.fu.get(e4);
          if (!n3)
            return;
          t3.fu.set(e4, n3.withResumeToken(be.EMPTY_BYTE_STRING, n3.snapshotVersion)), Uu(t3, e4);
          const s = new tr(n3.target, e4, 1, n3.sequenceNumber);
          qu(t3, s);
        }), t3.remoteSyncer.applyRemoteEvent(n2);
      }(t2, n);
    } catch (e2) {
      C2("RemoteStore", "Failed to raise snapshot:", e2), await Ju(t2, e2);
    }
}
async function Ju(t2, e, n) {
  if (!Vt(e))
    throw e;
  t2.du.add(1), await Fu(t2), t2.mu.set("Offline"), n || (n = () => Jo(t2.localStore)), t2.asyncQueue.enqueueRetryable(async () => {
    C2("RemoteStore", "Retrying IndexedDB access"), await n(), t2.du.delete(1), await Mu(t2);
  });
}
function Yu(t2, e) {
  return e().catch((n) => Ju(t2, n, e));
}
async function Zu(t2) {
  const e = F(t2), n = hc2(e);
  let s = e.lu.length > 0 ? e.lu[e.lu.length - 1].batchId : -1;
  for (; Xu(e); )
    try {
      const t3 = await Xo(e.localStore, s);
      if (null === t3) {
        0 === e.lu.length && n.$o();
        break;
      }
      s = t3.batchId, tc2(e, t3);
    } catch (t3) {
      await Ju(e, t3);
    }
  ec2(e) && nc2(e);
}
function Xu(t2) {
  return Qu(t2) && t2.lu.length < 10;
}
function tc2(t2, e) {
  t2.lu.push(e);
  const n = hc2(t2);
  n.No() && n.Jo && n.Yo(e.mutations);
}
function ec2(t2) {
  return Qu(t2) && !hc2(t2).xo() && t2.lu.length > 0;
}
function nc2(t2) {
  hc2(t2).start();
}
async function sc2(t2) {
  hc2(t2).tu();
}
async function ic2(t2) {
  const e = hc2(t2);
  for (const n of t2.lu)
    e.Yo(n.mutations);
}
async function rc2(t2, e, n) {
  const s = t2.lu.shift(), i = Ys.from(s, e, n);
  await Yu(t2, () => t2.remoteSyncer.applySuccessfulWrite(i)), await Zu(t2);
}
async function oc2(t2, e) {
  e && hc2(t2).Jo && await async function(t3, e2) {
    if (n = e2.code, ri(n) && n !== B2.ABORTED) {
      const n2 = t3.lu.shift();
      hc2(t3).Oo(), await Yu(t3, () => t3.remoteSyncer.rejectFailedWrite(n2.batchId, e2)), await Zu(t3);
    }
    var n;
  }(t2, e), ec2(t2) && nc2(t2);
}
async function uc2(t2, e) {
  const n = F(t2);
  n.asyncQueue.verifyOperationInProgress(), C2("RemoteStore", "RemoteStore received new credentials");
  const s = Qu(n);
  n.du.add(3), await Fu(n), s && n.mu.set("Unknown"), await n.remoteSyncer.handleCredentialChange(e), n.du.delete(3), await Mu(n);
}
async function cc2(t2, e) {
  const n = F(t2);
  e ? (n.du.delete(2), await Mu(n)) : e || (n.du.add(2), await Fu(n), n.mu.set("Unknown"));
}
function ac2(t2) {
  return t2.yu || (t2.yu = function(t3, e, n) {
    const s = F(t3);
    return s.nu(), new Cu(e, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, n);
  }(t2.datastore, t2.asyncQueue, {
    Jr: ju.bind(null, t2),
    Zr: Wu.bind(null, t2),
    zo: Hu.bind(null, t2)
  }), t2.wu.push(async (e) => {
    e ? (t2.yu.Oo(), Gu(t2) ? Ku(t2) : t2.mu.set("Unknown")) : (await t2.yu.stop(), zu(t2));
  })), t2.yu;
}
function hc2(t2) {
  return t2.pu || (t2.pu = function(t3, e, n) {
    const s = F(t3);
    return s.nu(), new xu(e, s.connection, s.authCredentials, s.appCheckCredentials, s.serializer, n);
  }(t2.datastore, t2.asyncQueue, {
    Jr: sc2.bind(null, t2),
    Zr: oc2.bind(null, t2),
    Xo: ic2.bind(null, t2),
    Zo: rc2.bind(null, t2)
  }), t2.wu.push(async (e) => {
    e ? (t2.pu.Oo(), await Zu(t2)) : (await t2.pu.stop(), t2.lu.length > 0 && (C2("RemoteStore", `Stopping write stream with ${t2.lu.length} pending writes`), t2.lu = []));
  })), t2.pu;
}
var lc2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.timerId = e, this.targetTimeMs = n, this.op = s, this.removalCallback = i, this.deferred = new q2(), this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch((t3) => {
    });
  }
  static createAndSchedule(t2, e, n, s, i) {
    const r = Date.now() + n, o = new lc2(t2, e, r, s, i);
    return o.start(n), o;
  }
  start(t2) {
    this.timerHandle = setTimeout(() => this.handleDelayElapsed(), t2);
  }
  skipDelay() {
    return this.handleDelayElapsed();
  }
  cancel(t2) {
    null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new L2(B2.CANCELLED, "Operation cancelled" + (t2 ? ": " + t2 : ""))));
  }
  handleDelayElapsed() {
    this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then((t2) => this.deferred.resolve(t2))) : Promise.resolve());
  }
  clearTimeout() {
    null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null);
  }
};
function fc2(t2, e) {
  if (x2("AsyncQueue", `${e}: ${t2}`), Vt(t2))
    return new L2(B2.UNAVAILABLE, `${e}: ${t2}`);
  throw t2;
}
var dc2 = class {
  constructor(t2) {
    this.comparator = t2 ? (e, n) => t2(e, n) || ct.comparator(e.key, n.key) : (t3, e) => ct.comparator(t3.key, e.key), this.keyedMap = us(), this.sortedSet = new ge(this.comparator);
  }
  static emptySet(t2) {
    return new dc2(t2.comparator);
  }
  has(t2) {
    return null != this.keyedMap.get(t2);
  }
  get(t2) {
    return this.keyedMap.get(t2);
  }
  first() {
    return this.sortedSet.minKey();
  }
  last() {
    return this.sortedSet.maxKey();
  }
  isEmpty() {
    return this.sortedSet.isEmpty();
  }
  indexOf(t2) {
    const e = this.keyedMap.get(t2);
    return e ? this.sortedSet.indexOf(e) : -1;
  }
  get size() {
    return this.sortedSet.size;
  }
  forEach(t2) {
    this.sortedSet.inorderTraversal((e, n) => (t2(e), false));
  }
  add(t2) {
    const e = this.delete(t2.key);
    return e.copy(e.keyedMap.insert(t2.key, t2), e.sortedSet.insert(t2, null));
  }
  delete(t2) {
    const e = this.get(t2);
    return e ? this.copy(this.keyedMap.remove(t2), this.sortedSet.remove(e)) : this;
  }
  isEqual(t2) {
    if (!(t2 instanceof dc2))
      return false;
    if (this.size !== t2.size)
      return false;
    const e = this.sortedSet.getIterator(), n = t2.sortedSet.getIterator();
    for (; e.hasNext(); ) {
      const t3 = e.getNext().key, s = n.getNext().key;
      if (!t3.isEqual(s))
        return false;
    }
    return true;
  }
  toString() {
    const t2 = [];
    return this.forEach((e) => {
      t2.push(e.toString());
    }), 0 === t2.length ? "DocumentSet ()" : "DocumentSet (\n  " + t2.join("  \n") + "\n)";
  }
  copy(t2, e) {
    const n = new dc2();
    return n.comparator = this.comparator, n.keyedMap = t2, n.sortedSet = e, n;
  }
};
var wc2 = class {
  constructor() {
    this.Iu = new ge(ct.comparator);
  }
  track(t2) {
    const e = t2.doc.key, n = this.Iu.get(e);
    n ? 0 !== t2.type && 3 === n.type ? this.Iu = this.Iu.insert(e, t2) : 3 === t2.type && 1 !== n.type ? this.Iu = this.Iu.insert(e, {
      type: n.type,
      doc: t2.doc
    }) : 2 === t2.type && 2 === n.type ? this.Iu = this.Iu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : 2 === t2.type && 0 === n.type ? this.Iu = this.Iu.insert(e, {
      type: 0,
      doc: t2.doc
    }) : 1 === t2.type && 0 === n.type ? this.Iu = this.Iu.remove(e) : 1 === t2.type && 2 === n.type ? this.Iu = this.Iu.insert(e, {
      type: 1,
      doc: n.doc
    }) : 0 === t2.type && 1 === n.type ? this.Iu = this.Iu.insert(e, {
      type: 2,
      doc: t2.doc
    }) : O2() : this.Iu = this.Iu.insert(e, t2);
  }
  Tu() {
    const t2 = [];
    return this.Iu.inorderTraversal((e, n) => {
      t2.push(n);
    }), t2;
  }
};
var _c = class {
  constructor(t2, e, n, s, i, r, o, u, c) {
    this.query = t2, this.docs = e, this.oldDocs = n, this.docChanges = s, this.mutatedKeys = i, this.fromCache = r, this.syncStateChanged = o, this.excludesMetadataChanges = u, this.hasCachedResults = c;
  }
  static fromInitialDocuments(t2, e, n, s, i) {
    const r = [];
    return e.forEach((t3) => {
      r.push({
        type: 0,
        doc: t3
      });
    }), new _c(
      t2,
      e,
      dc2.emptySet(e),
      r,
      n,
      s,
      true,
      false,
      i
    );
  }
  get hasPendingWrites() {
    return !this.mutatedKeys.isEmpty();
  }
  isEqual(t2) {
    if (!(this.fromCache === t2.fromCache && this.hasCachedResults === t2.hasCachedResults && this.syncStateChanged === t2.syncStateChanged && this.mutatedKeys.isEqual(t2.mutatedKeys) && Jn(this.query, t2.query) && this.docs.isEqual(t2.docs) && this.oldDocs.isEqual(t2.oldDocs)))
      return false;
    const e = this.docChanges, n = t2.docChanges;
    if (e.length !== n.length)
      return false;
    for (let t3 = 0; t3 < e.length; t3++)
      if (e[t3].type !== n[t3].type || !e[t3].doc.isEqual(n[t3].doc))
        return false;
    return true;
  }
};
var mc2 = class {
  constructor() {
    this.Eu = void 0, this.listeners = [];
  }
};
var gc2 = class {
  constructor() {
    this.queries = new ss((t2) => Yn(t2), Jn), this.onlineState = "Unknown", this.Au = /* @__PURE__ */ new Set();
  }
};
async function yc2(t2, e) {
  const n = F(t2), s = e.query;
  let i = false, r = n.queries.get(s);
  if (r || (i = true, r = new mc2()), i)
    try {
      r.Eu = await n.onListen(s);
    } catch (t3) {
      const n2 = fc2(t3, `Initialization of query '${Zn(e.query)}' failed`);
      return void e.onError(n2);
    }
  if (n.queries.set(s, r), r.listeners.push(e), e.Ru(n.onlineState), r.Eu) {
    e.vu(r.Eu) && Ec2(n);
  }
}
async function pc2(t2, e) {
  const n = F(t2), s = e.query;
  let i = false;
  const r = n.queries.get(s);
  if (r) {
    const t3 = r.listeners.indexOf(e);
    t3 >= 0 && (r.listeners.splice(t3, 1), i = 0 === r.listeners.length);
  }
  if (i)
    return n.queries.delete(s), n.onUnlisten(s);
}
function Ic2(t2, e) {
  const n = F(t2);
  let s = false;
  for (const t3 of e) {
    const e2 = t3.query, i = n.queries.get(e2);
    if (i) {
      for (const e3 of i.listeners)
        e3.vu(t3) && (s = true);
      i.Eu = t3;
    }
  }
  s && Ec2(n);
}
function Tc2(t2, e, n) {
  const s = F(t2), i = s.queries.get(e);
  if (i)
    for (const t3 of i.listeners)
      t3.onError(n);
  s.queries.delete(e);
}
function Ec2(t2) {
  t2.Au.forEach((t3) => {
    t3.next();
  });
}
var Ac2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.bu = e, this.Pu = false, this.Vu = null, this.onlineState = "Unknown", this.options = n || {};
  }
  vu(t2) {
    if (!this.options.includeMetadataChanges) {
      const e2 = [];
      for (const n of t2.docChanges)
        3 !== n.type && e2.push(n);
      t2 = new _c(
        t2.query,
        t2.docs,
        t2.oldDocs,
        e2,
        t2.mutatedKeys,
        t2.fromCache,
        t2.syncStateChanged,
        true,
        t2.hasCachedResults
      );
    }
    let e = false;
    return this.Pu ? this.Su(t2) && (this.bu.next(t2), e = true) : this.Du(t2, this.onlineState) && (this.Cu(t2), e = true), this.Vu = t2, e;
  }
  onError(t2) {
    this.bu.error(t2);
  }
  Ru(t2) {
    this.onlineState = t2;
    let e = false;
    return this.Vu && !this.Pu && this.Du(this.Vu, t2) && (this.Cu(this.Vu), e = true), e;
  }
  Du(t2, e) {
    if (!t2.fromCache)
      return true;
    const n = "Offline" !== e;
    return (!this.options.xu || !n) && (!t2.docs.isEmpty() || t2.hasCachedResults || "Offline" === e);
  }
  Su(t2) {
    if (t2.docChanges.length > 0)
      return true;
    const e = this.Vu && this.Vu.hasPendingWrites !== t2.hasPendingWrites;
    return !(!t2.syncStateChanged && !e) && true === this.options.includeMetadataChanges;
  }
  Cu(t2) {
    t2 = _c.fromInitialDocuments(t2.query, t2.docs, t2.mutatedKeys, t2.fromCache, t2.hasCachedResults), this.Pu = true, this.bu.next(t2);
  }
};
var Rc2 = class {
  constructor(t2, e) {
    this.Nu = t2, this.byteLength = e;
  }
  ku() {
    return "metadata" in this.Nu;
  }
};
var vc2 = class {
  constructor(t2) {
    this.serializer = t2;
  }
  Hi(t2) {
    return Si(this.serializer, t2);
  }
  Ji(t2) {
    return t2.metadata.exists ? Oi(this.serializer, t2.document, false) : on.newNoDocument(this.Hi(t2.metadata.name), this.Yi(t2.metadata.readTime));
  }
  Yi(t2) {
    return vi(t2);
  }
};
var bc2 = class {
  constructor(t2, e, n) {
    this.Ou = t2, this.localStore = e, this.serializer = n, this.queries = [], this.documents = [], this.collectionGroups = /* @__PURE__ */ new Set(), this.progress = Pc2(t2);
  }
  $u(t2) {
    this.progress.bytesLoaded += t2.byteLength;
    let e = this.progress.documentsLoaded;
    if (t2.Nu.namedQuery)
      this.queries.push(t2.Nu.namedQuery);
    else if (t2.Nu.documentMetadata) {
      this.documents.push({
        metadata: t2.Nu.documentMetadata
      }), t2.Nu.documentMetadata.exists || ++e;
      const n = rt.fromString(t2.Nu.documentMetadata.name);
      this.collectionGroups.add(n.get(n.length - 2));
    } else
      t2.Nu.document && (this.documents[this.documents.length - 1].document = t2.Nu.document, ++e);
    return e !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = e, Object.assign({}, this.progress)) : null;
  }
  Mu(t2) {
    const e = /* @__PURE__ */ new Map(), n = new vc2(this.serializer);
    for (const s of t2)
      if (s.metadata.queries) {
        const t3 = n.Hi(s.metadata.name);
        for (const n2 of s.metadata.queries) {
          const s2 = (e.get(n2) || ws()).add(t3);
          e.set(n2, s2);
        }
      }
    return e;
  }
  async complete() {
    const t2 = await ou(this.localStore, new vc2(this.serializer), this.documents, this.Ou.id), e = this.Mu(this.documents);
    for (const t3 of this.queries)
      await uu(this.localStore, t3, e.get(t3.name));
    return this.progress.taskState = "Success", {
      progress: this.progress,
      Fu: this.collectionGroups,
      Bu: t2
    };
  }
};
function Pc2(t2) {
  return {
    taskState: "Running",
    documentsLoaded: 0,
    bytesLoaded: 0,
    totalDocuments: t2.totalDocuments,
    totalBytes: t2.totalBytes
  };
}
var Vc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Sc2 = class {
  constructor(t2) {
    this.key = t2;
  }
};
var Dc2 = class {
  constructor(t2, e) {
    this.query = t2, this.Lu = e, this.qu = null, this.hasCachedResults = false, this.current = false, this.Uu = ws(), this.mutatedKeys = ws(), this.Ku = es(t2), this.Gu = new dc2(this.Ku);
  }
  get Qu() {
    return this.Lu;
  }
  zu(t2, e) {
    const n = e ? e.ju : new wc2(), s = e ? e.Gu : this.Gu;
    let i = e ? e.mutatedKeys : this.mutatedKeys, r = s, o = false;
    const u = "F" === this.query.limitType && s.size === this.query.limit ? s.last() : null, c = "L" === this.query.limitType && s.size === this.query.limit ? s.first() : null;
    if (t2.inorderTraversal((t3, e2) => {
      const a = s.get(t3), h = Xn(this.query, e2) ? e2 : null, l2 = !!a && this.mutatedKeys.has(a.key), f = !!h && (h.hasLocalMutations || this.mutatedKeys.has(h.key) && h.hasCommittedMutations);
      let d = false;
      if (a && h) {
        a.data.isEqual(h.data) ? l2 !== f && (n.track({
          type: 3,
          doc: h
        }), d = true) : this.Wu(a, h) || (n.track({
          type: 2,
          doc: h
        }), d = true, (u && this.Ku(h, u) > 0 || c && this.Ku(h, c) < 0) && (o = true));
      } else
        !a && h ? (n.track({
          type: 0,
          doc: h
        }), d = true) : a && !h && (n.track({
          type: 1,
          doc: a
        }), d = true, (u || c) && (o = true));
      d && (h ? (r = r.add(h), i = f ? i.add(t3) : i.delete(t3)) : (r = r.delete(t3), i = i.delete(t3)));
    }), null !== this.query.limit)
      for (; r.size > this.query.limit; ) {
        const t3 = "F" === this.query.limitType ? r.last() : r.first();
        r = r.delete(t3.key), i = i.delete(t3.key), n.track({
          type: 1,
          doc: t3
        });
      }
    return {
      Gu: r,
      ju: n,
      Mi: o,
      mutatedKeys: i
    };
  }
  Wu(t2, e) {
    return t2.hasLocalMutations && e.hasCommittedMutations && !e.hasLocalMutations;
  }
  applyChanges(t2, e, n) {
    const s = this.Gu;
    this.Gu = t2.Gu, this.mutatedKeys = t2.mutatedKeys;
    const i = t2.ju.Tu();
    i.sort((t3, e2) => function(t4, e3) {
      const n2 = (t5) => {
        switch (t5) {
          case 0:
            return 1;
          case 2:
          case 3:
            return 2;
          case 1:
            return 0;
          default:
            return O2();
        }
      };
      return n2(t4) - n2(e3);
    }(t3.type, e2.type) || this.Ku(t3.doc, e2.doc)), this.Hu(n);
    const r = e ? this.Ju() : [], o = 0 === this.Uu.size && this.current ? 1 : 0, u = o !== this.qu;
    if (this.qu = o, 0 !== i.length || u) {
      return {
        snapshot: new _c(
          this.query,
          t2.Gu,
          s,
          i,
          t2.mutatedKeys,
          0 === o,
          u,
          false,
          !!n && n.resumeToken.approximateByteSize() > 0
        ),
        Yu: r
      };
    }
    return {
      Yu: r
    };
  }
  Ru(t2) {
    return this.current && "Offline" === t2 ? (this.current = false, this.applyChanges(
      {
        Gu: this.Gu,
        ju: new wc2(),
        mutatedKeys: this.mutatedKeys,
        Mi: false
      },
      false
    )) : {
      Yu: []
    };
  }
  Zu(t2) {
    return !this.Lu.has(t2) && (!!this.Gu.has(t2) && !this.Gu.get(t2).hasLocalMutations);
  }
  Hu(t2) {
    t2 && (t2.addedDocuments.forEach((t3) => this.Lu = this.Lu.add(t3)), t2.modifiedDocuments.forEach((t3) => {
    }), t2.removedDocuments.forEach((t3) => this.Lu = this.Lu.delete(t3)), this.current = t2.current);
  }
  Ju() {
    if (!this.current)
      return [];
    const t2 = this.Uu;
    this.Uu = ws(), this.Gu.forEach((t3) => {
      this.Zu(t3.key) && (this.Uu = this.Uu.add(t3.key));
    });
    const e = [];
    return t2.forEach((t3) => {
      this.Uu.has(t3) || e.push(new Sc2(t3));
    }), this.Uu.forEach((n) => {
      t2.has(n) || e.push(new Vc2(n));
    }), e;
  }
  Xu(t2) {
    this.Lu = t2.Wi, this.Uu = ws();
    const e = this.zu(t2.documents);
    return this.applyChanges(e, true);
  }
  tc() {
    return _c.fromInitialDocuments(this.query, this.Gu, this.mutatedKeys, 0 === this.qu, this.hasCachedResults);
  }
};
var Cc2 = class {
  constructor(t2, e, n) {
    this.query = t2, this.targetId = e, this.view = n;
  }
};
var xc2 = class {
  constructor(t2) {
    this.key = t2, this.ec = false;
  }
};
var Nc2 = class {
  constructor(t2, e, n, s, i, r) {
    this.localStore = t2, this.remoteStore = e, this.eventManager = n, this.sharedClientState = s, this.currentUser = i, this.maxConcurrentLimboResolutions = r, this.nc = {}, this.sc = new ss((t3) => Yn(t3), Jn), this.ic = /* @__PURE__ */ new Map(), this.rc = /* @__PURE__ */ new Set(), this.oc = new ge(ct.comparator), this.uc = /* @__PURE__ */ new Map(), this.cc = new Vo(), this.ac = {}, this.hc = /* @__PURE__ */ new Map(), this.lc = so.bn(), this.onlineState = "Unknown", this.fc = void 0;
  }
  get isPrimaryClient() {
    return true === this.fc;
  }
};
async function kc2(t2, e) {
  const n = aa2(t2);
  let s, i;
  const r = n.sc.get(e);
  if (r)
    s = r.targetId, n.sharedClientState.addLocalQueryTarget(s), i = r.view.tc();
  else {
    const t3 = await tu(n.localStore, jn(e));
    n.isPrimaryClient && Bu(n.remoteStore, t3);
    const r2 = n.sharedClientState.addLocalQueryTarget(t3.targetId);
    s = t3.targetId, i = await Oc2(n, e, s, "current" === r2, t3.resumeToken);
  }
  return i;
}
async function Oc2(t2, e, n, s, i) {
  t2.dc = (e2, n2, s2) => async function(t3, e3, n3, s3) {
    let i2 = e3.view.zu(n3);
    i2.Mi && (i2 = await nu(
      t3.localStore,
      e3.query,
      false
    ).then(({ documents: t4 }) => e3.view.zu(t4, i2)));
    const r2 = s3 && s3.targetChanges.get(e3.targetId), o2 = e3.view.applyChanges(
      i2,
      t3.isPrimaryClient,
      r2
    );
    return Wc2(t3, e3.targetId, o2.Yu), o2.snapshot;
  }(t2, e2, n2, s2);
  const r = await nu(
    t2.localStore,
    e,
    true
  ), o = new Dc2(e, r.Wi), u = o.zu(r.documents), c = hi.createSynthesizedTargetChangeForCurrentChange(n, s && "Offline" !== t2.onlineState, i), a = o.applyChanges(
    u,
    t2.isPrimaryClient,
    c
  );
  Wc2(t2, n, a.Yu);
  const h = new Cc2(e, n, o);
  return t2.sc.set(e, h), t2.ic.has(n) ? t2.ic.get(n).push(e) : t2.ic.set(n, [e]), a.snapshot;
}
async function $c2(t2, e) {
  const n = F(t2), s = n.sc.get(e), i = n.ic.get(s.targetId);
  if (i.length > 1)
    return n.ic.set(s.targetId, i.filter((t3) => !Jn(t3, e))), void n.sc.delete(e);
  if (n.isPrimaryClient) {
    n.sharedClientState.removeLocalQueryTarget(s.targetId);
    n.sharedClientState.isActiveQueryTarget(s.targetId) || await eu(
      n.localStore,
      s.targetId,
      false
    ).then(() => {
      n.sharedClientState.clearQueryState(s.targetId), Lu(n.remoteStore, s.targetId), zc2(n, s.targetId);
    }).catch(Et);
  } else
    zc2(n, s.targetId), await eu(
      n.localStore,
      s.targetId,
      true
    );
}
async function Mc2(t2, e, n) {
  const s = ha2(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = F(t4), s2 = nt.now(), i = e2.reduce((t5, e3) => t5.add(e3.key), ws());
      let r, o;
      return n2.persistence.runTransaction("Locally write mutations", "readwrite", (t5) => {
        let u = rs(), c = ws();
        return n2.Ki.getEntries(t5, i).next((t6) => {
          u = t6, u.forEach((t7, e3) => {
            e3.isValidDocument() || (c = c.add(t7));
          });
        }).next(() => n2.localDocuments.getOverlayedDocuments(t5, u)).next((i2) => {
          r = i2;
          const o2 = [];
          for (const t6 of e2) {
            const e3 = qs(t6, r.get(t6.key).overlayedDocument);
            null != e3 && o2.push(new Gs(t6.key, e3, rn(e3.value.mapValue), Os.exists(true)));
          }
          return n2.mutationQueue.addMutationBatch(t5, s2, o2, e2);
        }).next((e3) => {
          o = e3;
          const s3 = e3.applyToLocalDocumentSet(r, c);
          return n2.documentOverlayCache.saveOverlays(t5, e3.batchId, s3);
        });
      }).then(() => ({
        batchId: o.batchId,
        changes: cs(r)
      }));
    }(s.localStore, e);
    s.sharedClientState.addPendingMutation(t3.batchId), function(t4, e2, n2) {
      let s2 = t4.ac[t4.currentUser.toKey()];
      s2 || (s2 = new ge(X2));
      s2 = s2.insert(e2, n2), t4.ac[t4.currentUser.toKey()] = s2;
    }(s, t3.batchId, n), await Yc2(s, t3.changes), await Zu(s.remoteStore);
  } catch (t3) {
    const e2 = fc2(t3, "Failed to persist write");
    n.reject(e2);
  }
}
async function Fc2(t2, e) {
  const n = F(t2);
  try {
    const t3 = await Yo(n.localStore, e);
    e.targetChanges.forEach((t4, e2) => {
      const s = n.uc.get(e2);
      s && ($(t4.addedDocuments.size + t4.modifiedDocuments.size + t4.removedDocuments.size <= 1), t4.addedDocuments.size > 0 ? s.ec = true : t4.modifiedDocuments.size > 0 ? $(s.ec) : t4.removedDocuments.size > 0 && ($(s.ec), s.ec = false));
    }), await Yc2(n, t3, e);
  } catch (t3) {
    await Et(t3);
  }
}
function Bc2(t2, e, n) {
  const s = F(t2);
  if (s.isPrimaryClient && 0 === n || !s.isPrimaryClient && 1 === n) {
    const t3 = [];
    s.sc.forEach((n2, s2) => {
      const i = s2.view.Ru(e);
      i.snapshot && t3.push(i.snapshot);
    }), function(t4, e2) {
      const n2 = F(t4);
      n2.onlineState = e2;
      let s2 = false;
      n2.queries.forEach((t5, n3) => {
        for (const t6 of n3.listeners)
          t6.Ru(e2) && (s2 = true);
      }), s2 && Ec2(n2);
    }(s.eventManager, e), t3.length && s.nc.zo(t3), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e);
  }
}
async function Lc2(t2, e, n) {
  const s = F(t2);
  s.sharedClientState.updateQueryState(e, "rejected", n);
  const i = s.uc.get(e), r = i && i.key;
  if (r) {
    let t3 = new ge(ct.comparator);
    t3 = t3.insert(r, on.newNoDocument(r, st.min()));
    const n2 = ws().add(r), i2 = new ai(
      st.min(),
      /* @__PURE__ */ new Map(),
      new Ie(X2),
      t3,
      n2
    );
    await Fc2(s, i2), s.oc = s.oc.remove(r), s.uc.delete(e), Jc2(s);
  } else
    await eu(
      s.localStore,
      e,
      false
    ).then(() => zc2(s, e, n)).catch(Et);
}
async function qc2(t2, e) {
  const n = F(t2), s = e.batch.batchId;
  try {
    const t3 = await Ho(n.localStore, e);
    Qc2(n, s, null), Gc2(n, s), n.sharedClientState.updateMutationState(s, "acknowledged"), await Yc2(n, t3);
  } catch (t3) {
    await Et(t3);
  }
}
async function Uc2(t2, e, n) {
  const s = F(t2);
  try {
    const t3 = await function(t4, e2) {
      const n2 = F(t4);
      return n2.persistence.runTransaction("Reject batch", "readwrite-primary", (t5) => {
        let s2;
        return n2.mutationQueue.lookupMutationBatch(t5, e2).next((e3) => ($(null !== e3), s2 = e3.keys(), n2.mutationQueue.removeMutationBatch(t5, e3))).next(() => n2.mutationQueue.performConsistencyCheck(t5)).next(() => n2.documentOverlayCache.removeOverlaysForBatchId(t5, s2, e2)).next(() => n2.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(t5, s2)).next(() => n2.localDocuments.getDocuments(t5, s2));
      });
    }(s.localStore, e);
    Qc2(s, e, n), Gc2(s, e), s.sharedClientState.updateMutationState(e, "rejected", n), await Yc2(s, t3);
  } catch (n2) {
    await Et(n2);
  }
}
async function Kc2(t2, e) {
  const n = F(t2);
  Qu(n.remoteStore) || C2("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled.");
  try {
    const t3 = await function(t4) {
      const e2 = F(t4);
      return e2.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", (t5) => e2.mutationQueue.getHighestUnacknowledgedBatchId(t5));
    }(n.localStore);
    if (-1 === t3)
      return void e.resolve();
    const s = n.hc.get(t3) || [];
    s.push(e), n.hc.set(t3, s);
  } catch (t3) {
    const n2 = fc2(t3, "Initialization of waitForPendingWrites() operation failed");
    e.reject(n2);
  }
}
function Gc2(t2, e) {
  (t2.hc.get(e) || []).forEach((t3) => {
    t3.resolve();
  }), t2.hc.delete(e);
}
function Qc2(t2, e, n) {
  const s = F(t2);
  let i = s.ac[s.currentUser.toKey()];
  if (i) {
    const t3 = i.get(e);
    t3 && (n ? t3.reject(n) : t3.resolve(), i = i.remove(e)), s.ac[s.currentUser.toKey()] = i;
  }
}
function zc2(t2, e, n = null) {
  t2.sharedClientState.removeLocalQueryTarget(e);
  for (const s of t2.ic.get(e))
    t2.sc.delete(s), n && t2.nc.wc(s, n);
  if (t2.ic.delete(e), t2.isPrimaryClient) {
    t2.cc.hs(e).forEach((e2) => {
      t2.cc.containsKey(e2) || jc2(t2, e2);
    });
  }
}
function jc2(t2, e) {
  t2.rc.delete(e.path.canonicalString());
  const n = t2.oc.get(e);
  null !== n && (Lu(t2.remoteStore, n), t2.oc = t2.oc.remove(e), t2.uc.delete(n), Jc2(t2));
}
function Wc2(t2, e, n) {
  for (const s of n)
    if (s instanceof Vc2)
      t2.cc.addReference(s.key, e), Hc2(t2, s);
    else if (s instanceof Sc2) {
      C2("SyncEngine", "Document no longer in limbo: " + s.key), t2.cc.removeReference(s.key, e);
      t2.cc.containsKey(s.key) || jc2(t2, s.key);
    } else
      O2();
}
function Hc2(t2, e) {
  const n = e.key, s = n.path.canonicalString();
  t2.oc.get(n) || t2.rc.has(s) || (C2("SyncEngine", "New document in limbo: " + n), t2.rc.add(s), Jc2(t2));
}
function Jc2(t2) {
  for (; t2.rc.size > 0 && t2.oc.size < t2.maxConcurrentLimboResolutions; ) {
    const e = t2.rc.values().next().value;
    t2.rc.delete(e);
    const n = new ct(rt.fromString(e)), s = t2.lc.next();
    t2.uc.set(s, new xc2(n)), t2.oc = t2.oc.insert(n, s), Bu(t2.remoteStore, new tr(jn(qn(n.path)), s, 2, Ot.ct));
  }
}
async function Yc2(t2, e, n) {
  const s = F(t2), i = [], r = [], o = [];
  s.sc.isEmpty() || (s.sc.forEach((t3, u) => {
    o.push(s.dc(u, e, n).then((t4) => {
      if ((t4 || n) && s.isPrimaryClient && s.sharedClientState.updateQueryState(u.targetId, (null == t4 ? void 0 : t4.fromCache) ? "not-current" : "current"), t4) {
        i.push(t4);
        const e2 = Go.Di(u.targetId, t4);
        r.push(e2);
      }
    }));
  }), await Promise.all(o), s.nc.zo(i), await async function(t3, e2) {
    const n2 = F(t3);
    try {
      await n2.persistence.runTransaction("notifyLocalViewChanges", "readwrite", (t4) => At.forEach(e2, (e3) => At.forEach(e3.Vi, (s2) => n2.persistence.referenceDelegate.addReference(t4, e3.targetId, s2)).next(() => At.forEach(e3.Si, (s2) => n2.persistence.referenceDelegate.removeReference(t4, e3.targetId, s2)))));
    } catch (t4) {
      if (!Vt(t4))
        throw t4;
      C2("LocalStore", "Failed to update sequence numbers: " + t4);
    }
    for (const t4 of e2) {
      const e3 = t4.targetId;
      if (!t4.fromCache) {
        const t5 = n2.Li.get(e3), s2 = t5.snapshotVersion, i2 = t5.withLastLimboFreeSnapshotVersion(s2);
        n2.Li = n2.Li.insert(e3, i2);
      }
    }
  }(s.localStore, r));
}
async function Zc2(t2, e) {
  const n = F(t2);
  if (!n.currentUser.isEqual(e)) {
    C2("SyncEngine", "User change. New user:", e.toKey());
    const t3 = await Wo(n.localStore, e);
    n.currentUser = e, function(t4, e2) {
      t4.hc.forEach((t5) => {
        t5.forEach((t6) => {
          t6.reject(new L2(B2.CANCELLED, e2));
        });
      }), t4.hc.clear();
    }(n, "'waitForPendingWrites' promise is rejected due to a user change."), n.sharedClientState.handleUserChange(e, t3.removedBatchIds, t3.addedBatchIds), await Yc2(n, t3.Qi);
  }
}
function Xc2(t2, e) {
  const n = F(t2), s = n.uc.get(e);
  if (s && s.ec)
    return ws().add(s.key);
  {
    let t3 = ws();
    const s2 = n.ic.get(e);
    if (!s2)
      return t3;
    for (const e2 of s2) {
      const s3 = n.sc.get(e2);
      t3 = t3.unionWith(s3.view.Qu);
    }
    return t3;
  }
}
async function ta2(t2, e) {
  const n = F(t2), s = await nu(
    n.localStore,
    e.query,
    true
  ), i = e.view.Xu(s);
  return n.isPrimaryClient && Wc2(n, e.targetId, i.Yu), i;
}
async function ea2(t2, e) {
  const n = F(t2);
  return iu(n.localStore, e).then((t3) => Yc2(n, t3));
}
async function na2(t2, e, n, s) {
  const i = F(t2), r = await function(t3, e2) {
    const n2 = F(t3), s2 = F(n2.mutationQueue);
    return n2.persistence.runTransaction("Lookup mutation documents", "readonly", (t4) => s2.In(t4, e2).next((e3) => e3 ? n2.localDocuments.getDocuments(t4, e3) : At.resolve(null)));
  }(i.localStore, e);
  null !== r ? ("pending" === n ? await Zu(i.remoteStore) : "acknowledged" === n || "rejected" === n ? (Qc2(i, e, s || null), Gc2(i, e), function(t3, e2) {
    F(F(t3).mutationQueue).En(e2);
  }(i.localStore, e)) : O2(), await Yc2(i, r)) : C2("SyncEngine", "Cannot apply mutation batch with id: " + e);
}
async function sa2(t2, e) {
  const n = F(t2);
  if (aa2(n), ha2(n), true === e && true !== n.fc) {
    const t3 = n.sharedClientState.getAllActiveQueryTargets(), e2 = await ia2(n, t3.toArray());
    n.fc = true, await cc2(n.remoteStore, true);
    for (const t4 of e2)
      Bu(n.remoteStore, t4);
  } else if (false === e && false !== n.fc) {
    const t3 = [];
    let e2 = Promise.resolve();
    n.ic.forEach((s, i) => {
      n.sharedClientState.isLocalQueryTarget(i) ? t3.push(i) : e2 = e2.then(() => (zc2(n, i), eu(
        n.localStore,
        i,
        true
      ))), Lu(n.remoteStore, i);
    }), await e2, await ia2(n, t3), function(t4) {
      const e3 = F(t4);
      e3.uc.forEach((t5, n2) => {
        Lu(e3.remoteStore, n2);
      }), e3.cc.ls(), e3.uc = /* @__PURE__ */ new Map(), e3.oc = new ge(ct.comparator);
    }(n), n.fc = false, await cc2(n.remoteStore, false);
  }
}
async function ia2(t2, e, n) {
  const s = F(t2), i = [], r = [];
  for (const t3 of e) {
    let e2;
    const n2 = s.ic.get(t3);
    if (n2 && 0 !== n2.length) {
      e2 = await tu(s.localStore, jn(n2[0]));
      for (const t4 of n2) {
        const e3 = s.sc.get(t4), n3 = await ta2(s, e3);
        n3.snapshot && r.push(n3.snapshot);
      }
    } else {
      const n3 = await su(s.localStore, t3);
      e2 = await tu(s.localStore, n3), await Oc2(
        s,
        ra2(n3),
        t3,
        false,
        e2.resumeToken
      );
    }
    i.push(e2);
  }
  return s.nc.zo(r), i;
}
function ra2(t2) {
  return Ln(t2.path, t2.collectionGroup, t2.orderBy, t2.filters, t2.limit, "F", t2.startAt, t2.endAt);
}
function oa2(t2) {
  const e = F(t2);
  return F(F(e.localStore).persistence).bi();
}
async function ua2(t2, e, n, s) {
  const i = F(t2);
  if (i.fc)
    return void C2("SyncEngine", "Ignoring unexpected query state notification.");
  const r = i.ic.get(e);
  if (r && r.length > 0)
    switch (n) {
      case "current":
      case "not-current": {
        const t3 = await iu(i.localStore, ts(r[0])), s2 = ai.createSynthesizedRemoteEventForCurrentChange(e, "current" === n, be.EMPTY_BYTE_STRING);
        await Yc2(i, t3, s2);
        break;
      }
      case "rejected":
        await eu(
          i.localStore,
          e,
          true
        ), zc2(i, e, s);
        break;
      default:
        O2();
    }
}
async function ca2(t2, e, n) {
  const s = aa2(t2);
  if (s.fc) {
    for (const t3 of e) {
      if (s.ic.has(t3)) {
        C2("SyncEngine", "Adding an already active target " + t3);
        continue;
      }
      const e2 = await su(s.localStore, t3), n2 = await tu(s.localStore, e2);
      await Oc2(
        s,
        ra2(e2),
        n2.targetId,
        false,
        n2.resumeToken
      ), Bu(s.remoteStore, n2);
    }
    for (const t3 of n)
      s.ic.has(t3) && await eu(
        s.localStore,
        t3,
        false
      ).then(() => {
        Lu(s.remoteStore, t3), zc2(s, t3);
      }).catch(Et);
  }
}
function aa2(t2) {
  const e = F(t2);
  return e.remoteStore.remoteSyncer.applyRemoteEvent = Fc2.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Xc2.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = Lc2.bind(null, e), e.nc.zo = Ic2.bind(null, e.eventManager), e.nc.wc = Tc2.bind(null, e.eventManager), e;
}
function ha2(t2) {
  const e = F(t2);
  return e.remoteStore.remoteSyncer.applySuccessfulWrite = qc2.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = Uc2.bind(null, e), e;
}
function la2(t2, e, n) {
  const s = F(t2);
  (async function(t3, e2, n2) {
    try {
      const s2 = await e2.getMetadata();
      if (await function(t4, e3) {
        const n3 = F(t4), s3 = vi(e3.createTime);
        return n3.persistence.runTransaction("hasNewerBundle", "readonly", (t5) => n3.xs.getBundleMetadata(t5, e3.id)).then((t5) => !!t5 && t5.createTime.compareTo(s3) >= 0);
      }(t3.localStore, s2))
        return await e2.close(), n2._completeWith(function(t4) {
          return {
            taskState: "Success",
            documentsLoaded: t4.totalDocuments,
            bytesLoaded: t4.totalBytes,
            totalDocuments: t4.totalDocuments,
            totalBytes: t4.totalBytes
          };
        }(s2)), Promise.resolve(/* @__PURE__ */ new Set());
      n2._updateProgress(Pc2(s2));
      const i = new bc2(s2, t3.localStore, e2.serializer);
      let r = await e2._c();
      for (; r; ) {
        const t4 = await i.$u(r);
        t4 && n2._updateProgress(t4), r = await e2._c();
      }
      const o = await i.complete();
      return await Yc2(
        t3,
        o.Bu,
        void 0
      ), await function(t4, e3) {
        const n3 = F(t4);
        return n3.persistence.runTransaction("Save bundle", "readwrite", (t5) => n3.xs.saveBundleMetadata(t5, e3));
      }(t3.localStore, s2), n2._completeWith(o.progress), Promise.resolve(o.Fu);
    } catch (t4) {
      return N2("SyncEngine", `Loading bundle failed with ${t4}`), n2._failWith(t4), Promise.resolve(/* @__PURE__ */ new Set());
    }
  })(s, e, n).then((t3) => {
    s.sharedClientState.notifyBundleLoaded(t3);
  });
}
var fa2 = class {
  constructor() {
    this.synchronizeTabs = false;
  }
  async initialize(t2) {
    this.serializer = Vu(t2.databaseInfo.databaseId), this.sharedClientState = this.createSharedClientState(t2), this.persistence = this.createPersistence(t2), await this.persistence.start(), this.localStore = this.createLocalStore(t2), this.gcScheduler = this.createGarbageCollectionScheduler(t2, this.localStore), this.indexBackfillerScheduler = this.createIndexBackfillerScheduler(t2, this.localStore);
  }
  createGarbageCollectionScheduler(t2, e) {
    return null;
  }
  createIndexBackfillerScheduler(t2, e) {
    return null;
  }
  createLocalStore(t2) {
    return jo(this.persistence, new Qo(), t2.initialUser, this.serializer);
  }
  createPersistence(t2) {
    return new ko($o.Fs, this.serializer);
  }
  createSharedClientState(t2) {
    return new gu();
  }
  async terminate() {
    this.gcScheduler && this.gcScheduler.stop(), await this.sharedClientState.shutdown(), await this.persistence.shutdown();
  }
};
var da2 = class extends fa2 {
  constructor(t2, e, n) {
    super(), this.mc = t2, this.cacheSizeBytes = e, this.forceOwnership = n, this.synchronizeTabs = false;
  }
  async initialize(t2) {
    await super.initialize(t2), await this.mc.initialize(this, t2), await ha2(this.mc.syncEngine), await Zu(this.mc.remoteStore), await this.persistence.hi(() => (this.gcScheduler && !this.gcScheduler.started && this.gcScheduler.start(), this.indexBackfillerScheduler && !this.indexBackfillerScheduler.started && this.indexBackfillerScheduler.start(), Promise.resolve()));
  }
  createLocalStore(t2) {
    return jo(this.persistence, new Qo(), t2.initialUser, this.serializer);
  }
  createGarbageCollectionScheduler(t2, e) {
    const n = this.persistence.referenceDelegate.garbageCollector;
    return new ho(n, t2.asyncQueue, e);
  }
  createIndexBackfillerScheduler(t2, e) {
    const n = new kt(e, this.persistence);
    return new Nt(t2.asyncQueue, n);
  }
  createPersistence(t2) {
    const e = Ko(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey), n = void 0 !== this.cacheSizeBytes ? Hr.withCacheSize(this.cacheSizeBytes) : Hr.DEFAULT;
    return new Lo(this.synchronizeTabs, e, t2.clientId, n, t2.asyncQueue, bu(), Pu(), this.serializer, this.sharedClientState, !!this.forceOwnership);
  }
  createSharedClientState(t2) {
    return new gu();
  }
};
var wa2 = class extends da2 {
  constructor(t2, e) {
    super(t2, e, false), this.mc = t2, this.cacheSizeBytes = e, this.synchronizeTabs = true;
  }
  async initialize(t2) {
    await super.initialize(t2);
    const e = this.mc.syncEngine;
    this.sharedClientState instanceof mu && (this.sharedClientState.syncEngine = {
      $r: na2.bind(null, e),
      Mr: ua2.bind(null, e),
      Fr: ca2.bind(null, e),
      bi: oa2.bind(null, e),
      Or: ea2.bind(null, e)
    }, await this.sharedClientState.start()), await this.persistence.hi(async (t3) => {
      await sa2(this.mc.syncEngine, t3), this.gcScheduler && (t3 && !this.gcScheduler.started ? this.gcScheduler.start() : t3 || this.gcScheduler.stop()), this.indexBackfillerScheduler && (t3 && !this.indexBackfillerScheduler.started ? this.indexBackfillerScheduler.start() : t3 || this.indexBackfillerScheduler.stop());
    });
  }
  createSharedClientState(t2) {
    const e = bu();
    if (!mu.D(e))
      throw new L2(B2.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage.");
    const n = Ko(t2.databaseInfo.databaseId, t2.databaseInfo.persistenceKey);
    return new mu(e, t2.asyncQueue, n, t2.clientId, t2.initialUser);
  }
};
var _a = class {
  async initialize(t2, e) {
    this.localStore || (this.localStore = t2.localStore, this.sharedClientState = t2.sharedClientState, this.datastore = this.createDatastore(e), this.remoteStore = this.createRemoteStore(e), this.eventManager = this.createEventManager(e), this.syncEngine = this.createSyncEngine(
      e,
      !t2.synchronizeTabs
    ), this.sharedClientState.onlineStateHandler = (t3) => Bc2(this.syncEngine, t3, 1), this.remoteStore.remoteSyncer.handleCredentialChange = Zc2.bind(null, this.syncEngine), await cc2(this.remoteStore, this.syncEngine.isPrimaryClient));
  }
  createEventManager(t2) {
    return new gc2();
  }
  createDatastore(t2) {
    const e = Vu(t2.databaseInfo.databaseId), n = (s = t2.databaseInfo, new vu(s));
    var s;
    return function(t3, e2, n2, s2) {
      return new Nu(t3, e2, n2, s2);
    }(t2.authCredentials, t2.appCheckCredentials, n, e);
  }
  createRemoteStore(t2) {
    return e = this.localStore, n = this.datastore, s = t2.asyncQueue, i = (t3) => Bc2(this.syncEngine, t3, 0), r = pu.D() ? new pu() : new yu(), new $u(e, n, s, i, r);
    var e, n, s, i, r;
  }
  createSyncEngine(t2, e) {
    return function(t3, e2, n, s, i, r, o) {
      const u = new Nc2(t3, e2, n, s, i, r);
      return o && (u.fc = true), u;
    }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, t2.initialUser, t2.maxConcurrentLimboResolutions, e);
  }
  terminate() {
    return async function(t2) {
      const e = F(t2);
      C2("RemoteStore", "RemoteStore shutting down."), e.du.add(5), await Fu(e), e._u.shutdown(), e.mu.set("Unknown");
    }(this.remoteStore);
  }
};
function ma2(t2, e = 10240) {
  let n = 0;
  return {
    async read() {
      if (n < t2.byteLength) {
        const s = {
          value: t2.slice(n, n + e),
          done: false
        };
        return n += e, s;
      }
      return {
        done: true
      };
    },
    async cancel() {
    },
    releaseLock() {
    },
    closed: Promise.resolve()
  };
}
var ga = class {
  constructor(t2) {
    this.observer = t2, this.muted = false;
  }
  next(t2) {
    this.observer.next && this.gc(this.observer.next, t2);
  }
  error(t2) {
    this.observer.error ? this.gc(this.observer.error, t2) : x2("Uncaught Error in snapshot listener:", t2.toString());
  }
  yc() {
    this.muted = true;
  }
  gc(t2, e) {
    this.muted || setTimeout(() => {
      this.muted || t2(e);
    }, 0);
  }
};
var ya2 = class {
  constructor(t2, e) {
    this.Ic = t2, this.serializer = e, this.metadata = new q2(), this.buffer = new Uint8Array(), this.Tc = new TextDecoder("utf-8"), this.Ec().then((t3) => {
      t3 && t3.ku() ? this.metadata.resolve(t3.Nu.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is
             ${JSON.stringify(null == t3 ? void 0 : t3.Nu)}`));
    }, (t3) => this.metadata.reject(t3));
  }
  close() {
    return this.Ic.cancel();
  }
  async getMetadata() {
    return this.metadata.promise;
  }
  async _c() {
    return await this.getMetadata(), this.Ec();
  }
  async Ec() {
    const t2 = await this.Ac();
    if (null === t2)
      return null;
    const e = this.Tc.decode(t2), n = Number(e);
    isNaN(n) && this.Rc(`length string (${e}) is not valid number`);
    const s = await this.vc(n);
    return new Rc2(JSON.parse(s), t2.length + n);
  }
  bc() {
    return this.buffer.findIndex((t2) => t2 === "{".charCodeAt(0));
  }
  async Ac() {
    for (; this.bc() < 0; ) {
      if (await this.Pc())
        break;
    }
    if (0 === this.buffer.length)
      return null;
    const t2 = this.bc();
    t2 < 0 && this.Rc("Reached the end of bundle when a length string is expected.");
    const e = this.buffer.slice(0, t2);
    return this.buffer = this.buffer.slice(t2), e;
  }
  async vc(t2) {
    for (; this.buffer.length < t2; ) {
      await this.Pc() && this.Rc("Reached the end of bundle when more is expected.");
    }
    const e = this.Tc.decode(this.buffer.slice(0, t2));
    return this.buffer = this.buffer.slice(t2), e;
  }
  Rc(t2) {
    throw this.Ic.cancel(), new Error(`Invalid bundle format: ${t2}`);
  }
  async Pc() {
    const t2 = await this.Ic.read();
    if (!t2.done) {
      const e = new Uint8Array(this.buffer.length + t2.value.length);
      e.set(this.buffer), e.set(t2.value, this.buffer.length), this.buffer = e;
    }
    return t2.done;
  }
};
var pa2 = class {
  constructor(t2) {
    this.datastore = t2, this.readVersions = /* @__PURE__ */ new Map(), this.mutations = [], this.committed = false, this.lastWriteError = null, this.writtenDocs = /* @__PURE__ */ new Set();
  }
  async lookup(t2) {
    if (this.ensureCommitNotCalled(), this.mutations.length > 0)
      throw new L2(B2.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes.");
    const e = await async function(t3, e2) {
      const n = F(t3), s = xi(n.serializer) + "/documents", i = {
        documents: e2.map((t4) => Vi(n.serializer, t4))
      }, r = await n.fo("BatchGetDocuments", s, i, e2.length), o = /* @__PURE__ */ new Map();
      r.forEach((t4) => {
        const e3 = $i(n.serializer, t4);
        o.set(e3.key.toString(), e3);
      });
      const u = [];
      return e2.forEach((t4) => {
        const e3 = o.get(t4.toString());
        $(!!e3), u.push(e3);
      }), u;
    }(this.datastore, t2);
    return e.forEach((t3) => this.recordVersion(t3)), e;
  }
  set(t2, e) {
    this.write(e.toMutation(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  update(t2, e) {
    try {
      this.write(e.toMutation(t2, this.preconditionForUpdate(t2)));
    } catch (t3) {
      this.lastWriteError = t3;
    }
    this.writtenDocs.add(t2.toString());
  }
  delete(t2) {
    this.write(new Ws(t2, this.precondition(t2))), this.writtenDocs.add(t2.toString());
  }
  async commit() {
    if (this.ensureCommitNotCalled(), this.lastWriteError)
      throw this.lastWriteError;
    const t2 = this.readVersions;
    this.mutations.forEach((e) => {
      t2.delete(e.key.toString());
    }), t2.forEach((t3, e) => {
      const n = ct.fromPath(e);
      this.mutations.push(new Hs(n, this.precondition(n)));
    }), await async function(t3, e) {
      const n = F(t3), s = xi(n.serializer) + "/documents", i = {
        writes: e.map((t4) => Fi(n.serializer, t4))
      };
      await n.co("Commit", s, i);
    }(this.datastore, this.mutations), this.committed = true;
  }
  recordVersion(t2) {
    let e;
    if (t2.isFoundDocument())
      e = t2.version;
    else {
      if (!t2.isNoDocument())
        throw O2();
      e = st.min();
    }
    const n = this.readVersions.get(t2.key.toString());
    if (n) {
      if (!e.isEqual(n))
        throw new L2(B2.ABORTED, "Document version changed between two reads.");
    } else
      this.readVersions.set(t2.key.toString(), e);
  }
  precondition(t2) {
    const e = this.readVersions.get(t2.toString());
    return !this.writtenDocs.has(t2.toString()) && e ? e.isEqual(st.min()) ? Os.exists(false) : Os.updateTime(e) : Os.none();
  }
  preconditionForUpdate(t2) {
    const e = this.readVersions.get(t2.toString());
    if (!this.writtenDocs.has(t2.toString()) && e) {
      if (e.isEqual(st.min()))
        throw new L2(B2.INVALID_ARGUMENT, "Can't update a document that doesn't exist.");
      return Os.updateTime(e);
    }
    return Os.exists(true);
  }
  write(t2) {
    this.ensureCommitNotCalled(), this.mutations.push(t2);
  }
  ensureCommitNotCalled() {
  }
};
var Ia2 = class {
  constructor(t2, e, n, s, i) {
    this.asyncQueue = t2, this.datastore = e, this.options = n, this.updateFunction = s, this.deferred = i, this.Vc = n.maxAttempts, this.Co = new Su(this.asyncQueue, "transaction_retry");
  }
  run() {
    this.Vc -= 1, this.Sc();
  }
  Sc() {
    this.Co.Ao(async () => {
      const t2 = new pa2(this.datastore), e = this.Dc(t2);
      e && e.then((e2) => {
        this.asyncQueue.enqueueAndForget(() => t2.commit().then(() => {
          this.deferred.resolve(e2);
        }).catch((t3) => {
          this.Cc(t3);
        }));
      }).catch((t3) => {
        this.Cc(t3);
      });
    });
  }
  Dc(t2) {
    try {
      const e = this.updateFunction(t2);
      return !$t(e) && e.catch && e.then ? e : (this.deferred.reject(Error("Transaction callback must return a Promise")), null);
    } catch (t3) {
      return this.deferred.reject(t3), null;
    }
  }
  Cc(t2) {
    this.Vc > 0 && this.xc(t2) ? (this.Vc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Sc(), Promise.resolve()))) : this.deferred.reject(t2);
  }
  xc(t2) {
    if ("FirebaseError" === t2.name) {
      const e = t2.code;
      return "aborted" === e || "failed-precondition" === e || "already-exists" === e || !ri(e);
    }
    return false;
  }
};
var Ta2 = class {
  constructor(t2, e, n, s) {
    this.authCredentials = t2, this.appCheckCredentials = e, this.asyncQueue = n, this.databaseInfo = s, this.user = b.UNAUTHENTICATED, this.clientId = Z.A(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(n, async (t3) => {
      C2("FirestoreClient", "Received user=", t3.uid), await this.authCredentialListener(t3), this.user = t3;
    }), this.appCheckCredentials.start(n, (t3) => (C2("FirestoreClient", "Received new app check token=", t3), this.appCheckCredentialListener(t3, this.user)));
  }
  async getConfiguration() {
    return {
      asyncQueue: this.asyncQueue,
      databaseInfo: this.databaseInfo,
      clientId: this.clientId,
      authCredentials: this.authCredentials,
      appCheckCredentials: this.appCheckCredentials,
      initialUser: this.user,
      maxConcurrentLimboResolutions: 100
    };
  }
  setCredentialChangeListener(t2) {
    this.authCredentialListener = t2;
  }
  setAppCheckTokenChangeListener(t2) {
    this.appCheckCredentialListener = t2;
  }
  verifyNotTerminated() {
    if (this.asyncQueue.isShuttingDown)
      throw new L2(B2.FAILED_PRECONDITION, "The client has already been terminated.");
  }
  terminate() {
    this.asyncQueue.enterRestrictedMode();
    const t2 = new q2();
    return this.asyncQueue.enqueueAndForgetEvenWhileRestricted(async () => {
      try {
        this._onlineComponents && await this._onlineComponents.terminate(), this._offlineComponents && await this._offlineComponents.terminate(), this.authCredentials.shutdown(), this.appCheckCredentials.shutdown(), t2.resolve();
      } catch (e) {
        const n = fc2(e, "Failed to shutdown persistence");
        t2.reject(n);
      }
    }), t2.promise;
  }
};
async function Ea2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress(), C2("FirestoreClient", "Initializing OfflineComponentProvider");
  const n = await t2.getConfiguration();
  await e.initialize(n);
  let s = n.initialUser;
  t2.setCredentialChangeListener(async (t3) => {
    s.isEqual(t3) || (await Wo(e.localStore, t3), s = t3);
  }), e.persistence.setDatabaseDeletedListener(() => t2.terminate()), t2._offlineComponents = e;
}
async function Aa2(t2, e) {
  t2.asyncQueue.verifyOperationInProgress();
  const n = await va2(t2);
  C2("FirestoreClient", "Initializing OnlineComponentProvider");
  const s = await t2.getConfiguration();
  await e.initialize(n, s), t2.setCredentialChangeListener((t3) => uc2(e.remoteStore, t3)), t2.setAppCheckTokenChangeListener((t3, n2) => uc2(e.remoteStore, n2)), t2._onlineComponents = e;
}
function Ra2(t2) {
  return "FirebaseError" === t2.name ? t2.code === B2.FAILED_PRECONDITION || t2.code === B2.UNIMPLEMENTED : !("undefined" != typeof DOMException && t2 instanceof DOMException) || (22 === t2.code || 20 === t2.code || 11 === t2.code);
}
async function va2(t2) {
  if (!t2._offlineComponents)
    if (t2._uninitializedComponentsProvider) {
      C2("FirestoreClient", "Using user provided OfflineComponentProvider");
      try {
        await Ea2(t2, t2._uninitializedComponentsProvider._offline);
      } catch (e) {
        const n = e;
        if (!Ra2(n))
          throw n;
        N2("Error using user provided cache. Falling back to memory cache: " + n), await Ea2(t2, new fa2());
      }
    } else
      C2("FirestoreClient", "Using default OfflineComponentProvider"), await Ea2(t2, new fa2());
  return t2._offlineComponents;
}
async function ba2(t2) {
  return t2._onlineComponents || (t2._uninitializedComponentsProvider ? (C2("FirestoreClient", "Using user provided OnlineComponentProvider"), await Aa2(t2, t2._uninitializedComponentsProvider._online)) : (C2("FirestoreClient", "Using default OnlineComponentProvider"), await Aa2(t2, new _a()))), t2._onlineComponents;
}
function Pa2(t2) {
  return va2(t2).then((t3) => t3.persistence);
}
function Va2(t2) {
  return va2(t2).then((t3) => t3.localStore);
}
function Sa2(t2) {
  return ba2(t2).then((t3) => t3.remoteStore);
}
function Da(t2) {
  return ba2(t2).then((t3) => t3.syncEngine);
}
function Ca(t2) {
  return ba2(t2).then((t3) => t3.datastore);
}
async function xa2(t2) {
  const e = await ba2(t2), n = e.eventManager;
  return n.onListen = kc2.bind(null, e.syncEngine), n.onUnlisten = $c2.bind(null, e.syncEngine), n;
}
function Na2(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Pa2(t2), n = await Sa2(t2);
    return e.setNetworkEnabled(true), function(t3) {
      const e2 = F(t3);
      return e2.du.delete(0), Mu(e2);
    }(n);
  });
}
function ka(t2) {
  return t2.asyncQueue.enqueue(async () => {
    const e = await Pa2(t2), n = await Sa2(t2);
    return e.setNetworkEnabled(false), async function(t3) {
      const e2 = F(t3);
      e2.du.add(0), await Fu(e2), e2.mu.set("Offline");
    }(n);
  });
}
function Oa2(t2, e) {
  const n = new q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await function(t4, e3) {
        const n3 = F(t4);
        return n3.persistence.runTransaction("read document", "readonly", (t5) => n3.localDocuments.getDocument(t5, e3));
      }(t3, e2);
      s.isFoundDocument() ? n2.resolve(s) : s.isNoDocument() ? n2.resolve(null) : n2.reject(new L2(B2.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)"));
    } catch (t4) {
      const s = fc2(t4, `Failed to get document '${e2} from cache`);
      n2.reject(s);
    }
  }(await Va2(t2), e, n)), n.promise;
}
function $a2(t2, e, n = {}) {
  const s = new q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new ga({
      next: (r2) => {
        e2.enqueueAndForget(() => pc2(t3, o));
        const u = r2.docs.has(n2);
        !u && r2.fromCache ? i.reject(new L2(B2.UNAVAILABLE, "Failed to get document because the client is offline.")) : u && r2.fromCache && s2 && "server" === s2.source ? i.reject(new L2(B2.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : i.resolve(r2);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ac2(qn(n2.path), r, {
      includeMetadataChanges: true,
      xu: true
    });
    return yc2(t3, o);
  }(await xa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Ma2(t2, e) {
  const n = new q2();
  return t2.asyncQueue.enqueueAndForget(async () => async function(t3, e2, n2) {
    try {
      const s = await nu(
        t3,
        e2,
        true
      ), i = new Dc2(e2, s.Wi), r = i.zu(s.documents), o = i.applyChanges(
        r,
        false
      );
      n2.resolve(o.snapshot);
    } catch (t4) {
      const s = fc2(t4, `Failed to execute query '${e2} against cache`);
      n2.reject(s);
    }
  }(await Va2(t2), e, n)), n.promise;
}
function Fa(t2, e, n = {}) {
  const s = new q2();
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2, n2, s2, i) {
    const r = new ga({
      next: (n3) => {
        e2.enqueueAndForget(() => pc2(t3, o)), n3.fromCache && "server" === s2.source ? i.reject(new L2(B2.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : i.resolve(n3);
      },
      error: (t4) => i.reject(t4)
    }), o = new Ac2(n2, r, {
      includeMetadataChanges: true,
      xu: true
    });
    return yc2(t3, o);
  }(await xa2(t2), t2.asyncQueue, e, n, s)), s.promise;
}
function Ba2(t2, e) {
  const n = new ga(e);
  return t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
    F(t3).Au.add(e2), e2.next();
  }(await xa2(t2), n)), () => {
    n.yc(), t2.asyncQueue.enqueueAndForget(async () => function(t3, e2) {
      F(t3).Au.delete(e2);
    }(await xa2(t2), n));
  };
}
function La2(t2, e, n, s) {
  const i = function(t3, e2) {
    let n2;
    n2 = "string" == typeof t3 ? new TextEncoder().encode(t3) : t3;
    return function(t4, e3) {
      return new ya2(t4, e3);
    }(function(t4, e3) {
      if (t4 instanceof Uint8Array)
        return ma2(t4, e3);
      if (t4 instanceof ArrayBuffer)
        return ma2(new Uint8Array(t4), e3);
      if (t4 instanceof ReadableStream)
        return t4.getReader();
      throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream");
    }(n2), e2);
  }(n, Vu(e));
  t2.asyncQueue.enqueueAndForget(async () => {
    la2(await Da(t2), i, s);
  });
}
function qa2(t2, e) {
  return t2.asyncQueue.enqueue(async () => function(t3, e2) {
    const n = F(t3);
    return n.persistence.runTransaction("Get named query", "readonly", (t4) => n.xs.getNamedQuery(t4, e2));
  }(await Va2(t2), e));
}
function Ua2(t2, e) {
  return t2.asyncQueue.enqueue(async () => async function(t3, e2) {
    const n = F(t3), s = n.indexManager, i = [];
    return n.persistence.runTransaction("Configure indexes", "readwrite", (t4) => s.getFieldIndexes(t4).next((n2) => function(t5, e3, n3, s2, i2) {
      t5 = [...t5], e3 = [...e3], t5.sort(n3), e3.sort(n3);
      const r = t5.length, o = e3.length;
      let u = 0, c = 0;
      for (; u < o && c < r; ) {
        const r2 = n3(t5[c], e3[u]);
        r2 < 0 ? i2(t5[c++]) : r2 > 0 ? s2(e3[u++]) : (u++, c++);
      }
      for (; u < o; )
        s2(e3[u++]);
      for (; c < r; )
        i2(t5[c++]);
    }(n2, e2, ft, (e3) => {
      i.push(s.addFieldIndex(t4, e3));
    }, (e3) => {
      i.push(s.deleteFieldIndex(t4, e3));
    })).next(() => At.waitFor(i)));
  }(await Va2(t2), e));
}
var Ka = /* @__PURE__ */ new Map();
function Ga(t2, e, n) {
  if (!n)
    throw new L2(B2.INVALID_ARGUMENT, `Function ${t2}() cannot be called with an empty ${e}.`);
}
function Qa2(t2, e, n, s) {
  if (true === e && true === s)
    throw new L2(B2.INVALID_ARGUMENT, `${t2} and ${n} cannot be used together.`);
}
function za2(t2) {
  if (!ct.isDocumentKey(t2))
    throw new L2(B2.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${t2} has ${t2.length}.`);
}
function ja2(t2) {
  if (ct.isDocumentKey(t2))
    throw new L2(B2.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${t2} has ${t2.length}.`);
}
function Wa2(t2) {
  if (void 0 === t2)
    return "undefined";
  if (null === t2)
    return "null";
  if ("string" == typeof t2)
    return t2.length > 20 && (t2 = `${t2.substring(0, 20)}...`), JSON.stringify(t2);
  if ("number" == typeof t2 || "boolean" == typeof t2)
    return "" + t2;
  if ("object" == typeof t2) {
    if (t2 instanceof Array)
      return "an array";
    {
      const e = function(t3) {
        if (t3.constructor)
          return t3.constructor.name;
        return null;
      }(t2);
      return e ? `a custom ${e} object` : "an object";
    }
  }
  return "function" == typeof t2 ? "a function" : O2();
}
function Ha(t2, e) {
  if ("_delegate" in t2 && (t2 = t2._delegate), !(t2 instanceof e)) {
    if (e.name === t2.constructor.name)
      throw new L2(B2.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?");
    {
      const n = Wa2(t2);
      throw new L2(B2.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${n}`);
    }
  }
  return t2;
}
function Ja2(t2, e) {
  if (e <= 0)
    throw new L2(B2.INVALID_ARGUMENT, `Function ${t2}() requires a positive number, but it was: ${e}.`);
}
var Ya2 = class {
  constructor(t2) {
    var e;
    if (void 0 === t2.host) {
      if (void 0 !== t2.ssl)
        throw new L2(B2.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set");
      this.host = "firestore.googleapis.com", this.ssl = true;
    } else
      this.host = t2.host, this.ssl = null === (e = t2.ssl) || void 0 === e || e;
    if (this.credentials = t2.credentials, this.ignoreUndefinedProperties = !!t2.ignoreUndefinedProperties, this.cache = t2.localCache, void 0 === t2.cacheSizeBytes)
      this.cacheSizeBytes = 41943040;
    else {
      if (-1 !== t2.cacheSizeBytes && t2.cacheSizeBytes < 1048576)
        throw new L2(B2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
      this.cacheSizeBytes = t2.cacheSizeBytes;
    }
    this.experimentalForceLongPolling = !!t2.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !!t2.experimentalAutoDetectLongPolling, this.useFetchStreams = !!t2.useFetchStreams, Qa2("experimentalForceLongPolling", t2.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", t2.experimentalAutoDetectLongPolling);
  }
  isEqual(t2) {
    return this.host === t2.host && this.ssl === t2.ssl && this.credentials === t2.credentials && this.cacheSizeBytes === t2.cacheSizeBytes && this.experimentalForceLongPolling === t2.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === t2.experimentalAutoDetectLongPolling && this.ignoreUndefinedProperties === t2.ignoreUndefinedProperties && this.useFetchStreams === t2.useFetchStreams;
  }
};
var Za = class {
  constructor(t2, e, n, s) {
    this._authCredentials = t2, this._appCheckCredentials = e, this._databaseId = n, this._app = s, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new Ya2({}), this._settingsFrozen = false;
  }
  get app() {
    if (!this._app)
      throw new L2(B2.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available");
    return this._app;
  }
  get _initialized() {
    return this._settingsFrozen;
  }
  get _terminated() {
    return void 0 !== this._terminateTask;
  }
  _setSettings(t2) {
    if (this._settingsFrozen)
      throw new L2(B2.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object.");
    this._settings = new Ya2(t2), void 0 !== t2.credentials && (this._authCredentials = function(t3) {
      if (!t3)
        return new K2();
      switch (t3.type) {
        case "firstParty":
          return new j(t3.sessionIndex || "0", t3.iamToken || null, t3.authTokenFactory || null);
        case "provider":
          return t3.client;
        default:
          throw new L2(B2.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type");
      }
    }(t2.credentials));
  }
  _getSettings() {
    return this._settings;
  }
  _freezeSettings() {
    return this._settingsFrozen = true, this._settings;
  }
  _delete() {
    return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask;
  }
  toJSON() {
    return {
      app: this._app,
      databaseId: this._databaseId,
      settings: this._settings
    };
  }
  _terminate() {
    return function(t2) {
      const e = Ka.get(t2);
      e && (C2("ComponentProvider", "Removing Datastore"), Ka.delete(t2), e.terminate());
    }(this), Promise.resolve();
  }
};
function Xa2(t2, e, n, s = {}) {
  var i;
  const r = (t2 = Ha(t2, Za))._getSettings();
  if ("firestore.googleapis.com" !== r.host && r.host !== e && N2("Host has been set in both settings() and useEmulator(), emulator host will be used"), t2._setSettings(Object.assign(Object.assign({}, r), {
    host: `${e}:${n}`,
    ssl: false
  })), s.mockUserToken) {
    let e2, n2;
    if ("string" == typeof s.mockUserToken)
      e2 = s.mockUserToken, n2 = b.MOCK_USER;
    else {
      e2 = createMockUserToken(s.mockUserToken, null === (i = t2._app) || void 0 === i ? void 0 : i.options.projectId);
      const r2 = s.mockUserToken.sub || s.mockUserToken.user_id;
      if (!r2)
        throw new L2(B2.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!");
      n2 = new b(r2);
    }
    t2._authCredentials = new G2(new U2(e2, n2));
  }
}
var th = class {
  constructor(t2, e, n) {
    this.converter = e, this._key = n, this.type = "document", this.firestore = t2;
  }
  get _path() {
    return this._key.path;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get path() {
    return this._key.path.canonicalString();
  }
  get parent() {
    return new nh(this.firestore, this.converter, this._key.path.popLast());
  }
  withConverter(t2) {
    return new th(this.firestore, t2, this._key);
  }
};
var eh = class {
  constructor(t2, e, n) {
    this.converter = e, this._query = n, this.type = "query", this.firestore = t2;
  }
  withConverter(t2) {
    return new eh(this.firestore, t2, this._query);
  }
};
var nh = class extends eh {
  constructor(t2, e, n) {
    super(t2, e, qn(n)), this._path = n, this.type = "collection";
  }
  get id() {
    return this._query.path.lastSegment();
  }
  get path() {
    return this._query.path.canonicalString();
  }
  get parent() {
    const t2 = this._path.popLast();
    return t2.isEmpty() ? null : new th(
      this.firestore,
      null,
      new ct(t2)
    );
  }
  withConverter(t2) {
    return new nh(this.firestore, t2, this._path);
  }
};
function sh(t2, e, ...n) {
  if (t2 = getModularInstance(t2), Ga("collection", "path", e), t2 instanceof Za) {
    const s = rt.fromString(e, ...n);
    return ja2(s), new nh(t2, null, s);
  }
  {
    if (!(t2 instanceof th || t2 instanceof nh))
      throw new L2(B2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(rt.fromString(e, ...n));
    return ja2(s), new nh(
      t2.firestore,
      null,
      s
    );
  }
}
function ih(t2, e) {
  if (t2 = Ha(t2, Za), Ga("collectionGroup", "collection id", e), e.indexOf("/") >= 0)
    throw new L2(B2.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`);
  return new eh(
    t2,
    null,
    function(t3) {
      return new Bn(rt.emptyPath(), t3);
    }(e)
  );
}
function rh(t2, e, ...n) {
  if (t2 = getModularInstance(t2), 1 === arguments.length && (e = Z.A()), Ga("doc", "path", e), t2 instanceof Za) {
    const s = rt.fromString(e, ...n);
    return za2(s), new th(
      t2,
      null,
      new ct(s)
    );
  }
  {
    if (!(t2 instanceof th || t2 instanceof nh))
      throw new L2(B2.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore");
    const s = t2._path.child(rt.fromString(e, ...n));
    return za2(s), new th(t2.firestore, t2 instanceof nh ? t2.converter : null, new ct(s));
  }
}
function oh(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), (t2 instanceof th || t2 instanceof nh) && (e instanceof th || e instanceof nh) && (t2.firestore === e.firestore && t2.path === e.path && t2.converter === e.converter);
}
function uh(t2, e) {
  return t2 = getModularInstance(t2), e = getModularInstance(e), t2 instanceof eh && e instanceof eh && (t2.firestore === e.firestore && Jn(t2._query, e._query) && t2.converter === e.converter);
}
var ch = class {
  constructor() {
    this.Nc = Promise.resolve(), this.kc = [], this.Oc = false, this.$c = [], this.Mc = null, this.Fc = false, this.Bc = false, this.Lc = [], this.Co = new Su(this, "async_queue_retry"), this.qc = () => {
      const t3 = Pu();
      t3 && C2("AsyncQueue", "Visibility state changed to " + t3.visibilityState), this.Co.vo();
    };
    const t2 = Pu();
    t2 && "function" == typeof t2.addEventListener && t2.addEventListener("visibilitychange", this.qc);
  }
  get isShuttingDown() {
    return this.Oc;
  }
  enqueueAndForget(t2) {
    this.enqueue(t2);
  }
  enqueueAndForgetEvenWhileRestricted(t2) {
    this.Uc(), this.Kc(t2);
  }
  enterRestrictedMode(t2) {
    if (!this.Oc) {
      this.Oc = true, this.Bc = t2 || false;
      const e = Pu();
      e && "function" == typeof e.removeEventListener && e.removeEventListener("visibilitychange", this.qc);
    }
  }
  enqueue(t2) {
    if (this.Uc(), this.Oc)
      return new Promise(() => {
      });
    const e = new q2();
    return this.Kc(() => this.Oc && this.Bc ? Promise.resolve() : (t2().then(e.resolve, e.reject), e.promise)).then(() => e.promise);
  }
  enqueueRetryable(t2) {
    this.enqueueAndForget(() => (this.kc.push(t2), this.Gc()));
  }
  async Gc() {
    if (0 !== this.kc.length) {
      try {
        await this.kc[0](), this.kc.shift(), this.Co.reset();
      } catch (t2) {
        if (!Vt(t2))
          throw t2;
        C2("AsyncQueue", "Operation failed with retryable error: " + t2);
      }
      this.kc.length > 0 && this.Co.Ao(() => this.Gc());
    }
  }
  Kc(t2) {
    const e = this.Nc.then(() => (this.Fc = true, t2().catch((t3) => {
      this.Mc = t3, this.Fc = false;
      const e2 = function(t4) {
        let e3 = t4.message || "";
        t4.stack && (e3 = t4.stack.includes(t4.message) ? t4.stack : t4.message + "\n" + t4.stack);
        return e3;
      }(t3);
      throw x2("INTERNAL UNHANDLED ERROR: ", e2), t3;
    }).then((t3) => (this.Fc = false, t3))));
    return this.Nc = e, e;
  }
  enqueueAfterDelay(t2, e, n) {
    this.Uc(), this.Lc.indexOf(t2) > -1 && (e = 0);
    const s = lc2.createAndSchedule(this, t2, e, n, (t3) => this.Qc(t3));
    return this.$c.push(s), s;
  }
  Uc() {
    this.Mc && O2();
  }
  verifyOperationInProgress() {
  }
  async zc() {
    let t2;
    do {
      t2 = this.Nc, await t2;
    } while (t2 !== this.Nc);
  }
  jc(t2) {
    for (const e of this.$c)
      if (e.timerId === t2)
        return true;
    return false;
  }
  Wc(t2) {
    return this.zc().then(() => {
      this.$c.sort((t3, e) => t3.targetTimeMs - e.targetTimeMs);
      for (const e of this.$c)
        if (e.skipDelay(), "all" !== t2 && e.timerId === t2)
          break;
      return this.zc();
    });
  }
  Hc(t2) {
    this.Lc.push(t2);
  }
  Qc(t2) {
    const e = this.$c.indexOf(t2);
    this.$c.splice(e, 1);
  }
};
function ah(t2) {
  return function(t3, e) {
    if ("object" != typeof t3 || null === t3)
      return false;
    const n = t3;
    for (const t4 of e)
      if (t4 in n && "function" == typeof n[t4])
        return true;
    return false;
  }(t2, ["next", "error", "complete"]);
}
var hh = class {
  constructor() {
    this._progressObserver = {}, this._taskCompletionResolver = new q2(), this._lastProgress = {
      taskState: "Running",
      totalBytes: 0,
      totalDocuments: 0,
      bytesLoaded: 0,
      documentsLoaded: 0
    };
  }
  onProgress(t2, e, n) {
    this._progressObserver = {
      next: t2,
      error: e,
      complete: n
    };
  }
  catch(t2) {
    return this._taskCompletionResolver.promise.catch(t2);
  }
  then(t2, e) {
    return this._taskCompletionResolver.promise.then(t2, e);
  }
  _completeWith(t2) {
    this._updateProgress(t2), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(t2);
  }
  _failWith(t2) {
    this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(t2), this._taskCompletionResolver.reject(t2);
  }
  _updateProgress(t2) {
    this._lastProgress = t2, this._progressObserver.next && this._progressObserver.next(t2);
  }
};
var lh = -1;
var fh = class extends Za {
  constructor(t2, e, n, s) {
    super(t2, e, n, s), this.type = "firestore", this._queue = new ch(), this._persistenceKey = (null == s ? void 0 : s.name) || "[DEFAULT]";
  }
  _terminate() {
    return this._firestoreClient || mh(this), this._firestoreClient.terminate();
  }
};
function dh(t2, e, n) {
  n || (n = "(default)");
  const s = _getProvider(t2, "firestore");
  if (s.isInitialized(n)) {
    const t3 = s.getImmediate({
      identifier: n
    }), i = s.getOptions(n);
    if (deepEqual(i, e))
      return t3;
    throw new L2(B2.FAILED_PRECONDITION, "initializeFirestore() has already been called with different options. To avoid this error, call initializeFirestore() with the same options as when it was originally called, or call getFirestore() to return the already initialized instance.");
  }
  if (void 0 !== e.cacheSizeBytes && void 0 !== e.localCache)
    throw new L2(B2.INVALID_ARGUMENT, "cache and cacheSizeBytes cannot be specified at the same time as cacheSizeBytes willbe deprecated. Instead, specify the cache size in the cache object");
  if (void 0 !== e.cacheSizeBytes && -1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576)
    throw new L2(B2.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576");
  return s.initialize({
    options: e,
    instanceIdentifier: n
  });
}
function wh(e, n) {
  const s = "object" == typeof e ? e : getApp(), i = "string" == typeof e ? e : n || "(default)", r = _getProvider(s, "firestore").getImmediate({
    identifier: i
  });
  if (!r._initialized) {
    const t2 = getDefaultEmulatorHostnameAndPort("firestore");
    t2 && Xa2(r, ...t2);
  }
  return r;
}
function _h(t2) {
  return t2._firestoreClient || mh(t2), t2._firestoreClient.verifyNotTerminated(), t2._firestoreClient;
}
function mh(t2) {
  var e, n, s;
  const i = t2._freezeSettings(), r = function(t3, e2, n2, s2) {
    return new ke(t3, e2, n2, s2.host, s2.ssl, s2.experimentalForceLongPolling, s2.experimentalAutoDetectLongPolling, s2.useFetchStreams);
  }(t2._databaseId, (null === (e = t2._app) || void 0 === e ? void 0 : e.options.appId) || "", t2._persistenceKey, i);
  t2._firestoreClient = new Ta2(t2._authCredentials, t2._appCheckCredentials, t2._queue, r), (null === (n = i.cache) || void 0 === n ? void 0 : n._offlineComponentProvider) && (null === (s = i.cache) || void 0 === s ? void 0 : s._onlineComponentProvider) && (t2._firestoreClient._uninitializedComponentsProvider = {
    _offlineKind: i.cache.kind,
    _offline: i.cache._offlineComponentProvider,
    _online: i.cache._onlineComponentProvider
  });
}
function gh(t2, e) {
  Ph(t2 = Ha(t2, fh));
  const n = _h(t2);
  if (n._uninitializedComponentsProvider)
    throw new L2(B2.FAILED_PRECONDITION, "SDK cache is already specified.");
  N2("enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
  const s = t2._freezeSettings(), i = new _a();
  return ph(n, i, new da2(i, s.cacheSizeBytes, null == e ? void 0 : e.forceOwnership));
}
function yh(t2) {
  Ph(t2 = Ha(t2, fh));
  const e = _h(t2);
  if (e._uninitializedComponentsProvider)
    throw new L2(B2.FAILED_PRECONDITION, "SDK cache is already specified.");
  N2("enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead.");
  const n = t2._freezeSettings(), s = new _a();
  return ph(e, s, new wa2(s, n.cacheSizeBytes));
}
function ph(t2, e, n) {
  const s = new q2();
  return t2.asyncQueue.enqueue(async () => {
    try {
      await Ea2(t2, n), await Aa2(t2, e), s.resolve();
    } catch (t3) {
      const e2 = t3;
      if (!Ra2(e2))
        throw e2;
      N2("Error enabling indexeddb cache. Falling back to memory cache: " + e2), s.reject(e2);
    }
  }).then(() => s.promise);
}
function Ih(t2) {
  if (t2._initialized && !t2._terminated)
    throw new L2(B2.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated.");
  const e = new q2();
  return t2._queue.enqueueAndForgetEvenWhileRestricted(async () => {
    try {
      await async function(t3) {
        if (!vt.D())
          return Promise.resolve();
        const e2 = t3 + "main";
        await vt.delete(e2);
      }(Ko(t2._databaseId, t2._persistenceKey)), e.resolve();
    } catch (t3) {
      e.reject(t3);
    }
  }), e.promise;
}
function Th(t2) {
  return function(t3) {
    const e = new q2();
    return t3.asyncQueue.enqueueAndForget(async () => Kc2(await Da(t3), e)), e.promise;
  }(_h(t2 = Ha(t2, fh)));
}
function Eh(t2) {
  return Na2(_h(t2 = Ha(t2, fh)));
}
function Ah(t2) {
  return ka(_h(t2 = Ha(t2, fh)));
}
function Rh(t2) {
  return _removeServiceInstance(t2.app, "firestore", t2._databaseId.database), t2._delete();
}
function vh(t2, e) {
  const n = _h(t2 = Ha(t2, fh)), s = new hh();
  return La2(n, t2._databaseId, e, s), s;
}
function bh(t2, e) {
  return qa2(_h(t2 = Ha(t2, fh)), e).then((e2) => e2 ? new eh(t2, null, e2.query) : null);
}
function Ph(t2) {
  if (t2._initialized || t2._terminated)
    throw new L2(B2.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.");
}
var Vh = class {
  constructor(t2 = "count", e) {
    this._aggregateType = t2, this._internalFieldPath = e, this.type = "AggregateField";
  }
};
var Sh = class {
  constructor(t2, e, n) {
    this._userDataWriter = e, this._data = n, this.type = "AggregateQuerySnapshot", this.query = t2;
  }
  data() {
    return this._userDataWriter.convertValue(this._data.value);
  }
};
var Dh = class {
  constructor(t2) {
    this._byteString = t2;
  }
  static fromBase64String(t2) {
    try {
      return new Dh(be.fromBase64String(t2));
    } catch (t3) {
      throw new L2(B2.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t3);
    }
  }
  static fromUint8Array(t2) {
    return new Dh(be.fromUint8Array(t2));
  }
  toBase64() {
    return this._byteString.toBase64();
  }
  toUint8Array() {
    return this._byteString.toUint8Array();
  }
  toString() {
    return "Bytes(base64: " + this.toBase64() + ")";
  }
  isEqual(t2) {
    return this._byteString.isEqual(t2._byteString);
  }
};
var Ch = class {
  constructor(...t2) {
    for (let e = 0; e < t2.length; ++e)
      if (0 === t2[e].length)
        throw new L2(B2.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty.");
    this._internalPath = new ut(t2);
  }
  isEqual(t2) {
    return this._internalPath.isEqual(t2._internalPath);
  }
};
function xh() {
  return new Ch("__name__");
}
var Nh = class {
  constructor(t2) {
    this._methodName = t2;
  }
};
var kh = class {
  constructor(t2, e) {
    if (!isFinite(t2) || t2 < -90 || t2 > 90)
      throw new L2(B2.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + t2);
    if (!isFinite(e) || e < -180 || e > 180)
      throw new L2(B2.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + e);
    this._lat = t2, this._long = e;
  }
  get latitude() {
    return this._lat;
  }
  get longitude() {
    return this._long;
  }
  isEqual(t2) {
    return this._lat === t2._lat && this._long === t2._long;
  }
  toJSON() {
    return {
      latitude: this._lat,
      longitude: this._long
    };
  }
  _compareTo(t2) {
    return X2(this._lat, t2._lat) || X2(this._long, t2._long);
  }
};
var Oh = /^__.*__$/;
var $h = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return null !== this.fieldMask ? new Gs(t2, this.data, this.fieldMask, e, this.fieldTransforms) : new Ks(t2, this.data, e, this.fieldTransforms);
  }
};
var Mh = class {
  constructor(t2, e, n) {
    this.data = t2, this.fieldMask = e, this.fieldTransforms = n;
  }
  toMutation(t2, e) {
    return new Gs(t2, this.data, this.fieldMask, e, this.fieldTransforms);
  }
};
function Fh(t2) {
  switch (t2) {
    case 0:
    case 2:
    case 1:
      return true;
    case 3:
    case 4:
      return false;
    default:
      throw O2();
  }
}
var Bh = class {
  constructor(t2, e, n, s, i, r) {
    this.settings = t2, this.databaseId = e, this.serializer = n, this.ignoreUndefinedProperties = s, void 0 === i && this.Jc(), this.fieldTransforms = i || [], this.fieldMask = r || [];
  }
  get path() {
    return this.settings.path;
  }
  get Yc() {
    return this.settings.Yc;
  }
  Zc(t2) {
    return new Bh(Object.assign(Object.assign({}, this.settings), t2), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask);
  }
  Xc(t2) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), s = this.Zc({
      path: n,
      ta: false
    });
    return s.ea(t2), s;
  }
  na(t2) {
    var e;
    const n = null === (e = this.path) || void 0 === e ? void 0 : e.child(t2), s = this.Zc({
      path: n,
      ta: false
    });
    return s.Jc(), s;
  }
  sa(t2) {
    return this.Zc({
      path: void 0,
      ta: true
    });
  }
  ia(t2) {
    return rl(t2, this.settings.methodName, this.settings.ra || false, this.path, this.settings.oa);
  }
  contains(t2) {
    return void 0 !== this.fieldMask.find((e) => t2.isPrefixOf(e)) || void 0 !== this.fieldTransforms.find((e) => t2.isPrefixOf(e.field));
  }
  Jc() {
    if (this.path)
      for (let t2 = 0; t2 < this.path.length; t2++)
        this.ea(this.path.get(t2));
  }
  ea(t2) {
    if (0 === t2.length)
      throw this.ia("Document fields must not be empty");
    if (Fh(this.Yc) && Oh.test(t2))
      throw this.ia('Document fields cannot begin and end with "__"');
  }
};
var Lh = class {
  constructor(t2, e, n) {
    this.databaseId = t2, this.ignoreUndefinedProperties = e, this.serializer = n || Vu(t2);
  }
  ua(t2, e, n, s = false) {
    return new Bh({
      Yc: t2,
      methodName: e,
      oa: n,
      path: ut.emptyPath(),
      ta: false,
      ra: s
    }, this.databaseId, this.serializer, this.ignoreUndefinedProperties);
  }
};
function qh(t2) {
  const e = t2._freezeSettings(), n = Vu(t2._databaseId);
  return new Lh(t2._databaseId, !!e.ignoreUndefinedProperties, n);
}
function Uh(t2, e, n, s, i, r = {}) {
  const o = t2.ua(r.merge || r.mergeFields ? 2 : 0, e, n, i);
  el("Data must be an object, but it was:", o, s);
  const u = Xh(s, o);
  let c, a;
  if (r.merge)
    c = new Ae(o.fieldMask), a = o.fieldTransforms;
  else if (r.mergeFields) {
    const t3 = [];
    for (const s2 of r.mergeFields) {
      const i2 = nl(e, s2, n);
      if (!o.contains(i2))
        throw new L2(B2.INVALID_ARGUMENT, `Field '${i2}' is specified in your field mask but missing from your input data.`);
      ol(t3, i2) || t3.push(i2);
    }
    c = new Ae(t3), a = o.fieldTransforms.filter((t4) => c.covers(t4.field));
  } else
    c = null, a = o.fieldTransforms;
  return new $h(new sn(u), c, a);
}
var Kh = class extends Nh {
  _toFieldTransform(t2) {
    if (2 !== t2.Yc)
      throw 1 === t2.Yc ? t2.ia(`${this._methodName}() can only appear at the top level of your update data`) : t2.ia(`${this._methodName}() cannot be used with set() unless you pass {merge:true}`);
    return t2.fieldMask.push(t2.path), null;
  }
  isEqual(t2) {
    return t2 instanceof Kh;
  }
};
function Gh(t2, e, n) {
  return new Bh({
    Yc: 3,
    oa: e.settings.oa,
    methodName: t2._methodName,
    ta: n
  }, e.databaseId, e.serializer, e.ignoreUndefinedProperties);
}
var Qh = class extends Nh {
  _toFieldTransform(t2) {
    return new xs(t2.path, new Rs());
  }
  isEqual(t2) {
    return t2 instanceof Qh;
  }
};
var zh = class extends Nh {
  constructor(t2, e) {
    super(t2), this.ca = e;
  }
  _toFieldTransform(t2) {
    const e = Gh(
      this,
      t2,
      true
    ), n = this.ca.map((t3) => Zh(t3, e)), s = new vs(n);
    return new xs(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var jh = class extends Nh {
  constructor(t2, e) {
    super(t2), this.ca = e;
  }
  _toFieldTransform(t2) {
    const e = Gh(
      this,
      t2,
      true
    ), n = this.ca.map((t3) => Zh(t3, e)), s = new Ps(n);
    return new xs(t2.path, s);
  }
  isEqual(t2) {
    return this === t2;
  }
};
var Wh = class extends Nh {
  constructor(t2, e) {
    super(t2), this.aa = e;
  }
  _toFieldTransform(t2) {
    const e = new Ss(t2.serializer, ps(t2.serializer, this.aa));
    return new xs(t2.path, e);
  }
  isEqual(t2) {
    return this === t2;
  }
};
function Hh(t2, e, n, s) {
  const i = t2.ua(1, e, n);
  el("Data must be an object, but it was:", i, s);
  const r = [], o = sn.empty();
  _e(s, (t3, s2) => {
    const u2 = il(e, t3, n);
    s2 = getModularInstance(s2);
    const c = i.na(u2);
    if (s2 instanceof Kh)
      r.push(u2);
    else {
      const t4 = Zh(s2, c);
      null != t4 && (r.push(u2), o.set(u2, t4));
    }
  });
  const u = new Ae(r);
  return new Mh(o, u, i.fieldTransforms);
}
function Jh(t2, e, n, s, i, r) {
  const o = t2.ua(1, e, n), u = [nl(e, s, n)], c = [i];
  if (r.length % 2 != 0)
    throw new L2(B2.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`);
  for (let t3 = 0; t3 < r.length; t3 += 2)
    u.push(nl(e, r[t3])), c.push(r[t3 + 1]);
  const a = [], h = sn.empty();
  for (let t3 = u.length - 1; t3 >= 0; --t3)
    if (!ol(a, u[t3])) {
      const e2 = u[t3];
      let n2 = c[t3];
      n2 = getModularInstance(n2);
      const s2 = o.na(e2);
      if (n2 instanceof Kh)
        a.push(e2);
      else {
        const t4 = Zh(n2, s2);
        null != t4 && (a.push(e2), h.set(e2, t4));
      }
    }
  const l2 = new Ae(a);
  return new Mh(h, l2, o.fieldTransforms);
}
function Yh(t2, e, n, s = false) {
  return Zh(n, t2.ua(s ? 4 : 3, e));
}
function Zh(t2, e) {
  if (tl(
    t2 = getModularInstance(t2)
  ))
    return el("Unsupported field value:", e, t2), Xh(t2, e);
  if (t2 instanceof Nh)
    return function(t3, e2) {
      if (!Fh(e2.Yc))
        throw e2.ia(`${t3._methodName}() can only be used with update() and set()`);
      if (!e2.path)
        throw e2.ia(`${t3._methodName}() is not currently supported inside arrays`);
      const n = t3._toFieldTransform(e2);
      n && e2.fieldTransforms.push(n);
    }(t2, e), null;
  if (void 0 === t2 && e.ignoreUndefinedProperties)
    return null;
  if (e.path && e.fieldMask.push(e.path), t2 instanceof Array) {
    if (e.settings.ta && 4 !== e.Yc)
      throw e.ia("Nested arrays are not supported");
    return function(t3, e2) {
      const n = [];
      let s = 0;
      for (const i of t3) {
        let t4 = Zh(i, e2.sa(s));
        null == t4 && (t4 = {
          nullValue: "NULL_VALUE"
        }), n.push(t4), s++;
      }
      return {
        arrayValue: {
          values: n
        }
      };
    }(t2, e);
  }
  return function(t3, e2) {
    if (null === (t3 = getModularInstance(t3)))
      return {
        nullValue: "NULL_VALUE"
      };
    if ("number" == typeof t3)
      return ps(e2.serializer, t3);
    if ("boolean" == typeof t3)
      return {
        booleanValue: t3
      };
    if ("string" == typeof t3)
      return {
        stringValue: t3
      };
    if (t3 instanceof Date) {
      const n = nt.fromDate(t3);
      return {
        timestampValue: Ei(e2.serializer, n)
      };
    }
    if (t3 instanceof nt) {
      const n = new nt(t3.seconds, 1e3 * Math.floor(t3.nanoseconds / 1e3));
      return {
        timestampValue: Ei(e2.serializer, n)
      };
    }
    if (t3 instanceof kh)
      return {
        geoPointValue: {
          latitude: t3.latitude,
          longitude: t3.longitude
        }
      };
    if (t3 instanceof Dh)
      return {
        bytesValue: Ai(e2.serializer, t3._byteString)
      };
    if (t3 instanceof th) {
      const n = e2.databaseId, s = t3.firestore._databaseId;
      if (!s.isEqual(n))
        throw e2.ia(`Document reference is for database ${s.projectId}/${s.database} but should be for database ${n.projectId}/${n.database}`);
      return {
        referenceValue: bi(t3.firestore._databaseId || e2.databaseId, t3._key.path)
      };
    }
    throw e2.ia(`Unsupported field value: ${Wa2(t3)}`);
  }(t2, e);
}
function Xh(t2, e) {
  const n = {};
  return me(t2) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : _e(t2, (t3, s) => {
    const i = Zh(s, e.Xc(t3));
    null != i && (n[t3] = i);
  }), {
    mapValue: {
      fields: n
    }
  };
}
function tl(t2) {
  return !("object" != typeof t2 || null === t2 || t2 instanceof Array || t2 instanceof Date || t2 instanceof nt || t2 instanceof kh || t2 instanceof Dh || t2 instanceof th || t2 instanceof Nh);
}
function el(t2, e, n) {
  if (!tl(n) || !function(t3) {
    return "object" == typeof t3 && null !== t3 && (Object.getPrototypeOf(t3) === Object.prototype || null === Object.getPrototypeOf(t3));
  }(n)) {
    const s = Wa2(n);
    throw "an object" === s ? e.ia(t2 + " a custom object") : e.ia(t2 + " " + s);
  }
}
function nl(t2, e, n) {
  if ((e = getModularInstance(e)) instanceof Ch)
    return e._internalPath;
  if ("string" == typeof e)
    return il(t2, e);
  throw rl(
    "Field path arguments must be of type string or ",
    t2,
    false,
    void 0,
    n
  );
}
var sl = new RegExp("[~\\*/\\[\\]]");
function il(t2, e, n) {
  if (e.search(sl) >= 0)
    throw rl(
      `Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`,
      t2,
      false,
      void 0,
      n
    );
  try {
    return new Ch(...e.split("."))._internalPath;
  } catch (s) {
    throw rl(
      `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`,
      t2,
      false,
      void 0,
      n
    );
  }
}
function rl(t2, e, n, s, i) {
  const r = s && !s.isEmpty(), o = void 0 !== i;
  let u = `Function ${e}() called with invalid data`;
  n && (u += " (via `toFirestore()`)"), u += ". ";
  let c = "";
  return (r || o) && (c += " (found", r && (c += ` in field ${s}`), o && (c += ` in document ${i}`), c += ")"), new L2(B2.INVALID_ARGUMENT, u + t2 + c);
}
function ol(t2, e) {
  return t2.some((t3) => t3.isEqual(e));
}
var ul = class {
  constructor(t2, e, n, s, i) {
    this._firestore = t2, this._userDataWriter = e, this._key = n, this._document = s, this._converter = i;
  }
  get id() {
    return this._key.path.lastSegment();
  }
  get ref() {
    return new th(this._firestore, this._converter, this._key);
  }
  exists() {
    return null !== this._document;
  }
  data() {
    if (this._document) {
      if (this._converter) {
        const t2 = new cl(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          null
        );
        return this._converter.fromFirestore(t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value);
    }
  }
  get(t2) {
    if (this._document) {
      const e = this._document.data.field(al("DocumentSnapshot.get", t2));
      if (null !== e)
        return this._userDataWriter.convertValue(e);
    }
  }
};
var cl = class extends ul {
  data() {
    return super.data();
  }
};
function al(t2, e) {
  return "string" == typeof e ? il(t2, e) : e instanceof Ch ? e._internalPath : e._delegate._internalPath;
}
function hl(t2) {
  if ("L" === t2.limitType && 0 === t2.explicitOrderBy.length)
    throw new L2(B2.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause");
}
var ll = class {
};
var fl = class extends ll {
};
function dl(t2, e, ...n) {
  let s = [];
  e instanceof ll && s.push(e), s = s.concat(n), function(t3) {
    const e2 = t3.filter((t4) => t4 instanceof ml).length, n2 = t3.filter((t4) => t4 instanceof wl).length;
    if (e2 > 1 || e2 > 0 && n2 > 0)
      throw new L2(B2.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.");
  }(s);
  for (const e2 of s)
    t2 = e2._apply(t2);
  return t2;
}
var wl = class extends fl {
  constructor(t2, e, n) {
    super(), this._field = t2, this._op = e, this._value = n, this.type = "where";
  }
  static _create(t2, e, n) {
    return new wl(t2, e, n);
  }
  _apply(t2) {
    const e = this._parse(t2);
    return Nl(t2._query, e), new eh(t2.firestore, t2.converter, Wn(t2._query, e));
  }
  _parse(t2) {
    const e = qh(t2.firestore), n = function(t3, e2, n2, s, i, r, o) {
      let u;
      if (i.isKeyField()) {
        if ("array-contains" === r || "array-contains-any" === r)
          throw new L2(B2.INVALID_ARGUMENT, `Invalid Query. You can't perform '${r}' queries on documentId().`);
        if ("in" === r || "not-in" === r) {
          xl(o, r);
          const e3 = [];
          for (const n3 of o)
            e3.push(Cl(s, t3, n3));
          u = {
            arrayValue: {
              values: e3
            }
          };
        } else
          u = Cl(s, t3, o);
      } else
        "in" !== r && "not-in" !== r && "array-contains-any" !== r || xl(o, r), u = Yh(
          n2,
          e2,
          o,
          "in" === r || "not-in" === r
        );
      return dn.create(i, r, u);
    }(t2._query, "where", e, t2.firestore._databaseId, this._field, this._op, this._value);
    return n;
  }
};
function _l(t2, e, n) {
  const s = e, i = al("where", t2);
  return wl._create(i, s, n);
}
var ml = class extends ll {
  constructor(t2, e) {
    super(), this.type = t2, this._queryConstraints = e;
  }
  static _create(t2, e) {
    return new ml(t2, e);
  }
  _parse(t2) {
    const e = this._queryConstraints.map((e2) => e2._parse(t2)).filter((t3) => t3.getFilters().length > 0);
    return 1 === e.length ? e[0] : wn.create(e, this._getOperator());
  }
  _apply(t2) {
    const e = this._parse(t2);
    return 0 === e.getFilters().length ? t2 : (function(t3, e2) {
      let n = t3;
      const s = e2.getFlattenedFilters();
      for (const t4 of s)
        Nl(n, t4), n = Wn(n, t4);
    }(t2._query, e), new eh(t2.firestore, t2.converter, Wn(t2._query, e)));
  }
  _getQueryConstraints() {
    return this._queryConstraints;
  }
  _getOperator() {
    return "and" === this.type ? "and" : "or";
  }
};
function gl(...t2) {
  return t2.forEach((t3) => Ol("or", t3)), ml._create("or", t2);
}
function yl(...t2) {
  return t2.forEach((t3) => Ol("and", t3)), ml._create("and", t2);
}
var pl = class extends fl {
  constructor(t2, e) {
    super(), this._field = t2, this._direction = e, this.type = "orderBy";
  }
  static _create(t2, e) {
    return new pl(t2, e);
  }
  _apply(t2) {
    const e = function(t3, e2, n) {
      if (null !== t3.startAt)
        throw new L2(B2.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy().");
      if (null !== t3.endAt)
        throw new L2(B2.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy().");
      const s = new hn(e2, n);
      return function(t4, e3) {
        if (null === Kn(t4)) {
          const n2 = Gn(t4);
          null !== n2 && kl(t4, n2, e3.field);
        }
      }(t3, s), s;
    }(t2._query, this._field, this._direction);
    return new eh(t2.firestore, t2.converter, function(t3, e2) {
      const n = t3.explicitOrderBy.concat([e2]);
      return new Bn(t3.path, t3.collectionGroup, n, t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, t3.endAt);
    }(t2._query, e));
  }
};
function Il(t2, e = "asc") {
  const n = e, s = al("orderBy", t2);
  return pl._create(s, n);
}
var Tl = class extends fl {
  constructor(t2, e, n) {
    super(), this.type = t2, this._limit = e, this._limitType = n;
  }
  static _create(t2, e, n) {
    return new Tl(t2, e, n);
  }
  _apply(t2) {
    return new eh(t2.firestore, t2.converter, Hn(t2._query, this._limit, this._limitType));
  }
};
function El(t2) {
  return Ja2("limit", t2), Tl._create("limit", t2, "F");
}
function Al(t2) {
  return Ja2("limitToLast", t2), Tl._create("limitToLast", t2, "L");
}
var Rl = class extends fl {
  constructor(t2, e, n) {
    super(), this.type = t2, this._docOrFields = e, this._inclusive = n;
  }
  static _create(t2, e, n) {
    return new Rl(t2, e, n);
  }
  _apply(t2) {
    const e = Dl(t2, this.type, this._docOrFields, this._inclusive);
    return new eh(t2.firestore, t2.converter, function(t3, e2) {
      return new Bn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, e2, t3.endAt);
    }(t2._query, e));
  }
};
function vl(...t2) {
  return Rl._create(
    "startAt",
    t2,
    true
  );
}
function bl(...t2) {
  return Rl._create(
    "startAfter",
    t2,
    false
  );
}
var Pl = class extends fl {
  constructor(t2, e, n) {
    super(), this.type = t2, this._docOrFields = e, this._inclusive = n;
  }
  static _create(t2, e, n) {
    return new Pl(t2, e, n);
  }
  _apply(t2) {
    const e = Dl(t2, this.type, this._docOrFields, this._inclusive);
    return new eh(t2.firestore, t2.converter, function(t3, e2) {
      return new Bn(t3.path, t3.collectionGroup, t3.explicitOrderBy.slice(), t3.filters.slice(), t3.limit, t3.limitType, t3.startAt, e2);
    }(t2._query, e));
  }
};
function Vl(...t2) {
  return Pl._create(
    "endBefore",
    t2,
    false
  );
}
function Sl(...t2) {
  return Pl._create(
    "endAt",
    t2,
    true
  );
}
function Dl(t2, e, n, s) {
  if (n[0] = getModularInstance(n[0]), n[0] instanceof ul)
    return function(t3, e2, n2, s2, i) {
      if (!s2)
        throw new L2(B2.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${n2}().`);
      const r = [];
      for (const n3 of zn(t3))
        if (n3.field.isKeyField())
          r.push(Qe(e2, s2.key));
        else {
          const t4 = s2.data.field(n3.field);
          if (Ce(t4))
            throw new L2(B2.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + n3.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)');
          if (null === t4) {
            const t5 = n3.field.canonicalString();
            throw new L2(B2.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${t5}' (used as the orderBy) does not exist.`);
          }
          r.push(t4);
        }
      return new un(r, i);
    }(t2._query, t2.firestore._databaseId, e, n[0]._document, s);
  {
    const i = qh(t2.firestore);
    return function(t3, e2, n2, s2, i2, r) {
      const o = t3.explicitOrderBy;
      if (i2.length > o.length)
        throw new L2(B2.INVALID_ARGUMENT, `Too many arguments provided to ${s2}(). The number of arguments must be less than or equal to the number of orderBy() clauses`);
      const u = [];
      for (let r2 = 0; r2 < i2.length; r2++) {
        const c = i2[r2];
        if (o[r2].field.isKeyField()) {
          if ("string" != typeof c)
            throw new L2(B2.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${s2}(), but got a ${typeof c}`);
          if (!Qn(t3) && -1 !== c.indexOf("/"))
            throw new L2(B2.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${s2}() must be a plain document ID, but '${c}' contains a slash.`);
          const n3 = t3.path.child(rt.fromString(c));
          if (!ct.isDocumentKey(n3))
            throw new L2(B2.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${s2}() must result in a valid document path, but '${n3}' is not because it contains an odd number of segments.`);
          const i3 = new ct(n3);
          u.push(Qe(e2, i3));
        } else {
          const t4 = Yh(n2, s2, c);
          u.push(t4);
        }
      }
      return new un(u, r);
    }(t2._query, t2.firestore._databaseId, i, e, n, s);
  }
}
function Cl(t2, e, n) {
  if ("string" == typeof (n = getModularInstance(n))) {
    if ("" === n)
      throw new L2(B2.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string.");
    if (!Qn(e) && -1 !== n.indexOf("/"))
      throw new L2(B2.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${n}' contains a '/' character.`);
    const s = e.path.child(rt.fromString(n));
    if (!ct.isDocumentKey(s))
      throw new L2(B2.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`);
    return Qe(t2, new ct(s));
  }
  if (n instanceof th)
    return Qe(t2, n._key);
  throw new L2(B2.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${Wa2(n)}.`);
}
function xl(t2, e) {
  if (!Array.isArray(t2) || 0 === t2.length)
    throw new L2(B2.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`);
}
function Nl(t2, e) {
  if (e.isInequality()) {
    const n2 = Gn(t2), s = e.field;
    if (null !== n2 && !n2.isEqual(s))
      throw new L2(B2.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${n2.toString()}' and '${s.toString()}'`);
    const i = Kn(t2);
    null !== i && kl(t2, s, i);
  }
  const n = function(t3, e2) {
    for (const n2 of t3)
      for (const t4 of n2.getFlattenedFilters())
        if (e2.indexOf(t4.op) >= 0)
          return t4.op;
    return null;
  }(t2.filters, function(t3) {
    switch (t3) {
      case "!=":
        return ["!=", "not-in"];
      case "array-contains-any":
      case "in":
        return ["not-in"];
      case "not-in":
        return ["array-contains-any", "in", "not-in", "!="];
      default:
        return [];
    }
  }(e.op));
  if (null !== n)
    throw n === e.op ? new L2(B2.INVALID_ARGUMENT, `Invalid query. You cannot use more than one '${e.op.toString()}' filter.`) : new L2(B2.INVALID_ARGUMENT, `Invalid query. You cannot use '${e.op.toString()}' filters with '${n.toString()}' filters.`);
}
function kl(t2, e, n) {
  if (!n.isEqual(e))
    throw new L2(B2.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${n.toString()}' instead.`);
}
function Ol(t2, e) {
  if (!(e instanceof wl || e instanceof ml))
    throw new L2(B2.INVALID_ARGUMENT, `Function ${t2}() requires AppliableConstraints created with a call to 'where(...)', 'or(...)', or 'and(...)'.`);
}
var $l = class {
  convertValue(t2, e = "none") {
    switch (Fe(t2)) {
      case 0:
        return null;
      case 1:
        return t2.booleanValue;
      case 2:
        return Se(t2.integerValue || t2.doubleValue);
      case 3:
        return this.convertTimestamp(t2.timestampValue);
      case 4:
        return this.convertServerTimestamp(t2, e);
      case 5:
        return t2.stringValue;
      case 6:
        return this.convertBytes(De(t2.bytesValue));
      case 7:
        return this.convertReference(t2.referenceValue);
      case 8:
        return this.convertGeoPoint(t2.geoPointValue);
      case 9:
        return this.convertArray(t2.arrayValue, e);
      case 10:
        return this.convertObject(t2.mapValue, e);
      default:
        throw O2();
    }
  }
  convertObject(t2, e) {
    const n = {};
    return _e(t2.fields, (t3, s) => {
      n[t3] = this.convertValue(s, e);
    }), n;
  }
  convertGeoPoint(t2) {
    return new kh(Se(t2.latitude), Se(t2.longitude));
  }
  convertArray(t2, e) {
    return (t2.values || []).map((t3) => this.convertValue(t3, e));
  }
  convertServerTimestamp(t2, e) {
    switch (e) {
      case "previous":
        const n = xe(t2);
        return null == n ? null : this.convertValue(n, e);
      case "estimate":
        return this.convertTimestamp(Ne(t2));
      default:
        return null;
    }
  }
  convertTimestamp(t2) {
    const e = Ve(t2);
    return new nt(e.seconds, e.nanos);
  }
  convertDocumentKey(t2, e) {
    const n = rt.fromString(t2);
    $(Xi(n));
    const s = new Oe(n.get(1), n.get(3)), i = new ct(n.popFirst(5));
    return s.isEqual(e) || x2(`Document ${i} contains a document reference within a different database (${s.projectId}/${s.database}) which is not supported. It will be treated as a reference in the current database (${e.projectId}/${e.database}) instead.`), i;
  }
};
function Ml(t2, e, n) {
  let s;
  return s = t2 ? n && (n.merge || n.mergeFields) ? t2.toFirestore(e, n) : t2.toFirestore(e) : e, s;
}
var Fl = class extends $l {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Dh(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new th(this.firestore, null, e);
  }
};
function Bl(t2) {
  return new Vh("sum", nl("sum", t2));
}
function Ll(t2) {
  return new Vh("avg", nl("average", t2));
}
function ql() {
  return new Vh("count");
}
function Ul(t2, e) {
  var n, s;
  return t2 instanceof Vh && e instanceof Vh && t2._aggregateType === e._aggregateType && (null === (n = t2._internalFieldPath) || void 0 === n ? void 0 : n.canonicalString()) === (null === (s = e._internalFieldPath) || void 0 === s ? void 0 : s.canonicalString());
}
function Kl(t2, e) {
  return uh(t2.query, e.query) && deepEqual(t2.data(), e.data());
}
var Gl = class {
  constructor(t2, e) {
    this.hasPendingWrites = t2, this.fromCache = e;
  }
  isEqual(t2) {
    return this.hasPendingWrites === t2.hasPendingWrites && this.fromCache === t2.fromCache;
  }
};
var Ql = class extends ul {
  constructor(t2, e, n, s, i, r) {
    super(t2, e, n, s, r), this._firestore = t2, this._firestoreImpl = t2, this.metadata = i;
  }
  exists() {
    return super.exists();
  }
  data(t2 = {}) {
    if (this._document) {
      if (this._converter) {
        const e = new zl(
          this._firestore,
          this._userDataWriter,
          this._key,
          this._document,
          this.metadata,
          null
        );
        return this._converter.fromFirestore(e, t2);
      }
      return this._userDataWriter.convertValue(this._document.data.value, t2.serverTimestamps);
    }
  }
  get(t2, e = {}) {
    if (this._document) {
      const n = this._document.data.field(al("DocumentSnapshot.get", t2));
      if (null !== n)
        return this._userDataWriter.convertValue(n, e.serverTimestamps);
    }
  }
};
var zl = class extends Ql {
  data(t2 = {}) {
    return super.data(t2);
  }
};
var jl = class {
  constructor(t2, e, n, s) {
    this._firestore = t2, this._userDataWriter = e, this._snapshot = s, this.metadata = new Gl(s.hasPendingWrites, s.fromCache), this.query = n;
  }
  get docs() {
    const t2 = [];
    return this.forEach((e) => t2.push(e)), t2;
  }
  get size() {
    return this._snapshot.docs.size;
  }
  get empty() {
    return 0 === this.size;
  }
  forEach(t2, e) {
    this._snapshot.docs.forEach((n) => {
      t2.call(e, new zl(this._firestore, this._userDataWriter, n.key, n, new Gl(this._snapshot.mutatedKeys.has(n.key), this._snapshot.fromCache), this.query.converter));
    });
  }
  docChanges(t2 = {}) {
    const e = !!t2.includeMetadataChanges;
    if (e && this._snapshot.excludesMetadataChanges)
      throw new L2(B2.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot().");
    return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === e || (this._cachedChanges = function(t3, e2) {
      if (t3._snapshot.oldDocs.isEmpty()) {
        let e3 = 0;
        return t3._snapshot.docChanges.map((n) => {
          const s = new zl(t3._firestore, t3._userDataWriter, n.doc.key, n.doc, new Gl(t3._snapshot.mutatedKeys.has(n.doc.key), t3._snapshot.fromCache), t3.query.converter);
          return n.doc, {
            type: "added",
            doc: s,
            oldIndex: -1,
            newIndex: e3++
          };
        });
      }
      {
        let n = t3._snapshot.oldDocs;
        return t3._snapshot.docChanges.filter((t4) => e2 || 3 !== t4.type).map((e3) => {
          const s = new zl(t3._firestore, t3._userDataWriter, e3.doc.key, e3.doc, new Gl(t3._snapshot.mutatedKeys.has(e3.doc.key), t3._snapshot.fromCache), t3.query.converter);
          let i = -1, r = -1;
          return 0 !== e3.type && (i = n.indexOf(e3.doc.key), n = n.delete(e3.doc.key)), 1 !== e3.type && (n = n.add(e3.doc), r = n.indexOf(e3.doc.key)), {
            type: Wl(e3.type),
            doc: s,
            oldIndex: i,
            newIndex: r
          };
        });
      }
    }(this, e), this._cachedChangesIncludeMetadataChanges = e), this._cachedChanges;
  }
};
function Wl(t2) {
  switch (t2) {
    case 0:
      return "added";
    case 2:
    case 3:
      return "modified";
    case 1:
      return "removed";
    default:
      return O2();
  }
}
function Hl(t2, e) {
  return t2 instanceof Ql && e instanceof Ql ? t2._firestore === e._firestore && t2._key.isEqual(e._key) && (null === t2._document ? null === e._document : t2._document.isEqual(e._document)) && t2._converter === e._converter : t2 instanceof jl && e instanceof jl && (t2._firestore === e._firestore && uh(t2.query, e.query) && t2.metadata.isEqual(e.metadata) && t2._snapshot.isEqual(e._snapshot));
}
function Jl(t2) {
  t2 = Ha(t2, th);
  const e = Ha(t2.firestore, fh);
  return $a2(_h(e), t2._key).then((n) => lf(e, t2, n));
}
var Yl = class extends $l {
  constructor(t2) {
    super(), this.firestore = t2;
  }
  convertBytes(t2) {
    return new Dh(t2);
  }
  convertReference(t2) {
    const e = this.convertDocumentKey(t2, this.firestore._databaseId);
    return new th(this.firestore, null, e);
  }
};
function Zl(t2) {
  t2 = Ha(t2, th);
  const e = Ha(t2.firestore, fh), n = _h(e), s = new Yl(e);
  return Oa2(n, t2._key).then((n2) => new Ql(e, s, t2._key, n2, new Gl(
    null !== n2 && n2.hasLocalMutations,
    true
  ), t2.converter));
}
function Xl(t2) {
  t2 = Ha(t2, th);
  const e = Ha(t2.firestore, fh);
  return $a2(_h(e), t2._key, {
    source: "server"
  }).then((n) => lf(e, t2, n));
}
function tf(t2) {
  t2 = Ha(t2, eh);
  const e = Ha(t2.firestore, fh), n = _h(e), s = new Yl(e);
  return hl(t2._query), Fa(n, t2._query).then((n2) => new jl(e, s, t2, n2));
}
function ef(t2) {
  t2 = Ha(t2, eh);
  const e = Ha(t2.firestore, fh), n = _h(e), s = new Yl(e);
  return Ma2(n, t2._query).then((n2) => new jl(e, s, t2, n2));
}
function nf(t2) {
  t2 = Ha(t2, eh);
  const e = Ha(t2.firestore, fh), n = _h(e), s = new Yl(e);
  return Fa(n, t2._query, {
    source: "server"
  }).then((n2) => new jl(e, s, t2, n2));
}
function sf(t2, e, n) {
  t2 = Ha(t2, th);
  const s = Ha(t2.firestore, fh), i = Ml(t2.converter, e, n);
  return hf(s, [Uh(qh(s), "setDoc", t2._key, i, null !== t2.converter, n).toMutation(t2._key, Os.none())]);
}
function rf(t2, e, n, ...s) {
  t2 = Ha(t2, th);
  const i = Ha(t2.firestore, fh), r = qh(i);
  let o;
  o = "string" == typeof (e = getModularInstance(e)) || e instanceof Ch ? Jh(r, "updateDoc", t2._key, e, n, s) : Hh(r, "updateDoc", t2._key, e);
  return hf(i, [o.toMutation(t2._key, Os.exists(true))]);
}
function of(t2) {
  return hf(Ha(t2.firestore, fh), [new Ws(t2._key, Os.none())]);
}
function uf(t2, e) {
  const n = Ha(t2.firestore, fh), s = rh(t2), i = Ml(t2.converter, e);
  return hf(n, [Uh(qh(t2.firestore), "addDoc", s._key, i, null !== t2.converter, {}).toMutation(s._key, Os.exists(false))]).then(() => s);
}
function cf(t2, ...e) {
  var n, s, i;
  t2 = getModularInstance(t2);
  let r = {
    includeMetadataChanges: false
  }, o = 0;
  "object" != typeof e[o] || ah(e[o]) || (r = e[o], o++);
  const u = {
    includeMetadataChanges: r.includeMetadataChanges
  };
  if (ah(e[o])) {
    const t3 = e[o];
    e[o] = null === (n = t3.next) || void 0 === n ? void 0 : n.bind(t3), e[o + 1] = null === (s = t3.error) || void 0 === s ? void 0 : s.bind(t3), e[o + 2] = null === (i = t3.complete) || void 0 === i ? void 0 : i.bind(t3);
  }
  let c, a, h;
  if (t2 instanceof th)
    a = Ha(t2.firestore, fh), h = qn(t2._key.path), c = {
      next: (n2) => {
        e[o] && e[o](lf(a, t2, n2));
      },
      error: e[o + 1],
      complete: e[o + 2]
    };
  else {
    const n2 = Ha(t2, eh);
    a = Ha(n2.firestore, fh), h = n2._query;
    const s2 = new Yl(a);
    c = {
      next: (t3) => {
        e[o] && e[o](new jl(a, s2, n2, t3));
      },
      error: e[o + 1],
      complete: e[o + 2]
    }, hl(t2._query);
  }
  return function(t3, e2, n2, s2) {
    const i2 = new ga(s2), r2 = new Ac2(e2, i2, n2);
    return t3.asyncQueue.enqueueAndForget(async () => yc2(await xa2(t3), r2)), () => {
      i2.yc(), t3.asyncQueue.enqueueAndForget(async () => pc2(await xa2(t3), r2));
    };
  }(_h(a), h, u, c);
}
function af(t2, e) {
  return Ba2(_h(t2 = Ha(t2, fh)), ah(e) ? e : {
    next: e
  });
}
function hf(t2, e) {
  return function(t3, e2) {
    const n = new q2();
    return t3.asyncQueue.enqueueAndForget(async () => Mc2(await Da(t3), e2, n)), n.promise;
  }(_h(t2), e);
}
function lf(t2, e, n) {
  const s = n.docs.get(e._key), i = new Yl(t2);
  return new Ql(t2, i, e._key, s, new Gl(n.hasPendingWrites, n.fromCache), e.converter);
}
function ff(t2) {
  return df(t2, {
    count: ql()
  });
}
function df(t2, e) {
  const n = Ha(t2.firestore, fh), s = _h(n), i = function(t3, e2) {
    const n2 = [];
    for (const s2 in t3)
      Object.prototype.hasOwnProperty.call(t3, s2) && n2.push(e2(t3[s2], s2, t3));
    return n2;
  }(e, (t3, e2) => new ei(new ti(e2), t3._aggregateType, t3._internalFieldPath));
  return function(t3, e2, n2) {
    const s2 = new q2();
    return t3.asyncQueue.enqueueAndForget(async () => {
      try {
        if (Qu(await Sa2(t3))) {
          const i2 = await Ca(t3);
          s2.resolve(ku(i2, e2, n2));
        } else
          s2.reject(new L2(B2.UNAVAILABLE, "Failed to get aggregate result because the client is offline."));
      } catch (t4) {
        s2.reject(t4);
      }
    }), s2.promise;
  }(s, t2._query, i).then((e2) => function(t3, e3, n2) {
    const s2 = new Yl(t3);
    return new Sh(e3, s2, n2);
  }(n, t2, e2));
}
var wf = class {
  constructor() {
    this.kind = "memory", this._onlineComponentProvider = new _a(), this._offlineComponentProvider = new fa2();
  }
  toJSON() {
    return {
      kind: this.kind
    };
  }
};
var _f = class {
  constructor(t2) {
    let e;
    this.kind = "persistent", (null == t2 ? void 0 : t2.tabManager) ? (t2.tabManager._initialize(t2), e = t2.tabManager) : (e = If(void 0), e._initialize(t2)), this._onlineComponentProvider = e._onlineComponentProvider, this._offlineComponentProvider = e._offlineComponentProvider;
  }
  toJSON() {
    return {
      kind: this.kind
    };
  }
};
function mf() {
  return new wf();
}
function gf(t2) {
  return new _f(t2);
}
var yf = class {
  constructor(t2) {
    this.forceOwnership = t2, this.kind = "persistentSingleTab";
  }
  toJSON() {
    return {
      kind: this.kind
    };
  }
  _initialize(t2) {
    this._onlineComponentProvider = new _a(), this._offlineComponentProvider = new da2(this._onlineComponentProvider, null == t2 ? void 0 : t2.cacheSizeBytes, this.forceOwnership);
  }
};
var pf = class {
  constructor() {
    this.kind = "PersistentMultipleTab";
  }
  toJSON() {
    return {
      kind: this.kind
    };
  }
  _initialize(t2) {
    this._onlineComponentProvider = new _a(), this._offlineComponentProvider = new wa2(this._onlineComponentProvider, null == t2 ? void 0 : t2.cacheSizeBytes);
  }
};
function If(t2) {
  return new yf(null == t2 ? void 0 : t2.forceOwnership);
}
function Tf() {
  return new pf();
}
var Ef = {
  maxAttempts: 5
};
var Af = class {
  constructor(t2, e) {
    this._firestore = t2, this._commitHandler = e, this._mutations = [], this._committed = false, this._dataReader = qh(t2);
  }
  set(t2, e, n) {
    this._verifyNotCommitted();
    const s = Rf(t2, this._firestore), i = Ml(s.converter, e, n), r = Uh(this._dataReader, "WriteBatch.set", s._key, i, null !== s.converter, n);
    return this._mutations.push(r.toMutation(s._key, Os.none())), this;
  }
  update(t2, e, n, ...s) {
    this._verifyNotCommitted();
    const i = Rf(t2, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Ch ? Jh(this._dataReader, "WriteBatch.update", i._key, e, n, s) : Hh(this._dataReader, "WriteBatch.update", i._key, e), this._mutations.push(r.toMutation(i._key, Os.exists(true))), this;
  }
  delete(t2) {
    this._verifyNotCommitted();
    const e = Rf(t2, this._firestore);
    return this._mutations = this._mutations.concat(new Ws(e._key, Os.none())), this;
  }
  commit() {
    return this._verifyNotCommitted(), this._committed = true, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve();
  }
  _verifyNotCommitted() {
    if (this._committed)
      throw new L2(B2.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.");
  }
};
function Rf(t2, e) {
  if ((t2 = getModularInstance(t2)).firestore !== e)
    throw new L2(B2.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance.");
  return t2;
}
var vf = class extends class {
  constructor(t2, e) {
    this._firestore = t2, this._transaction = e, this._dataReader = qh(t2);
  }
  get(t2) {
    const e = Rf(t2, this._firestore), n = new Fl(this._firestore);
    return this._transaction.lookup([e._key]).then((t3) => {
      if (!t3 || 1 !== t3.length)
        return O2();
      const s = t3[0];
      if (s.isFoundDocument())
        return new ul(this._firestore, n, s.key, s, e.converter);
      if (s.isNoDocument())
        return new ul(this._firestore, n, e._key, null, e.converter);
      throw O2();
    });
  }
  set(t2, e, n) {
    const s = Rf(t2, this._firestore), i = Ml(s.converter, e, n), r = Uh(this._dataReader, "Transaction.set", s._key, i, null !== s.converter, n);
    return this._transaction.set(s._key, r), this;
  }
  update(t2, e, n, ...s) {
    const i = Rf(t2, this._firestore);
    let r;
    return r = "string" == typeof (e = getModularInstance(e)) || e instanceof Ch ? Jh(this._dataReader, "Transaction.update", i._key, e, n, s) : Hh(this._dataReader, "Transaction.update", i._key, e), this._transaction.update(i._key, r), this;
  }
  delete(t2) {
    const e = Rf(t2, this._firestore);
    return this._transaction.delete(e._key), this;
  }
} {
  constructor(t2, e) {
    super(t2, e), this._firestore = t2;
  }
  get(t2) {
    const e = Rf(t2, this._firestore), n = new Yl(this._firestore);
    return super.get(t2).then((t3) => new Ql(this._firestore, n, e._key, t3._document, new Gl(
      false,
      false
    ), e.converter));
  }
};
function bf(t2, e, n) {
  t2 = Ha(t2, fh);
  const s = Object.assign(Object.assign({}, Ef), n);
  !function(t3) {
    if (t3.maxAttempts < 1)
      throw new L2(B2.INVALID_ARGUMENT, "Max attempts must be at least 1");
  }(s);
  return function(t3, e2, n2) {
    const s2 = new q2();
    return t3.asyncQueue.enqueueAndForget(async () => {
      const i = await Ca(t3);
      new Ia2(t3.asyncQueue, i, n2, e2, s2).run();
    }), s2.promise;
  }(_h(t2), (n2) => e(new vf(t2, n2)), s);
}
function Pf() {
  return new Kh("deleteField");
}
function Vf() {
  return new Qh("serverTimestamp");
}
function Sf(...t2) {
  return new zh("arrayUnion", t2);
}
function Df(...t2) {
  return new jh("arrayRemove", t2);
}
function Cf(t2) {
  return new Wh("increment", t2);
}
function xf(t2) {
  return _h(t2 = Ha(t2, fh)), new Af(t2, (e) => hf(t2, e));
}
function Nf(t2, e) {
  var n;
  const s = _h(t2 = Ha(t2, fh));
  if (!s._uninitializedComponentsProvider || "memory" === (null === (n = s._uninitializedComponentsProvider) || void 0 === n ? void 0 : n._offlineKind))
    return N2("Cannot enable indexes when persistence is disabled"), Promise.resolve();
  const i = function(t3) {
    const e2 = "string" == typeof t3 ? function(t4) {
      try {
        return JSON.parse(t4);
      } catch (t5) {
        throw new L2(B2.INVALID_ARGUMENT, "Failed to parse JSON: " + (null == t5 ? void 0 : t5.message));
      }
    }(t3) : t3, n2 = [];
    if (Array.isArray(e2.indexes))
      for (const t4 of e2.indexes) {
        const e3 = kf(t4, "collectionGroup"), s2 = [];
        if (Array.isArray(t4.fields))
          for (const e4 of t4.fields) {
            const t5 = il("setIndexConfiguration", kf(e4, "fieldPath"));
            "CONTAINS" === e4.arrayConfig ? s2.push(new dt(t5, 2)) : "ASCENDING" === e4.order ? s2.push(new dt(t5, 0)) : "DESCENDING" === e4.order && s2.push(new dt(t5, 1));
          }
        n2.push(new at(at.UNKNOWN_ID, e3, s2, _t.empty()));
      }
    return n2;
  }(e);
  return Ua2(s, i);
}
function kf(t2, e) {
  if ("string" != typeof t2[e])
    throw new L2(B2.INVALID_ARGUMENT, "Missing string value for: " + e);
  return t2[e];
}
!function(t2, e = true) {
  !function(t3) {
    P2 = t3;
  }(SDK_VERSION), _registerComponent(new Component("firestore", (t3, { instanceIdentifier: n, options: s }) => {
    const i = t3.getProvider("app").getImmediate(), r = new fh(new Q2(t3.getProvider("auth-internal")), new H2(t3.getProvider("app-check-internal")), function(t4, e2) {
      if (!Object.prototype.hasOwnProperty.apply(t4.options, ["projectId"]))
        throw new L2(B2.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.');
      return new Oe(t4.options.projectId, e2);
    }(i, n), i);
    return s = Object.assign({
      useFetchStreams: e
    }, s), r._setSettings(s), r;
  }, "PUBLIC").setMultipleInstances(true)), registerVersion(v2, "3.10.0", t2), registerVersion(v2, "3.10.0", "esm2017");
}();
export {
  $l as AbstractUserDataWriter,
  Vh as AggregateField,
  Sh as AggregateQuerySnapshot,
  Dh as Bytes,
  lh as CACHE_SIZE_UNLIMITED,
  nh as CollectionReference,
  th as DocumentReference,
  Ql as DocumentSnapshot,
  Ch as FieldPath,
  Nh as FieldValue,
  fh as Firestore,
  L2 as FirestoreError,
  kh as GeoPoint,
  hh as LoadBundleTask,
  eh as Query,
  ml as QueryCompositeFilterConstraint,
  fl as QueryConstraint,
  zl as QueryDocumentSnapshot,
  Pl as QueryEndAtConstraint,
  wl as QueryFieldFilterConstraint,
  Tl as QueryLimitConstraint,
  pl as QueryOrderByConstraint,
  jl as QuerySnapshot,
  Rl as QueryStartAtConstraint,
  Gl as SnapshotMetadata,
  nt as Timestamp,
  vf as Transaction,
  Af as WriteBatch,
  Oe as _DatabaseId,
  ct as _DocumentKey,
  J2 as _EmptyAppCheckTokenProvider,
  K2 as _EmptyAuthCredentialsProvider,
  ut as _FieldPath,
  ui as _TestingHooks,
  Ha as _cast,
  M2 as _debugAssert,
  ve as _isBase64Available,
  N2 as _logWarn,
  Qa2 as _validateIsNotUsedTogether,
  uf as addDoc,
  Ul as aggregateFieldEqual,
  Kl as aggregateQuerySnapshotEqual,
  yl as and,
  Df as arrayRemove,
  Sf as arrayUnion,
  Ll as average,
  Ih as clearIndexedDbPersistence,
  sh as collection,
  ih as collectionGroup,
  Xa2 as connectFirestoreEmulator,
  ql as count,
  of as deleteDoc,
  Pf as deleteField,
  Ah as disableNetwork,
  rh as doc,
  xh as documentId,
  gh as enableIndexedDbPersistence,
  yh as enableMultiTabIndexedDbPersistence,
  Eh as enableNetwork,
  Sl as endAt,
  Vl as endBefore,
  _h as ensureFirestoreConfigured,
  hf as executeWrite,
  df as getAggregateFromServer,
  ff as getCountFromServer,
  Jl as getDoc,
  Zl as getDocFromCache,
  Xl as getDocFromServer,
  tf as getDocs,
  ef as getDocsFromCache,
  nf as getDocsFromServer,
  wh as getFirestore,
  Cf as increment,
  dh as initializeFirestore,
  El as limit,
  Al as limitToLast,
  vh as loadBundle,
  mf as memoryLocalCache,
  bh as namedQuery,
  cf as onSnapshot,
  af as onSnapshotsInSync,
  gl as or,
  Il as orderBy,
  gf as persistentLocalCache,
  Tf as persistentMultipleTabManager,
  If as persistentSingleTabManager,
  dl as query,
  uh as queryEqual,
  oh as refEqual,
  bf as runTransaction,
  Vf as serverTimestamp,
  sf as setDoc,
  Nf as setIndexConfiguration,
  D2 as setLogLevel,
  Hl as snapshotEqual,
  bl as startAfter,
  vl as startAt,
  Bl as sum,
  Rh as terminate,
  rf as updateDoc,
  Th as waitForPendingWrites,
  _l as where,
  xf as writeBatch
};
/**
 * @license
 * Copyright 2017 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2021 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * @license
 * Copyright 2023 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
* @license
* Copyright 2017 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
* @license
* Copyright 2020 Google LLC
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
//# sourceMappingURL=firebase_firestore.js.map
